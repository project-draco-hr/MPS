{
  List<INodeSubstituteAction> result=new ArrayList<INodeSubstituteAction>();
{
    ConceptDeclaration concept=SModelUtil_new.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.IntegerConstant",operationContext.getScope());
    result.add(new DefaultSimpleSubstituteAction(concept,parentNode,currentTargetNode,childSetter,operationContext.getScope()){
      public SNode createChildNode(      Object parameterObject,      SModel model,      String pattern){
        SNode intConst=SModelOperations.createNewNode(model,"jetbrains.mps.baseLanguage.structure.IntegerConstant",null);
        SPropertyOperations.set(intConst,"value","" + (Integer.parseInt(pattern)));
        return intConst;
      }
      public boolean hasSubstitute(){
        return true;
      }
      public boolean canSubstitute_internal(      String pattern){
        return Pattern.compile("(?:\\d)+",0).matcher(pattern).matches();
      }
      public String getMatchingText(      String pattern){
        return pattern;
      }
    }
);
  }
{
    ConceptDeclaration concept=SModelUtil_new.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.BooleanConstant",operationContext.getScope());
    Calculable calc=new Calculable(){
      public Object calculate(){
        return ListOperations.createList(new Boolean[]{Boolean.TRUE,Boolean.FALSE});
      }
    }
;
    Iterable<Boolean> queryResult=(Iterable)calc.calculate();
    for (    Boolean item : queryResult) {
      result.add(new DefaultChildNodeSubstituteAction(item,parentNode,currentTargetNode,childSetter,operationContext.getScope()){
        public SNode createChildNode(        Object parameterObject,        SModel model,        String pattern){
          SNode integerConst=SModelOperations.createNewNode(model,"jetbrains.mps.baseLanguage.structure.BooleanConstant",null);
          SPropertyOperations.set(integerConst,"value","" + (((Boolean)this.getParameterObject()).booleanValue()));
          return integerConst;
        }
        public String getMatchingText(        String pattern){
          return ((Boolean)this.getParameterObject()).toString();
        }
      }
);
    }
  }
{
    ConceptDeclaration concept=SModelUtil_new.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.FloatingPointConstant",operationContext.getScope());
    result.add(new DefaultSimpleSubstituteAction(concept,parentNode,currentTargetNode,childSetter,operationContext.getScope()){
      public SNode createChildNode(      Object parameterObject,      SModel model,      String pattern){
        SNode boolConst=SModelOperations.createNewNode(model,"jetbrains.mps.baseLanguage.structure.FloatingPointConstant",null);
        SPropertyOperations.set(boolConst,"value",pattern);
        return boolConst;
      }
      public boolean hasSubstitute(){
        return true;
      }
      public boolean canSubstitute_internal(      String pattern){
        return Pattern.compile("(?:(?:(?:-)?))(?:(?:(?:\\d)+)(?:(?:\\.)(?:(?:\\d)*)))",0).matcher(pattern).matches();
      }
      public String getMatchingText(      String pattern){
        return pattern;
      }
    }
);
  }
{
    ConceptDeclaration concept=SModelUtil_new.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.StringLiteral",operationContext.getScope());
    result.add(new DefaultSimpleSubstituteAction(concept,parentNode,currentTargetNode,childSetter,operationContext.getScope()){
      public SNode createChildNode(      Object parameterObject,      SModel model,      String pattern){
        SNode stringLiteral=SModelOperations.createNewNode(model,"jetbrains.mps.baseLanguage.structure.StringLiteral",null);
{
          Pattern _pattern_0=Pattern.compile("(?:(?:\")(?:((?:[^\\\"])*)))(?:(?:\")?)",0);
          Matcher _matcher_0=_pattern_0.matcher(pattern);
          if (_matcher_0.matches()) {
            SPropertyOperations.set(stringLiteral,"value",_matcher_0.group(1));
          }
        }
        return stringLiteral;
      }
      public boolean hasSubstitute(){
        return true;
      }
      public boolean canSubstitute_internal(      String pattern){
        return Pattern.compile("(?:\")(?:(?:(?:[^\\\"])*)(?:(?:\")?))",0).matcher(pattern).matches();
      }
      public String getMatchingText(      String pattern){
        return pattern;
      }
    }
);
  }
  return result;
}
