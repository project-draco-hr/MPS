{
  List<INodeSubstituteAction> result=new ArrayList<INodeSubstituteAction>();
{
    ConceptDeclaration concept=SModelUtil_new.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.BinaryOperation",operationContext.getScope());
    Calculable calculable=new Calculable(){
      public Object calculate(){
        return SConceptOperations.getAllSubConcepts(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.BinaryOperation"),model,operationContext.getScope());
      }
    }
;
    Iterable<SNode> parameterObjects=(Iterable<SNode>)calculable.calculate();
    for (    SNode parameter : parameterObjects) {
      result.add(new AbstractRTransformHintSubstituteAction(parameter,sourceNode){
        public SNode doSubstitute(        String pattern){
          SNode result=SConceptOperations.createNewNode(NameUtil.nodeFQName(((SNode)this.getParameterObject())),null);
          SNodeOperations.replaceWithAnother(sourceNode,result);
          SLinkOperations.setTarget(result,"leftExpression",sourceNode,true);
          SNode boToCheck=(SNodeOperations.isInstanceOf(result,"jetbrains.mps.baseLanguage.structure.BinaryOperation") ? SNodeOperations.getParent(result,null,false,false) : result);
          ParenthesisUtil.checkOperationWRTPriority(boToCheck);
          return boToCheck;
        }
      }
);
    }
  }
  return result;
}
