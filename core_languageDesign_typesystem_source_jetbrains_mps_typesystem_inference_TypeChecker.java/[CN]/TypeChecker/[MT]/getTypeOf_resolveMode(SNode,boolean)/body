{
  if (node == null)   return null;
  SNode containingRoot=node.getContainingRoot();
  if (containingRoot == null)   return null;
  if (myComputedTypesForCompletion != null && myComputedTypesForCompletion.containsKey(node)) {
    return myComputedTypesForCompletion.get(node);
  }
  NodeTypesComponent component=NodeTypesComponentsRepository.getInstance().getNodeTypesComponent(node.getContainingRoot());
  if (nodeIsNotChecked || !myCheckedRoots.contains(containingRoot) || component == null) {
    final SNode[] result=new SNode[1];
    final NodeTypesComponent component1=NodeTypesComponentsRepository.getInstance().createNodeTypesComponent(containingRoot);
    SNode computedType=component1.getType(node);
    if (computedType != null) {
      if (myComputedTypesForCompletion != null) {
        myComputedTypesForCompletion.put(node,computedType);
      }
      return computedType;
    }
    final NodeTypesComponent temporaryComponent;
    try {
      temporaryComponent=component1.clone();
    }
 catch (    CloneNotSupportedException ex) {
      LOG.error(ex);
      return null;
    }
    try {
      checkWithinRoot(node,new Runnable(){
        public void run(){
          result[0]=temporaryComponent.computeTypesForNodeDuringResolving(node,new Runnable(){
            public void run(){
              myCheckedRoots.add(node);
            }
          }
);
        }
      }
);
    }
  finally {
      temporaryComponent.clearListeners();
    }
    SNode resultType=result[0];
    if (myComputedTypesForCompletion != null) {
      myComputedTypesForCompletion.put(node,resultType);
    }
    return resultType;
  }
  SNode resultType=getTypeDontCheck(node);
  if (myComputedTypesForCompletion != null) {
    myComputedTypesForCompletion.put(node,resultType);
  }
  return resultType;
}
