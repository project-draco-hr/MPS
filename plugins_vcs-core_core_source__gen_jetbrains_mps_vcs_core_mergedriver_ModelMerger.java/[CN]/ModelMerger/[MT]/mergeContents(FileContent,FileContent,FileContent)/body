{
  if (Boolean.getBoolean("mps.mergedriver.model.fail")) {
    return null;
  }
  RuntimeFlags.setMergeDriverMode(true);
  LightModelEnvironmentInfoImpl persistenceEnv=new LightModelEnvironmentInfoImpl();
  PersistenceRegistry.getInstance().setModelEnvironmentInfo(persistenceEnv);
  String ext=(myExtension == null ? MPSExtentions.MODEL : myExtension);
  if (MPSExtentions.MODEL_HEADER.equals(myExtension) || MPSExtentions.MODEL_ROOT.equals(myExtension)) {
    ext=MPSExtentions.MODEL;
  }
  if (LOG.isInfoEnabled()) {
    LOG.info("Reading models...");
  }
  final SModel baseModel=loadModel(baseContent,ext);
  final SModel localModel=loadModel(localContent,ext);
  final SModel latestModel=loadModel(latestContent,ext);
  if (baseModel == null || localModel == null || latestModel == null) {
    return backup(baseContent,localContent,latestContent);
  }
  myModelName=baseModel.getName();
  int baseP=getPersistenceVersion(baseModel);
  int localP=getPersistenceVersion(localModel);
  int latestP=getPersistenceVersion(latestModel);
  if (baseP >= 7 && localP >= 7 && latestP >= 7 || baseP < 7 && localP < 7 && latestP < 7) {
  }
 else {
    if (LOG.isEnabledFor(Level.ERROR)) {
      LOG.error(String.format("%s: Conflicting model persistence versions",myModelName));
    }
    return backup(baseContent,localContent,latestContent);
  }
  if (!(persistenceEnv.isConsistent())) {
    if (LOG.isEnabledFor(Level.ERROR)) {
      LOG.error(String.format("%s: Inconsistent structure ids or import versions",myModelName));
    }
    return backup(baseContent,localContent,latestContent);
  }
  try {
    if (LOG.isInfoEnabled()) {
      LOG.info("Merging " + baseModel.getReference() + "...");
    }
    final Wrappers._T<MergeSession> mergeSession=new Wrappers._T<MergeSession>(null);
    ModelAccess.instance().runReadAction(new Runnable(){
      public void run(){
        mergeSession.value=MergeSession.createMergeSession(baseModel,localModel,latestModel);
      }
    }
);
    int conflictingChangesCount=Sequence.fromIterable(mergeSession.value.getAllChanges()).where(new IWhereFilter<ModelChange>(){
      public boolean accept(      ModelChange c){
        return Sequence.fromIterable(mergeSession.value.getConflictedWith(c)).isNotEmpty();
      }
    }
).count();
    if (conflictingChangesCount == 0) {
      if (LOG.isInfoEnabled()) {
        LOG.info(String.format("%s: %d changes detected: %d local and %d latest.",myModelName,Sequence.fromIterable(mergeSession.value.getAllChanges()).count(),ListSequence.fromList(mergeSession.value.getMyChangeSet().getModelChanges()).count(),ListSequence.fromList(mergeSession.value.getRepositoryChangeSet().getModelChanges()).count()));
      }
      ModelAccess.instance().runReadAction(new Runnable(){
        public void run(){
          mergeSession.value.applyChanges(mergeSession.value.getAllChanges());
        }
      }
);
    }
 else {
      if (LOG.isInfoEnabled()) {
        LOG.info(String.format("%s: %d changes detected, %d of them are conflicting",myModelName,Sequence.fromIterable(mergeSession.value.getAllChanges()).count(),conflictingChangesCount));
      }
      return backup(baseContent,localContent,latestContent);
    }
    if (mergeSession.value.hasIdsToRestore()) {
      if (LOG.isInfoEnabled()) {
        LOG.info(String.format("%s: node id duplication detected, should merge in UI.",myModelName));
      }
    }
 else {
      String resultString;
      SModel resultModel=mergeSession.value.getResultModel();
      if (LOG.isInfoEnabled()) {
        LOG.info(String.format("%s: Saving merged model...",myModelName));
      }
      updateMetaModelInfo(resultModel,baseModel,localModel,latestModel);
      if (MPSExtentions.MODEL_HEADER.equals(myExtension) || MPSExtentions.MODEL_ROOT.equals(myExtension)) {
        resultString=PersistenceUtil.savePerRootModel(resultModel,MPSExtentions.MODEL_HEADER.equals(myExtension));
      }
 else {
        resultString=PersistenceUtil.saveModel(resultModel,ext);
      }
      if (resultString == null) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Error while saving result model");
        }
        return backup(baseContent,localContent,latestContent);
      }
      if (LOG.isInfoEnabled()) {
        LOG.info(String.format("%s: merged successfully.",myModelName));
      }
      backup(baseContent,localContent,latestContent);
      return MultiTuple.<Integer,byte[]>from(MERGED,resultString.getBytes(FileUtil.DEFAULT_CHARSET));
    }
  }
 catch (  Throwable e) {
    if (LOG.isEnabledFor(Level.ERROR)) {
      LOG.error("Exception while merging",e);
    }
  }
  return backup(baseContent,localContent,latestContent);
}
