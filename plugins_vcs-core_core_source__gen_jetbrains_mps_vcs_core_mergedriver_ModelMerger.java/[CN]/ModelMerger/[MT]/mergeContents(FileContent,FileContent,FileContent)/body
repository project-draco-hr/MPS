{
  System.setProperty("mps.playRefactorings","false");
  MPSCore.getInstance().setMergeDriverMode(true);
  LightModelEnvironmentInfoImpl persistenceEnv=new LightModelEnvironmentInfoImpl();
  PersistenceRegistry.getInstance().setModelEnvironmentInfo(persistenceEnv);
  DefaultSModel baseModel;
  DefaultSModel localModel;
  DefaultSModel latestModel;
  try {
    if (LOG.isInfoEnabled()) {
      LOG.info("Reading models...");
    }
    baseModel=ModelPersistence.readModel(new String(baseContent.getData(),FileUtil.DEFAULT_CHARSET),false);
    myModelName=baseModel.getReference().getModelName();
    localModel=ModelPersistence.readModel(new String(localContent.getData(),FileUtil.DEFAULT_CHARSET),false);
    latestModel=ModelPersistence.readModel(new String(latestContent.getData(),FileUtil.DEFAULT_CHARSET),false);
  }
 catch (  ModelReadException e) {
    if (LOG.isEnabledFor(Priority.ERROR)) {
      LOG.error("Exception while reading models",e);
    }
    return backup(baseContent,localContent,latestContent);
  }
  int baseP=baseModel.getPersistenceVersion();
  int localP=localModel.getPersistenceVersion();
  int latestP=latestModel.getPersistenceVersion();
  if (baseP >= 7 && localP >= 7 && latestP >= 7 || baseP < 7 && localP < 7 && latestP < 7) {
  }
 else {
    if (LOG.isEnabledFor(Priority.ERROR)) {
      LOG.error(String.format("%s: Conflicting model persistence versions",myModelName));
    }
    return backup(baseContent,localContent,latestContent);
  }
  if (!(persistenceEnv.isConsistent())) {
    if (LOG.isEnabledFor(Priority.ERROR)) {
      LOG.error(String.format("%s: Inconsistent structure ids or import versions",myModelName));
    }
    return backup(baseContent,localContent,latestContent);
  }
  try {
    if (LOG.isInfoEnabled()) {
      LOG.info("Merging " + baseModel.getReference() + "...");
    }
    final MergeSession mergeSession=MergeSession.createMergeSession(baseModel,localModel,latestModel);
    int conflictingChangesCount=Sequence.fromIterable(mergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>(){
      public boolean accept(      ModelChange c){
        return Sequence.fromIterable(mergeSession.getConflictedWith(c)).isNotEmpty();
      }
    }
).count();
    if (conflictingChangesCount == 0) {
      if (LOG.isInfoEnabled()) {
        LOG.info(String.format("%s: %d changes detected: %d local and %d latest.",myModelName,Sequence.fromIterable(mergeSession.getAllChanges()).count(),ListSequence.fromList(mergeSession.getMyChangeSet().getModelChanges()).count(),ListSequence.fromList(mergeSession.getRepositoryChangeSet().getModelChanges()).count()));
      }
      Runnable applyAction=new Runnable(){
        public void run(){
          mergeSession.applyChanges(mergeSession.getAllChanges());
        }
      }
;
      ModelAccess.instance().runReadAction(applyAction);
      if (mergeSession.hasIdsToRestore()) {
        if (LOG.isInfoEnabled()) {
          LOG.info(String.format("%s: node id duplication detected, should merge in UI.",myModelName));
        }
      }
 else {
        String resultString=ModelPersistence.modelToString(mergeSession.getResultModel());
        if (LOG.isInfoEnabled()) {
          LOG.info(String.format("%s: merged successfully.",myModelName));
        }
        backup(baseContent,localContent,latestContent);
        return MultiTuple.<Integer,byte[]>from(MERGED,resultString.getBytes(FileUtil.DEFAULT_CHARSET));
      }
    }
 else {
      if (LOG.isInfoEnabled()) {
        LOG.info(String.format("%s: %d changes detected, %d of them are conflicting",myModelName,Sequence.fromIterable(mergeSession.getAllChanges()).count(),conflictingChangesCount));
      }
    }
  }
 catch (  Throwable e) {
    if (LOG.isEnabledFor(Priority.ERROR)) {
      LOG.error("Exception while merging",e);
    }
    return backup(baseContent,localContent,latestContent);
  }
  return backup(baseContent,localContent,latestContent);
}
