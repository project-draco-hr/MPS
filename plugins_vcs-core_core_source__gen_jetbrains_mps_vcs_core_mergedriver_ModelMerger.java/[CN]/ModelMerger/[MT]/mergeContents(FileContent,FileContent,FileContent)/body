{
  System.setProperty("mps.playRefactorings","false");
  MPSCore.getInstance().setMergeDriverMode(true);
  LightModelEnvironmentInfoImpl persistenceEnv=new LightModelEnvironmentInfoImpl();
  PersistenceRegistry.getInstance().setModelEnvironmentInfo(persistenceEnv);
  String ext=(myExtension == null ? MPSExtentions.MODEL : myExtension);
  if (MPSExtentions.MODEL_HEADER.equals(myExtension) || MPSExtentions.MODEL_ROOT.equals(myExtension)) {
    ext=MPSExtentions.MODEL;
  }
  if (LOG.isInfoEnabled()) {
    LOG.info("Reading models...");
  }
  SModel baseModel=PersistenceUtil.loadModel(new String(baseContent.getData(),FileUtil.DEFAULT_CHARSET),ext);
  SModel localModel=PersistenceUtil.loadModel(new String(localContent.getData(),FileUtil.DEFAULT_CHARSET),ext);
  SModel latestModel=PersistenceUtil.loadModel(new String(latestContent.getData(),FileUtil.DEFAULT_CHARSET),ext);
  if (baseModel == null || localModel == null || latestModel == null) {
    if (LOG.isEnabledFor(Priority.ERROR)) {
      LOG.error("Error while reading models");
    }
    return backup(baseContent,localContent,latestContent);
  }
  myModelName=baseModel.getModelName();
  int baseP=getPersistenceVersion(baseModel);
  int localP=getPersistenceVersion(localModel);
  int latestP=getPersistenceVersion(latestModel);
  if (baseP >= 7 && localP >= 7 && latestP >= 7 || baseP < 7 && localP < 7 && latestP < 7) {
  }
 else {
    if (LOG.isEnabledFor(Priority.ERROR)) {
      LOG.error(String.format("%s: Conflicting model persistence versions",myModelName));
    }
    return backup(baseContent,localContent,latestContent);
  }
  if (!(persistenceEnv.isConsistent())) {
    if (LOG.isEnabledFor(Priority.ERROR)) {
      LOG.error(String.format("%s: Inconsistent structure ids or import versions",myModelName));
    }
    return backup(baseContent,localContent,latestContent);
  }
  try {
    if (LOG.isInfoEnabled()) {
      LOG.info("Merging " + baseModel.getReference() + "...");
    }
    final MergeSession mergeSession=MergeSession.createMergeSession(baseModel,localModel,latestModel);
    int conflictingChangesCount=Sequence.fromIterable(mergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>(){
      public boolean accept(      ModelChange c){
        return Sequence.fromIterable(mergeSession.getConflictedWith(c)).isNotEmpty();
      }
    }
).count();
    if (conflictingChangesCount == 0) {
      if (LOG.isInfoEnabled()) {
        LOG.info(String.format("%s: %d changes detected: %d local and %d latest.",myModelName,Sequence.fromIterable(mergeSession.getAllChanges()).count(),ListSequence.fromList(mergeSession.getMyChangeSet().getModelChanges()).count(),ListSequence.fromList(mergeSession.getRepositoryChangeSet().getModelChanges()).count()));
      }
      ModelAccess.instance().runReadAction(new Runnable(){
        public void run(){
          mergeSession.applyChanges(mergeSession.getAllChanges());
        }
      }
);
      if (mergeSession.hasIdsToRestore()) {
        if (LOG.isInfoEnabled()) {
          LOG.info(String.format("%s: node id duplication detected, should merge in UI.",myModelName));
        }
      }
 else {
        String resultString;
        if (MPSExtentions.MODEL_HEADER.equals(myExtension) || MPSExtentions.MODEL_ROOT.equals(myExtension)) {
          resultString=PersistenceUtil.savePerRootModel(mergeSession.getResultModel(),MPSExtentions.MODEL_HEADER.equals(myExtension));
        }
 else {
          resultString=PersistenceUtil.saveModel(mergeSession.getResultModel(),ext);
        }
        if (resultString == null) {
          if (LOG.isEnabledFor(Priority.ERROR)) {
            LOG.error("Error while saving result model");
          }
          return backup(baseContent,localContent,latestContent);
        }
        if (LOG.isInfoEnabled()) {
          LOG.info(String.format("%s: merged successfully.",myModelName));
        }
        backup(baseContent,localContent,latestContent);
        return MultiTuple.<Integer,byte[]>from(MERGED,resultString.getBytes(FileUtil.DEFAULT_CHARSET));
      }
    }
 else {
      if (LOG.isInfoEnabled()) {
        LOG.info(String.format("%s: %d changes detected, %d of them are conflicting",myModelName,Sequence.fromIterable(mergeSession.getAllChanges()).count(),conflictingChangesCount));
      }
    }
  }
 catch (  Throwable e) {
    if (LOG.isEnabledFor(Priority.ERROR)) {
      LOG.error("Exception while merging",e);
    }
    return backup(baseContent,localContent,latestContent);
  }
  return backup(baseContent,localContent,latestContent);
}
