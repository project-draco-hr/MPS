{
  System.setProperty("mps.playRefactorings","false");
  MPSCore.getInstance().setMergeDriverMode(true);
  MergerRoleIdsHandler roleIdsHandler=new MergerRoleIdsHandler();
  RoleIdsComponent.setHandler(roleIdsHandler);
  DefaultSModel baseModel;
  DefaultSModel localModel;
  DefaultSModel latestModel;
  try {
    if (log.isInfoEnabled()) {
      log.info("Reading models...");
    }
    baseModel=ModelPersistence.readModel(new String(baseContent,FileUtil.DEFAULT_CHARSET),false);
    myModelFqName=baseModel.getSModelFqName();
    localModel=ModelPersistence.readModel(new String(localContent,FileUtil.DEFAULT_CHARSET),false);
    latestModel=ModelPersistence.readModel(new String(latestContent,FileUtil.DEFAULT_CHARSET),false);
  }
 catch (  ModelReadException e) {
    if (log.isErrorEnabled()) {
      log.error("Exception while reading models",e);
    }
    return backup(baseContent,localContent,latestContent);
  }
  int baseP=baseModel.getPersistenceVersion();
  int localP=localModel.getPersistenceVersion();
  int latestP=latestModel.getPersistenceVersion();
  if (baseP >= 7 && localP >= 7 && latestP >= 7 || baseP < 7 && localP < 7 && latestP < 7) {
  }
 else {
    if (log.isErrorEnabled()) {
      log.error(String.format("%s: Conflicting model persistence versions",myModelFqName));
    }
    return backup(baseContent,localContent,latestContent);
  }
  if (!(roleIdsHandler.isConsistent())) {
    if (log.isErrorEnabled()) {
      log.error(String.format("%s: Inconsistent structure ids or import versions",myModelFqName));
    }
    return backup(baseContent,localContent,latestContent);
  }
  try {
    if (log.isInfoEnabled()) {
      log.info("Merging " + baseModel.getSModelReference() + "...");
    }
    final MergeSession mergeSession=new MergeSession(baseModel,localModel,latestModel);
    int conflictingChangesCount=Sequence.fromIterable(mergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>(){
      public boolean accept(      ModelChange c){
        return Sequence.fromIterable(mergeSession.getConflictedWith(c)).isNotEmpty();
      }
    }
).count();
    if (conflictingChangesCount == 0) {
      if (log.isInfoEnabled()) {
        log.info(String.format("%s: %d changes detected: %d local and %d latest.",myModelFqName,Sequence.fromIterable(mergeSession.getAllChanges()).count(),ListSequence.fromList(mergeSession.getMyChangeSet().getModelChanges()).count(),ListSequence.fromList(mergeSession.getRepositoryChangeSet().getModelChanges()).count()));
      }
      Runnable applyAction=new Runnable(){
        public void run(){
          mergeSession.applyChanges(mergeSession.getAllChanges());
        }
      }
;
      ModelAccess.instance().runReadAction(applyAction);
      if (mergeSession.hasIdsToRestore()) {
        if (log.isInfoEnabled()) {
          log.info(String.format("%s: node id duplication detected, should merge in UI.",myModelFqName));
        }
      }
 else {
        String resultString=ModelPersistence.modelToString(mergeSession.getResultModel());
        if (log.isInfoEnabled()) {
          log.info(String.format("%s: merged successfully.",myModelFqName));
        }
        backup(baseContent,localContent,latestContent);
        return MultiTuple.<Integer,byte[]>from(MERGED,resultString.getBytes(FileUtil.DEFAULT_CHARSET));
      }
    }
 else {
      if (log.isInfoEnabled()) {
        log.info(String.format("%s: %d changes detected, %d of them are conflicting",myModelFqName,Sequence.fromIterable(mergeSession.getAllChanges()).count(),conflictingChangesCount));
      }
    }
  }
 catch (  Throwable e) {
    if (log.isErrorEnabled()) {
      log.error("Exception while merging",e);
    }
    return backup(baseContent,localContent,latestContent);
  }
  return backup(baseContent,localContent,latestContent);
}
