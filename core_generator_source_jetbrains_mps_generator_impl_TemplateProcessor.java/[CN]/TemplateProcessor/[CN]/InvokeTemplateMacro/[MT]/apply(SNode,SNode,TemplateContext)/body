{
  SNode newInputNode=getNewInputNode(macro,templateContext);
  if (newInputNode == null) {
    return Collections.emptyList();
  }
  SNode invokedTemplate=getInvokedTemplate(macro);
  if (invokedTemplate == null) {
    showErrorMessage(newInputNode,null,macro,String.format("error processing %s : no template to invoke",myName));
    throw new TemplateProcessingFailureException();
  }
  TemplateContext newcontext=prepareContext(macro,invokedTemplate,templateContext,newInputNode);
  if (newcontext == null) {
    throw new TemplateProcessingFailureException();
  }
  List<SNode> fragments=GeneratorUtilEx.getTemplateFragments(invokedTemplate);
  if (!GeneratorUtilEx.checkIfOneOrMaryAdjacentFragments(fragments,invokedTemplate,newInputNode,macro,getGenerator())) {
    showErrorMessage(newInputNode,null,macro,String.format("error processing %s"));
    throw new TemplateProcessingFailureException();
  }
  boolean inputChanged=(newInputNode != templateContext.getInput());
  if (inputChanged) {
    myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));
  }
  myTracer.pushTemplateNode(new jetbrains.mps.smodel.SNodePointer(invokedTemplate));
  ArrayList<SNode> outputNodes=new ArrayList<SNode>();
  try {
    for (    SNode fragment : fragments) {
      SNode templateForInclude=fragment.getParent();
      String mappingName=GeneratorUtilEx.getMappingName_TemplateFragment(fragment,null);
      List<SNode> _outputNodes=myTemplateProcessor.applyTemplate(templateForInclude,newcontext.subContext(mappingName),null);
      if (_outputNodes != null)       outputNodes.addAll(_outputNodes);
    }
  }
  finally {
    if (inputChanged) {
      myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));
    }
  }
  return outputNodes;
}
