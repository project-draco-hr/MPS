{
  SNode macro_mapperFunction=RuleUtil.getMapSrc_MapperFunction(macro);
  final Collection<SNode> newInputNodes;
  if (myIsSoleInput) {
    newInputNodes=InputQueryUtil.wrapAsList(getNewInputNode(templateContext));
  }
 else {
    newInputNodes=getNewInputNodes(templateContext);
  }
  if (newInputNodes.isEmpty()) {
    return Collections.emptyList();
  }
  ArrayList<SNode> outputNodes=new ArrayList<SNode>(newInputNodes.size());
  for (  SNode newInputNode : newInputNodes) {
    boolean inputChanged=(newInputNode != templateContext.getInput());
    if (inputChanged) {
      myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));
    }
    try {
      TemplateContext newcontext=templateContext.subContext(newInputNode);
      final TemplateExecutionEnvironment env=templateContext.getEnvironment();
      if (macro_mapperFunction != null) {
        SNode childToReplaceLater=myTemplateProcessor.myOutputModel.createNode(templateNode.getConcept());
        myTracer.pushOutputNodeToReplaceLater(childToReplaceLater);
        outputNodes.add(childToReplaceLater);
        myTemplateProcessor.getGenerator().getDelayedChanges().addExecuteMapSrcNodeMacroChange(macro,childToReplaceLater,newcontext,env.getQueryExecutor());
      }
 else {
        List<SNode> _outputNodes=nextMacro(newcontext);
        outputNodes.addAll(_outputNodes);
        for (        SNode outputNode : _outputNodes) {
          myTemplateProcessor.getGenerator().getDelayedChanges().addExecuteMapSrcNodeMacroPostProcChange(macro,outputNode,newcontext,env.getQueryExecutor());
        }
      }
    }
  finally {
      if (inputChanged) {
        myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));
      }
    }
  }
  return outputNodes;
}
