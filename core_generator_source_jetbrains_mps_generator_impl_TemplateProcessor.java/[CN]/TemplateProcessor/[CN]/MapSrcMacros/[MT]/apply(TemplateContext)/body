{
  final Collection<SNode> newInputNodes;
  if (myIsSoleInput) {
    newInputNodes=wrapAsList(getNewInputNode(templateContext));
  }
 else {
    newInputNodes=getNewInputNodes(templateContext);
  }
  if (newInputNodes.isEmpty()) {
    return Collections.emptyList();
  }
  GeneratorQueryProvider queryProvider=myTemplateProcessor.getQueryProvider(getMacroNodeRef());
  SNode mf=RuleUtil.getMapSrc_MapperFunction(macro);
  SNode ppf=RuleUtil.getMapSrc_PostMapperFunction(macro);
  MapNodeQuery mapNodeQuery=mf == null ? null : queryProvider.getMapNodeQuery(new QueryKeyImpl(getMacroNodeRef(),mf.getNodeId()));
  MapPostProcessor postProcessor=ppf == null ? null : queryProvider.getMapPostProcessor(new QueryKeyImpl(getMacroNodeRef(),ppf.getNodeId()));
  final TemplateExecutionEnvironment env=templateContext.getEnvironment();
  ArrayList<SNode> outputNodes=new ArrayList<SNode>(newInputNodes.size());
  final DelayedChanges delayedChanges=myTemplateProcessor.getGenerator().getDelayedChanges();
  for (  SNode newInputNode : newInputNodes) {
    TemplateContext newcontext=templateContext.subContext(newInputNode);
    if (mapNodeQuery != null) {
      SNode childToReplaceLater=env.createOutputNode(templateNode.getConcept());
      outputNodes.add(childToReplaceLater);
      delayedChanges.add(new MapSrcMacroProcessorInterpreted(mapNodeQuery,postProcessor,getMacroNodeRef(),childToReplaceLater,newcontext));
    }
 else {
      List<SNode> _outputNodes=nextMacro(newcontext);
      outputNodes.addAll(_outputNodes);
      if (postProcessor != null) {
        for (        SNode outputNode : _outputNodes) {
          delayedChanges.add(new MapSrcMacroProcessorInterpreted(postProcessor,getMacroNodeRef(),outputNode,newcontext));
        }
      }
    }
  }
  return outputNodes;
}
