{
  String macroConceptFQName=macro.getConcept().getId();
  List<SNode> outputNodes=new ArrayList<SNode>();
  String mappingName=GeneratorUtilEx.getMappingName_NodeMacro(macro,outerMappingName);
  if (macroConceptFQName.equals(RuleUtil.concept_LoopMacro)) {
    List<SNode> newInputNodes=getNewInputNodes(macro,templateContext);
    for (    SNode newInputNode : newInputNodes) {
      boolean inputChanged=(newInputNode != templateContext.getInput());
      if (inputChanged) {
        myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));
      }
      try {
        List<SNode> _outputNodes=applyTemplate(mappingName,templateNode,templateContext.subContext(mappingName,newInputNode),macro);
        if (_outputNodes != null)         outputNodes.addAll(_outputNodes);
      }
  finally {
        if (inputChanged) {
          myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));
        }
      }
    }
    return outputNodes;
  }
 else   if (macroConceptFQName.equals(RuleUtil.concept_CopySrcNodeMacro) || macroConceptFQName.equals(RuleUtil.concept_CopySrcListMacro)) {
    List<SNode> newInputNodes=getNewInputNodes(macro,templateContext);
    SNodeReference templateNodeRef=templateNode == null ? null : new jetbrains.mps.smodel.SNodePointer(templateNode);
    for (    SNode newInputNode : newInputNodes) {
      Collection<SNode> _outputNodes=myGenerator.copySrc(mappingName,templateNodeRef,null,newInputNode,myReductionContext);
      if (_outputNodes != null) {
        for (        SNode outputNode : _outputNodes) {
          Language outputNodeLang=jetbrains.mps.util.SNodeOperations.getLanguage(outputNode);
          if (!myGenerator.getGeneratorSessionContext().getGenerationPlan().isCountedLanguage(outputNodeLang)) {
            if (!outputNodeLang.getGenerators().isEmpty()) {
              myGenerator.getLogger().error(outputNode,"language of output node is '" + outputNodeLang.getModuleFqName() + "' - this language did not show up when computing generation steps!",GeneratorUtil.describe(macro,"template"),GeneratorUtil.describe(templateContext.getInput(),"input"),new ProblemDescription(null,"workaround: add the language '" + outputNodeLang.getModuleFqName() + "' to list of 'Languages Engaged On Generation' in model '"+ ((SModelReference)myGenerator.getGeneratorSessionContext().getOriginalInputModel().getReference()).getSModelFqName()+ "'"));
            }
          }
        }
        outputNodes.addAll(_outputNodes);
      }
    }
    return outputNodes;
  }
 else   if (macroConceptFQName.equals(RuleUtil.concept_InsertMacro)) {
    SNode child=InputQueryUtil.getNodeToInsert(macro,templateContext.subContext(mappingName),myReductionContext,myGenerator);
    if (child != null) {
      Language childLang=jetbrains.mps.util.SNodeOperations.getLanguage(child);
      if (!myGenerator.getGeneratorSessionContext().getGenerationPlan().isCountedLanguage(childLang)) {
        if (!childLang.getGenerators().isEmpty()) {
          myGenerator.getLogger().error(child,"language of output node is '" + childLang.getModuleFqName() + "' - this language did not show up when computing generation steps!",GeneratorUtil.describe(macro,"template"),GeneratorUtil.describe(templateContext.getInput(),"input"),new ProblemDescription(null,"workaround: add the language '" + childLang.getModuleFqName() + "' to list of 'Languages Engaged On Generation' in model '"+ ((SModelReference)myGenerator.getGeneratorSessionContext().getOriginalInputModel().getReference()).getSModelFqName()+ "'"));
        }
      }
      if (child.getModel() != null) {
        child=CopyUtil.copy(child);
      }
      validateReferences(child,templateContext.getInput());
      myGenerator.getMappings().addOutputNodeByInputNodeAndMappingName(templateContext.getInput(),mappingName,child);
      outputNodes.add(child);
    }
    return outputNodes;
  }
 else   if (macroConceptFQName.equals(RuleUtil.concept_WeaveMacro)) {
    List<SNode> _outputNodes=applyTemplate(mappingName,templateNode,templateContext.subContext(mappingName),macro);
    if (_outputNodes != null && _outputNodes.size() > 0) {
      if (_outputNodes.size() == 1) {
        SNode contextNode=_outputNodes.get(0);
        List<SNode> nodesToWeave=getNewInputNodes(macro,templateContext);
        for (        SNode node : nodesToWeave) {
          try {
            myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(node));
            myTracer.pushRuleConsequence(new jetbrains.mps.smodel.SNodePointer(macro));
            SNode consequence=RuleUtil.getWeaveMacro_Consequence(macro);
            if (consequence == null) {
              myGenerator.showErrorMessage(templateContext.getInput(),macro,"couldn't evaluate weave macro: no consequence");
              break;
            }
            SNode template=RuleUtil.getTemplateDeclarationReference_Template(consequence);
            weaveMacro(template,contextNode,templateContext.subContext(null,node),macro);
          }
  finally {
            myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(node));
          }
        }
      }
 else {
        myGenerator.getLogger().error(templateContext.getInput(),"cannot apply $WEAVE$ to a list of nodes",GeneratorUtil.describe(macro,"template"),GeneratorUtil.describe(templateContext.getInput(),"input"));
      }
      outputNodes.addAll(_outputNodes);
    }
    return outputNodes;
  }
 else   if (macroConceptFQName.equals(RuleUtil.concept_LabelMacro)) {
    List<SNode> _outputNodes=applyTemplate(mappingName,templateNode,templateContext.subContext(mappingName),macro);
    if (_outputNodes != null)     outputNodes.addAll(_outputNodes);
    return outputNodes;
  }
 else   if (macroConceptFQName.equals(RuleUtil.concept_VarMacro)) {
    String varName=RuleUtil.getVarMacro_Name(macro);
    Object varValue=myReductionContext.getQueryExecutor().evaluateVariableQuery(templateContext.getInput(),RuleUtil.getVarMacro_Query(macro),templateContext);
    TemplateContext newContext=templateContext.subContext(Collections.singletonMap(varName,varValue));
    List<SNode> _outputNodes=applyTemplate(mappingName,templateNode,newContext.subContext(mappingName),macro);
    if (_outputNodes != null)     outputNodes.addAll(_outputNodes);
    return outputNodes;
  }
 else   if (macroConceptFQName.equals(RuleUtil.concept_IfMacro)) {
    List<SNode> _outputNodes=null;
    if (myReductionContext.getQueryExecutor().checkConditionForIfMacro(templateContext.getInput(),macro,templateContext)) {
      _outputNodes=applyTemplate(mappingName,templateNode,templateContext.subContext(mappingName),macro);
    }
 else {
      SNode altConsequence=RuleUtil.getIfMacro_AlternativeConsequence(macro);
      if (altConsequence != null) {
        try {
          List<Pair<SNode,String>> nodeAndMappingNamePairs=GeneratorUtilEx.getTemplateNodesFromRuleConsequence(altConsequence,templateContext.getInput(),macro,myReductionContext,myGenerator);
          if (nodeAndMappingNamePairs == null) {
            myGenerator.showErrorMessage(templateContext.getInput(),null,macro,"error processing $IF$/alternative");
            return null;
          }
          for (          Pair<SNode,String> nodeAndMappingNamePair : nodeAndMappingNamePairs) {
            SNode altTemplateNode=nodeAndMappingNamePair.o1;
            String innerMappingName=nodeAndMappingNamePair.o2 != null ? nodeAndMappingNamePair.o2 : mappingName;
            List<SNode> __outputNodes=applyExternalTemplate(innerMappingName,altTemplateNode,templateContext.subContext(innerMappingName));
            if (__outputNodes != null) {
              if (_outputNodes == null)               _outputNodes=new ArrayList<SNode>();
              _outputNodes.addAll(__outputNodes);
            }
          }
        }
 catch (        AbandonRuleInputException e) {
        }
      }
    }
    if (_outputNodes != null)     outputNodes.addAll(_outputNodes);
    return outputNodes;
  }
 else   if (macroConceptFQName.equals(RuleUtil.concept_MapSrcNodeMacro) || macroConceptFQName.equals(RuleUtil.concept_MapSrcListMacro)) {
    SNode macro_mapperFunction=RuleUtil.getMapSrc_MapperFunction(macro);
    List<SNode> newInputNodes=getNewInputNodes(macro,templateContext);
    for (    SNode newInputNode : newInputNodes) {
      boolean inputChanged=(newInputNode != templateContext.getInput());
      if (inputChanged) {
        myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));
      }
      try {
        TemplateContext newcontext=templateContext.subContext(mappingName,newInputNode);
        if (macro_mapperFunction != null) {
          SNode childToReplaceLater=SModelUtil_new.instantiateConceptDeclaration(templateNode.getConcept().getId(),myOutputModel,myGenerator.getScope(),false);
          myTracer.pushOutputNodeToReplaceLater(childToReplaceLater);
          outputNodes.add(childToReplaceLater);
          myGenerator.getDelayedChanges().addExecuteMapSrcNodeMacroChange(macro,childToReplaceLater,newcontext,myReductionContext);
        }
 else {
          List<SNode> _outputNodes=applyTemplate(mappingName,templateNode,newcontext,macro);
          if (_outputNodes != null) {
            outputNodes.addAll(_outputNodes);
            for (            SNode outputNode : _outputNodes) {
              myGenerator.getDelayedChanges().addExecuteMapSrcNodeMacroPostProcChange(macro,outputNode,newcontext,myReductionContext);
            }
          }
        }
      }
  finally {
        if (inputChanged) {
          myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));
        }
      }
    }
    return outputNodes;
  }
 else   if (macroConceptFQName.equals(RuleUtil.concept_SwitchMacro)) {
    SNode templateSwitch=RuleUtil.getSwitchMacro_TemplateSwitch(macro);
    if (templateSwitch == null) {
      myGenerator.showErrorMessage(templateContext.getInput(),macro,"error processing $SWITCH$ - bad TemplateSwitch reference");
      return null;
    }
    final SNodeReference switchPtr=new jetbrains.mps.smodel.SNodePointer(templateSwitch);
    SNode newInputNode=getNewInputNode(macro,templateContext);
    if (newInputNode == null) {
      TemplateSwitchMapping tswitch=myGenerator.getSwitch(switchPtr);
      if (tswitch != null) {
        tswitch.processNull(new TemplateExecutionEnvironmentImpl(myGenerator,myReductionContext,myGenerator.getOperationContext(),myTracer),switchPtr,templateContext);
      }
      return Collections.emptyList();
    }
    boolean inputChanged=(newInputNode != templateContext.getInput());
    if (inputChanged) {
      myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));
    }
    myTracer.pushSwitch(new jetbrains.mps.smodel.SNodePointer(templateSwitch));
    try {
      final TemplateContext switchContext=templateContext.subContext(mappingName,newInputNode);
      Collection<SNode> collection=myGenerator.tryToReduce(switchContext,switchPtr,mappingName,myReductionContext);
      if (collection == null) {
        TemplateSwitchMapping tswitch=myGenerator.getSwitch(switchPtr);
        if (tswitch != null) {
          TemplateExecutionEnvironment environment=new TemplateExecutionEnvironmentImpl(myGenerator,myReductionContext,myGenerator.getOperationContext(),myTracer);
          try {
            collection=tswitch.applyDefault(environment,switchPtr,mappingName,switchContext);
          }
 catch (          GenerationException e) {
            if (e instanceof GenerationCanceledException)             throw (GenerationCanceledException)e;
            if (e instanceof GenerationFailureException)             throw (GenerationFailureException)e;
            if (e instanceof DismissTopMappingRuleException)             throw (DismissTopMappingRuleException)e;
            myGenerator.showErrorMessage(null,tswitch.getSwitchNode().resolve(MPSModuleRepository.getInstance()),"internal error in switch.applyDefault: " + e.toString());
          }
        }
        if (collection == null) {
          collection=applyTemplate(mappingName,templateNode,templateContext.subContext(mappingName,newInputNode),macro);
        }
      }
      if (collection != null) {
        outputNodes.addAll(collection);
      }
    }
  finally {
      if (inputChanged) {
        myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));
      }
    }
    return outputNodes;
  }
 else   if (macroConceptFQName.equals(RuleUtil.concept_IncludeMacro)) {
    SNode newInputNode=getNewInputNode(macro,templateContext);
    if (newInputNode == null) {
      return outputNodes;
    }
    SNode includeTemplate=RuleUtil.getIncludeMacro_Template(macro);
    if (includeTemplate == null) {
      myGenerator.showErrorMessage(newInputNode,null,macro,"error processing $INCLUDE$ : no 'include template'");
      return null;
    }
    final String[] parameterNames=RuleUtil.getTemplateDeclarationParameterNames(includeTemplate);
    if (parameterNames == null) {
      myGenerator.showErrorMessage(newInputNode,null,macro,"error processing $INCLUDE$: target template is broken");
      return null;
    }
    for (    String name : parameterNames) {
      if (!templateContext.hasVariable(name)) {
        myGenerator.showErrorMessage(newInputNode,null,macro,"error processing $INCLUDE$: parameter `" + name + "' is missing");
      }
    }
    List<SNode> fragments=GeneratorUtilEx.getTemplateFragments(includeTemplate);
    if (!GeneratorUtilEx.checkIfOneOrMaryAdjacentFragments(fragments,includeTemplate,newInputNode,macro,myGenerator)) {
      myGenerator.showErrorMessage(newInputNode,null,macro,"error processing $INCLUDE$");
      return null;
    }
    boolean inputChanged=(newInputNode != templateContext.getInput());
    if (inputChanged) {
      myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));
    }
    myTracer.pushTemplateNode(new jetbrains.mps.smodel.SNodePointer(includeTemplate));
    try {
      for (      SNode fragment : fragments) {
        SNode templateForInclude=fragment.getParent();
        mappingName=GeneratorUtilEx.getMappingName(fragment,mappingName);
        List<SNode> _outputNodes=applyExternalTemplate(mappingName,templateForInclude,templateContext.subContext(mappingName,newInputNode));
        if (_outputNodes != null)         outputNodes.addAll(_outputNodes);
      }
    }
  finally {
      if (inputChanged) {
        myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));
      }
    }
    return outputNodes;
  }
 else   if (macroConceptFQName.equals(RuleUtil.concept_TemplateCallMacro)) {
    SNode newInputNode=getNewInputNode(macro,templateContext);
    if (newInputNode == null) {
      return outputNodes;
    }
    SNode template=RuleUtil.getCallMacro_Template(macro);
    if (template == null) {
      myGenerator.showErrorMessage(newInputNode,null,macro,"error processing $CALL$ : no 'include template'");
      return null;
    }
    TemplateContext newcontext=GeneratorUtil.createTemplateCallContext(templateContext.getInput(),templateContext,myReductionContext,macro,newInputNode,myGenerator);
    List<SNode> fragments=GeneratorUtilEx.getTemplateFragments(template);
    if (!GeneratorUtilEx.checkIfOneOrMaryAdjacentFragments(fragments,template,newInputNode,macro,myGenerator)) {
      myGenerator.showErrorMessage(newInputNode,null,macro,"error processing $CALL$");
      return null;
    }
    boolean inputChanged=(newInputNode != templateContext.getInput());
    if (inputChanged) {
      myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));
    }
    myTracer.pushTemplateNode(new jetbrains.mps.smodel.SNodePointer(template));
    try {
      for (      SNode fragment : fragments) {
        SNode templateForInclude=fragment.getParent();
        mappingName=GeneratorUtilEx.getMappingName(fragment,mappingName);
        List<SNode> _outputNodes=applyExternalTemplate(mappingName,templateForInclude,newcontext.subContext(mappingName));
        if (_outputNodes != null)         outputNodes.addAll(_outputNodes);
      }
    }
  finally {
      if (inputChanged) {
        myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));
      }
    }
    return outputNodes;
  }
 else   if (macroConceptFQName.equals(RuleUtil.concept_TraceMacro)) {
    SNode inputNode=getNewInputNode(macro,templateContext);
    List<SNode> _outputNodes=applyTemplate(mappingName,templateNode,templateContext.subContext(mappingName),macro);
    if (_outputNodes != null) {
      outputNodes.addAll(_outputNodes);
      for (      SNode outputNode : _outputNodes) {
        TracingUtil.fillOriginalNode(inputNode,outputNode,myGenerator.getGeneratorSessionContext().getOriginalInputModel() == inputNode.getModel());
      }
    }
    return outputNodes;
  }
 else {
    List<SNode> newInputNodes=getNewInputNodes(macro,templateContext);
    for (    SNode newInputNode : newInputNodes) {
      boolean inputChanged=(newInputNode != templateContext.getInput());
      if (inputChanged) {
        myTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));
      }
      try {
        List<SNode> _outputNodes=applyTemplate(mappingName,templateNode,templateContext.subContext(mappingName,newInputNode),macro);
        if (_outputNodes != null)         outputNodes.addAll(_outputNodes);
      }
  finally {
        if (inputChanged) {
          myTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(newInputNode));
        }
      }
    }
    return outputNodes;
  }
}
