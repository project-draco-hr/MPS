{
  IGenerationTracer generationTracer=myGenerator.getGenerationTracer();
  List<SNode> outputNodes=new ArrayList<SNode>();
  String mappingName=GeneratorUtil.getMappingName(nodeMacro,null);
  if (nodeMacro instanceof LoopMacro) {
    List<SNode> newInputNodes=getNewInputNodes(nodeMacro,templateContext);
    for (    SNode newInputNode : newInputNodes) {
      boolean inputChanged=(newInputNode != templateContext.getInput());
      if (inputChanged) {
        generationTracer.pushInputNode(newInputNode);
      }
      try {
        List<SNode> _outputNodes=createOutputNodesForTemplateNode(mappingName,templateNode,TemplateContext.getContext(templateContext,mappingName,newInputNode),nodeMacrosToSkip + 1);
        if (_outputNodes != null)         outputNodes.addAll(_outputNodes);
      }
  finally {
        if (inputChanged) {
          generationTracer.closeInputNode(newInputNode);
        }
      }
    }
    return outputNodes;
  }
 else   if (nodeMacro instanceof CopySrcNodeMacro || nodeMacro instanceof CopySrcListMacro) {
    List<SNode> newInputNodes=getNewInputNodes(nodeMacro,templateContext);
    for (    SNode newInputNode : newInputNodes) {
      List<SNode> _outputNodes=newInputNode.getModel() == myGenerator.getInputModel() && newInputNode.isRegistered() ? myGenerator.copyNodeFromInputNode(mappingName,templateNode,newInputNode,myReductionContext,new boolean[]{false}) : myGenerator.copyNodeFromExternalNode(mappingName,templateNode,newInputNode,myReductionContext);
      if (_outputNodes != null) {
        for (        SNode outputNode : _outputNodes) {
          Language outputNodeLang=outputNode.getNodeLanguage();
          if (!myGenerator.getGeneratorSessionContext().getGenerationPlan().isCountedLanguage(outputNodeLang)) {
            if (!outputNodeLang.getGenerators().isEmpty()) {
              myGenerator.getLogger().error(outputNode,"language of output node is '" + outputNodeLang.getModuleFqName() + "' - this language did not show up when computing generation steps!");
              myGenerator.getLogger().error(templateContext.getInput()," -- was input: " + templateContext.getInput().getDebugText());
              myGenerator.getLogger().error(nodeMacro.getNode()," -- was template: " + nodeMacro.getDebugText());
              myGenerator.getLogger().error(null," -- workaround: add the language '" + outputNodeLang.getModuleFqName() + "' to list of 'Languages Engaged On Generation' in model '"+ myGenerator.getGeneratorSessionContext().getOriginalInputModel().getSModelFqName()+ "'");
            }
          }
        }
        outputNodes.addAll(_outputNodes);
      }
    }
    return outputNodes;
  }
 else   if (nodeMacro instanceof IfMacro) {
    List<SNode> _outputNodes=null;
    if (myReductionContext.getQueryExecutor().checkConditionForIfMacro(templateContext.getInput(),(IfMacro)nodeMacro,templateContext)) {
      _outputNodes=createOutputNodesForTemplateNode(mappingName,templateNode,TemplateContext.getContext(templateContext,mappingName),nodeMacrosToSkip + 1);
    }
 else {
      RuleConsequence altConsequence=((IfMacro)nodeMacro).getAlternativeConsequence();
      if (altConsequence != null) {
        try {
          List<Pair<SNode,String>> nodeAndMappingNamePairs=GeneratorUtil.getTemplateNodesFromRuleConsequence(altConsequence,templateContext.getInput(),nodeMacro.getNode(),myReductionContext,myGenerator);
          if (nodeAndMappingNamePairs == null) {
            myGenerator.showErrorMessage(templateContext.getInput(),null,nodeMacro.getNode(),"error processing $IF$/alternative");
            return null;
          }
          for (          Pair<SNode,String> nodeAndMappingNamePair : nodeAndMappingNamePairs) {
            SNode altTemplateNode=nodeAndMappingNamePair.o1;
            String innerMappingName=nodeAndMappingNamePair.o2 != null ? nodeAndMappingNamePair.o2 : mappingName;
            List<SNode> __outputNodes=createOutputNodesForExternalTemplateNode(innerMappingName,altTemplateNode,TemplateContext.getContext(templateContext,innerMappingName));
            if (__outputNodes != null) {
              if (_outputNodes == null)               _outputNodes=new ArrayList<SNode>();
              _outputNodes.addAll(__outputNodes);
            }
          }
        }
 catch (        AbandonRuleInputException e) {
        }
      }
    }
    if (_outputNodes != null)     outputNodes.addAll(_outputNodes);
    return outputNodes;
  }
 else   if (nodeMacro instanceof MapSrcNodeMacro || nodeMacro instanceof MapSrcListMacro) {
    MapSrcMacro_MapperFunction macro_mapperFunction;
    if (nodeMacro instanceof MapSrcNodeMacro) {
      macro_mapperFunction=((MapSrcNodeMacro)nodeMacro).getMapperFunction();
    }
 else {
      macro_mapperFunction=((MapSrcListMacro)nodeMacro).getMapperFunction();
    }
    List<SNode> newInputNodes=getNewInputNodes(nodeMacro,templateContext);
    for (    SNode newInputNode : newInputNodes) {
      boolean inputChanged=(newInputNode != templateContext.getInput());
      if (inputChanged) {
        generationTracer.pushInputNode(newInputNode);
      }
      try {
        TemplateContext newcontext=TemplateContext.getContext(templateContext,mappingName,newInputNode);
        if (macro_mapperFunction != null) {
          SNode childToReplaceLater=SModelUtil_new.instantiateConceptDeclaration(templateNode.getConceptFqName(),myOutputModel,myGenerator.getScope(),false);
          generationTracer.pushOutputNodeToReplaceLater(childToReplaceLater);
          outputNodes.add(childToReplaceLater);
          myGenerator.getDelayedChanges().addExecuteMapSrcNodeMacroChange(nodeMacro,childToReplaceLater,newcontext,myReductionContext);
        }
 else {
          List<SNode> _outputNodes=createOutputNodesForTemplateNode(mappingName,templateNode,newcontext,nodeMacrosToSkip + 1);
          if (_outputNodes != null) {
            outputNodes.addAll(_outputNodes);
            for (            SNode outputNode : _outputNodes) {
              myGenerator.getDelayedChanges().addExecuteMapSrcNodeMacroPostProcChange(nodeMacro,outputNode,newcontext,myReductionContext);
            }
          }
        }
      }
  finally {
        if (inputChanged) {
          generationTracer.closeInputNode(newInputNode);
        }
      }
    }
    return outputNodes;
  }
 else   if (nodeMacro instanceof SwitchMacro) {
    TemplateSwitch templateSwitch=((SwitchMacro)nodeMacro).getTemplateSwitch();
    if (templateSwitch == null) {
      myGenerator.showErrorMessage(templateContext.getInput(),nodeMacro.getNode(),"error processing $SWITCH$ - bad TemplateSwitch reference");
      return null;
    }
    SNode newInputNode=getNewInputNode(nodeMacro,templateContext);
    if (newInputNode == null) {
      GeneratorMessage generatorMessage=templateSwitch.getNullInputMessage();
      if (generatorMessage != null) {
        GeneratorUtil.processGeneratorMessage(generatorMessage,templateContext.getInput(),nodeMacro.getNode(),null,myGenerator);
      }
      return outputNodes;
    }
    boolean inputChanged=(newInputNode != templateContext.getInput());
    if (inputChanged) {
      generationTracer.pushInputNode(newInputNode);
    }
    generationTracer.pushSwitch(templateSwitch.getNode());
    try {
      List<SNode> _outputNodes=null;
      RuleConsequence consequenceForCase=(RuleConsequence)myGenerator.getRuleManager().getConsequenceForSwitchCase(newInputNode,templateSwitch,myReductionContext,myGenerator);
      if (consequenceForCase == null) {
        _outputNodes=createOutputNodesForTemplateNode(mappingName,templateNode,TemplateContext.getContext(templateContext,mappingName,newInputNode),nodeMacrosToSkip + 1);
      }
 else {
        List<Pair<SNode,String>> nodeAndMappingNamePairs=GeneratorUtil.getTemplateNodesFromRuleConsequence(consequenceForCase,newInputNode,nodeMacro.getNode(),myReductionContext,myGenerator);
        if (nodeAndMappingNamePairs == null) {
          myGenerator.showErrorMessage(newInputNode,nodeMacro.getNode(),consequenceForCase.getNode(),"error processing $SWITCH$");
          return null;
        }
        for (        Pair<SNode,String> nodeAndMappingNamePair : nodeAndMappingNamePairs) {
          SNode templateNodeForCase=nodeAndMappingNamePair.o1;
          String innerMappingName=nodeAndMappingNamePair.o2 != null ? nodeAndMappingNamePair.o2 : mappingName;
          List<SNode> __outputNodes=createOutputNodesForExternalTemplateNode(innerMappingName,templateNodeForCase,TemplateContext.getContext(templateContext,innerMappingName,newInputNode));
          if (__outputNodes != null) {
            if (_outputNodes == null)             _outputNodes=new ArrayList<SNode>();
            _outputNodes.addAll(__outputNodes);
          }
        }
      }
      if (_outputNodes != null)       outputNodes.addAll(_outputNodes);
    }
 catch (    AbandonRuleInputException e) {
    }
 finally {
      if (inputChanged) {
        generationTracer.closeInputNode(newInputNode);
      }
    }
    return outputNodes;
  }
 else   if (nodeMacro instanceof IncludeMacro) {
    SNode newInputNode=getNewInputNode(nodeMacro,templateContext);
    if (newInputNode == null) {
      return outputNodes;
    }
    IncludeMacro includeMacro=(IncludeMacro)nodeMacro;
    TemplateDeclaration includeTemplate=includeMacro.getIncludeTemplate();
    if (includeTemplate == null) {
      myGenerator.showErrorMessage(newInputNode,null,nodeMacro.getNode(),"error processing $INCLUDE$ : no 'include template'");
      return null;
    }
    final List<TemplateParameterDeclaration> parameterDeclarations=includeTemplate.getParameters();
    if (parameterDeclarations != null && parameterDeclarations.size() > 0) {
      for (      TemplateParameterDeclaration decl : parameterDeclarations) {
        String name=decl.getName();
        if (name != null && !templateContext.hasVariable(name)) {
          myGenerator.showErrorMessage(newInputNode,null,nodeMacro.getNode(),"error processing $INCLUDE$: parameter `" + name + "' is missing");
        }
      }
    }
    List<TemplateFragment> fragments=GeneratorUtil.getTemplateFragments(includeTemplate);
    if (!GeneratorUtil.checkIfOneOrMaryAdjacentFragments(fragments,BaseAdapter.fromAdapter(includeTemplate),newInputNode,nodeMacro.getNode(),myGenerator)) {
      myGenerator.showErrorMessage(newInputNode,null,nodeMacro.getNode(),"error processing $INCLUDE$");
      return null;
    }
    boolean inputChanged=(newInputNode != templateContext.getInput());
    if (inputChanged) {
      generationTracer.pushInputNode(newInputNode);
    }
    generationTracer.pushTemplateNode(includeTemplate.getNode());
    try {
      for (      TemplateFragment fragment : fragments) {
        SNode templateForInclude=fragment.getParent().getNode();
        mappingName=GeneratorUtil.getMappingName(fragment,mappingName);
        List<SNode> _outputNodes=createOutputNodesForExternalTemplateNode(mappingName,templateForInclude,TemplateContext.getContext(templateContext,mappingName,newInputNode));
        if (_outputNodes != null)         outputNodes.addAll(_outputNodes);
      }
    }
  finally {
      if (inputChanged) {
        generationTracer.closeInputNode(newInputNode);
      }
    }
    return outputNodes;
  }
 else   if (nodeMacro instanceof TemplateCallMacro) {
    SNode newInputNode=getNewInputNode(nodeMacro,templateContext);
    if (newInputNode == null) {
      return outputNodes;
    }
    TemplateCallMacro callMacro=(TemplateCallMacro)nodeMacro;
    TemplateDeclaration template=callMacro.getTemplate();
    if (template == null) {
      myGenerator.showErrorMessage(newInputNode,null,nodeMacro.getNode(),"error processing $CALL$ : no 'include template'");
      return null;
    }
    TemplateContext newcontext=GeneratorUtil.createTemplateContext(templateContext.getInput(),templateContext,myReductionContext,callMacro,newInputNode,myGenerator);
    List<TemplateFragment> fragments=GeneratorUtil.getTemplateFragments(template);
    if (!GeneratorUtil.checkIfOneOrMaryAdjacentFragments(fragments,BaseAdapter.fromAdapter(template),newInputNode,nodeMacro.getNode(),myGenerator)) {
      myGenerator.showErrorMessage(newInputNode,null,nodeMacro.getNode(),"error processing $CALL$");
      return null;
    }
    boolean inputChanged=(newInputNode != templateContext.getInput());
    if (inputChanged) {
      generationTracer.pushInputNode(newInputNode);
    }
    generationTracer.pushTemplateNode(template.getNode());
    try {
      for (      TemplateFragment fragment : fragments) {
        SNode templateForInclude=fragment.getParent().getNode();
        mappingName=GeneratorUtil.getMappingName(fragment,mappingName);
        List<SNode> _outputNodes=createOutputNodesForExternalTemplateNode(mappingName,templateForInclude,TemplateContext.getContext(newcontext,mappingName));
        if (_outputNodes != null)         outputNodes.addAll(_outputNodes);
      }
    }
  finally {
      if (inputChanged) {
        generationTracer.closeInputNode(newInputNode);
      }
    }
    return outputNodes;
  }
 else {
    List<SNode> newInputNodes=getNewInputNodes(nodeMacro,templateContext);
    for (    SNode newInputNode : newInputNodes) {
      boolean inputChanged=(newInputNode != templateContext.getInput());
      if (inputChanged) {
        generationTracer.pushInputNode(newInputNode);
      }
      try {
        List<SNode> _outputNodes=createOutputNodesForTemplateNode(mappingName,templateNode,TemplateContext.getContext(templateContext,mappingName,newInputNode),nodeMacrosToSkip + 1);
        if (_outputNodes != null)         outputNodes.addAll(_outputNodes);
      }
  finally {
        if (inputChanged) {
          generationTracer.closeInputNode(newInputNode);
        }
      }
    }
    return outputNodes;
  }
}
