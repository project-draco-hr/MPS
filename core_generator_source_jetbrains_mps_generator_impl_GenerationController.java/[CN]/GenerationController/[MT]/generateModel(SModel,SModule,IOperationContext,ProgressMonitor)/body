{
  boolean currentGenerationOK=false;
  IPerformanceTracer ttrace=myOptions.getTracingMode() != GenerationOptions.TRACE_OFF ? new PerformanceTracer("model " + NameUtil.shortNameFromLongName(inputModel.getModelName())) : new NullPerformanceTracer();
  boolean traceTypes=myOptions.getTracingMode() == GenerationOptions.TRACE_TYPES;
  TypeChecker.getInstance().generationStarted(traceTypes ? ttrace : null);
  final GenerationSession generationSession=new GenerationSession(inputModel,invocationContext,this,myCancellationMonitor,myLogger,myTransientModelsProvider.getModule(module),ttrace,myOptions);
  monitor.start(inputModel.getModelName(),10);
  try {
    generationSession.getLoggingHandler().register();
    if (!myGenerationHandler.canHandle(inputModel)) {
      myLogger.error("Can't generate " + inputModel.getModelName());
      return true;
    }
    if (myLogger.needsInfo()) {
      myLogger.info("");
      myLogger.info("[model " + inputModel.getModelName() + (myOptions.isRebuildAll() ? ", rebuilding" : "")+ (myOptions.isGenerateInParallel() ? ", using " + myOptions.getNumberOfThreads() + " threads]" : "]"));
    }
    GenerationStatus status=generationSession.generateModel(monitor.subTask(9));
    monitor.advance(0);
    status.setOriginalInputModel(inputModel);
    currentGenerationOK=status.isOk();
    checkMonitorCanceled(monitor);
    currentGenerationOK=currentGenerationOK && myGenerationHandler.handleOutput(module,inputModel,status,invocationContext,monitor.subTask(1));
    monitor.advance(0);
  }
  finally {
    generationSession.getLoggingHandler().unregister();
    generationSession.discardTransients();
    monitor.done();
    TypeChecker.getInstance().generationFinished();
  }
  String report=ttrace.report();
  if (report != null) {
    myLogger.trace(report);
  }
  return currentGenerationOK;
}
