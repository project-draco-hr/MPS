{
  myLogger.clear();
  long startJobTime=System.currentTimeMillis();
  myGenerationHandler.startGeneration(myLogger);
  initMaps();
  try {
    boolean generationOK=true;
    final int compileWork=myModuleSequence.size();
    int totalWork=compileWork + myInputModels.size();
    monitor.start("",totalWork);
    try {
      for (      Pair<SModule,List<SModel>> moduleAndDescriptors : myModuleSequence) {
        final List<SModel> mlist=moduleAndDescriptors.o2;
        final ProgressMonitor pm=monitor.subTask(mlist.size());
        boolean result=generateModelsInModule(moduleAndDescriptors.o1,mlist,pm);
        pm.done();
        generationOK=generationOK && result;
      }
    }
  finally {
      if (myParallelTaskPool != null) {
        myParallelTaskPool.dispose();
        myParallelTaskPool=null;
      }
    }
    if (generationOK) {
      if (myLogger.needsInfo()) {
        myLogger.info("generation completed successfully in " + (System.currentTimeMillis() - startJobTime) + " ms");
      }
      generationOK=myGenerationHandler.compile(null,myModuleSequence,true,monitor.subTask(compileWork));
      monitor.advance(0);
    }
 else {
      myLogger.error("generation completed with errors in " + (System.currentTimeMillis() - startJobTime) + " ms");
    }
    return generationOK;
  }
 catch (  GenerationCanceledException gce) {
    myLogger.warning("generation canceled");
    return false;
  }
catch (  Exception t) {
    myLogger.handleException(t);
    return false;
  }
catch (  AssertionError e) {
    myLogger.handleException(e);
    throw e;
  }
 finally {
    monitor.done();
    myGenerationHandler.finishGeneration();
  }
}
