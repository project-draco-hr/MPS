{
  long startJobTime=System.currentTimeMillis();
  try {
    boolean generationOK=true;
    monitor.start("",myTasks.size());
    try {
      for (      GeneratorTask t : myTasks) {
        checkMonitorCanceled(monitor);
        boolean result=generateModel(t,monitor.subTask(1,SubProgressKind.REPLACING));
        generationOK=generationOK && result;
      }
    }
  finally {
      if (myParallelTaskPool != null) {
        myParallelTaskPool.dispose();
        myParallelTaskPool=null;
      }
    }
    if (generationOK) {
      if (myLogger.needsInfo()) {
        myLogger.info("generation completed successfully in " + (System.currentTimeMillis() - startJobTime) + " ms");
      }
      monitor.advance(0);
    }
 else {
      myLogger.error("generation completed with errors in " + (System.currentTimeMillis() - startJobTime) + " ms");
    }
    return generationOK;
  }
 catch (  GenerationCanceledException gce) {
    myLogger.warning("generation canceled");
    return false;
  }
catch (  Exception t) {
    myLogger.handleException(t);
    return false;
  }
catch (  AssertionError e) {
    myLogger.handleException(e);
    throw e;
  }
 finally {
    monitor.done();
  }
}
