{
  myLogger.clear();
  long startJobTime=System.currentTimeMillis();
  myGenerationHandler.startGeneration(myLogger);
  initMaps();
  try {
    boolean generationOK=true;
    final int compileWork=myGenerationHandler.estimateCompilationMillis();
    int totalWork=compileWork;
    for (    Pair<IModule,List<SModelDescriptor>> moduleAndDescriptors : myModuleSequence) {
      totalWork+=moduleAndDescriptors.o2 != null ? moduleAndDescriptors.o2.size() : 0;
    }
    monitor.start("",totalWork);
    try {
      for (      Pair<IModule,List<SModelDescriptor>> moduleAndDescriptors : myModuleSequence) {
        final List<SModelDescriptor> mlist=moduleAndDescriptors.o2;
        boolean result=generateModelsInModule(moduleAndDescriptors.o1,mlist,monitor.subTask(mlist != null ? mlist.size() : 0));
        monitor.advance(0);
        generationOK=generationOK && result;
      }
    }
  finally {
      if (myParallelTaskPool != null) {
        myParallelTaskPool.dispose();
        myParallelTaskPool=null;
      }
    }
    if (generationOK) {
      if (myLogger.needsInfo()) {
        myLogger.info("generation completed successfully in " + (System.currentTimeMillis() - startJobTime) + " ms");
      }
      generationOK=myGenerationHandler.compile(myOperationContext,myModuleSequence,true,monitor.subTask(compileWork));
      monitor.advance(0);
    }
 else {
      myLogger.error("generation completed with errors in " + (System.currentTimeMillis() - startJobTime) + " ms");
    }
    return generationOK;
  }
 catch (  GenerationCanceledException gce) {
    myLogger.warning("generation canceled");
    return false;
  }
catch (  GenerationFailureException e) {
    if (e.getMessage() != null && e.getCause() == null) {
      myLogger.error(e.getMessage());
    }
    return false;
  }
catch (  Exception t) {
    myLogger.handleException(t);
    return false;
  }
 finally {
    monitor.done();
    myGenerationHandler.finishGeneration();
  }
}
