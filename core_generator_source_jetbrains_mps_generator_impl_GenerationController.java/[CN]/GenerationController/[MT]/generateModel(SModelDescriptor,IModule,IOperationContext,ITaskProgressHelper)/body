{
  boolean currentGenerationOK=false;
  IPerformanceTracer ttrace=myOptions.getTracingMode() != GenerationOptions.TRACE_OFF ? new PerformanceTracer("model " + NameUtil.shortNameFromLongName(inputModel.getLongName())) : new NullPerformanceTracer();
  boolean traceTypes=myOptions.getTracingMode() == GenerationOptions.TRACE_TYPES;
  TypeChecker.getInstance().setIsGeneration(true,traceTypes ? ttrace : null);
  final GenerationSession generationSession=new GenerationSession(inputModel,invocationContext,this,myProgress,myLogger,myTransientModelsComponent.getModule(module),ttrace,myOptions);
  try {
    Logger.addLoggingHandler(generationSession.getLoggingHandler());
    if (!myGenerationHandler.canHandle(inputModel)) {
      LOG.error("Can't generate " + inputModel.getSModelReference().getSModelFqName());
      return true;
    }
    if (myLogger.needsInfo()) {
      myLogger.info("");
    }
    String taskName=ModelsProgressUtil.generationModelTaskName(inputModel);
    progressHelper.setText2("Generating " + inputModel.getSModelReference().getSModelFqName());
    progressHelper.startLeafTask(taskName);
    if (myLogger.needsInfo()) {
      myLogger.info("[model " + inputModel.getSModelReference().getSModelFqName() + (myOptions.isRebuildAll() ? ", rebuilding" : "")+ (myOptions.isGenerateInParallel() ? ", using " + myOptions.getNumberOfThreads() + " threads]" : "]"));
    }
    try {
      currentGenerationOK=GeneratorUtil.runReadInWrite(new GenerationComputable<Boolean>(){
        @Override public Boolean compute() throws GenerationCanceledException {
          GenerationStatus status=generationSession.generateModel();
          status.setOriginalInputModel(inputModel);
          boolean currentGenerationOK=status.isOk();
          checkMonitorCanceled();
          currentGenerationOK=currentGenerationOK && myGenerationHandler.handleOutput(module,inputModel,status,invocationContext,progressHelper);
          return currentGenerationOK;
        }
      }
);
    }
 catch (    GenerationFailureException e) {
    }
  }
  finally {
    Logger.removeLoggingHandler(generationSession.getLoggingHandler());
    generationSession.discardTransients();
    CleanupManager.getInstance().cleanup();
    progressHelper.finishTask();
    TypeChecker.getInstance().setIsGeneration(false);
    progressHelper.setText2("");
  }
  String report=ttrace.report();
  if (report != null) {
    myLogger.trace(report);
  }
  return currentGenerationOK;
}
