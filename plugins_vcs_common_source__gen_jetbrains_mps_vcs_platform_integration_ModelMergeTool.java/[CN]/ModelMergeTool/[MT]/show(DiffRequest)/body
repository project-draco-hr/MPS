{
  MergeRequestImpl mrequest=(MergeRequestImpl)request;
  try {
    VirtualFile file=getFileFromMergeRequest(mrequest);
    if (file == null) {
      if (log.isErrorEnabled()) {
        log.error("No file");
      }
      file=LocalFileSystem.getInstance().findFileByPath("/");
    }
    File backupFile=MergeBackupUtil.zipModel(request.getContents(),file);
    DiffContent[] contents=mrequest.getContents();
    final SModel baseModel;
    final SModel mineModel;
    final SModel newModel;
    try {
      baseModel=ModelPersistence.readModel(contents[MergeConstants.ORIGINAL].getDocument().getText(),false);
      mineModel=ModelPersistence.readModel(new String(contents[MergeConstants.CURRENT].getBytes(),FileUtil.DEFAULT_CHARSET),false);
      newModel=ModelPersistence.readModel(new String(contents[MergeConstants.LAST_REVISION].getBytes(),FileUtil.DEFAULT_CHARSET),false);
    }
 catch (    ModelReadException e) {
      if (log.isWarnEnabled()) {
        log.warn("Couldn't read model, invoking text merge",e);
      }
      super.show(request);
      return;
    }
    final MergeModelsDialog dialog=new MergeModelsDialog(baseModel,mineModel,newModel,mrequest);
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        dialog.toFront();
      }
    }
);
    dialog.show();
    if (dialog.getResultModel() != null) {
      String asString=ModelPersistence.modelToString(dialog.getResultModelWithFixedId());
      resolved(mrequest,asString);
      MergeBackupUtil.packMergeResult(backupFile,file.getName(),asString);
    }
    dialog.unregisterResultModel();
  }
 catch (  IOException e) {
    LOG.error(e);
  }
}
