{
  RuleManager ruleManager=new RuleManager(this);
  RuleUtil ruleUtil=new RuleUtil(ruleManager);
  ruleManager.getReductionRuleManager().setRuleUtil(ruleUtil);
  for (  CreateRootRule createRootRule : ruleManager.getCreateRootRules()) {
    ruleUtil.applyRootRule(createRootRule);
  }
  for (  MappingRule mappingRule : ruleManager.getMappingRules()) {
    ruleUtil.applyMappingRule(mappingRule);
  }
  for (  Root_MappingRule rootMappingRule : ruleManager.getRoot_MappingRules()) {
    ruleUtil.applyRoot_MappingRule(rootMappingRule);
  }
  for (  WeavingRule weavingRule : ruleManager.getWeavingRules()) {
    ruleUtil.applyWeavingRule(weavingRule);
  }
  for (  Weaving_MappingRule weavingMappingRule : ruleManager.getWeaving_MappingRules()) {
    ruleUtil.applyWeavingMappingRule(weavingMappingRule);
  }
  ArrayList<ReferenceInfo> referenceInfos=myReferenceInfos;
  ArrayList<ReferenceInfo> newReferenceInfos=new ArrayList<ReferenceInfo>(referenceInfos.size());
  while (true) {
    for (    ReferenceInfo referenceInfo : referenceInfos) {
      referenceInfo.execute(this);
      if (!referenceInfo.isSuccess()) {
        newReferenceInfos.add(referenceInfo);
      }
    }
    if (newReferenceInfos.size() == 0 || newReferenceInfos.size() == referenceInfos.size()) {
      break;
    }
    referenceInfos=newReferenceInfos;
    newReferenceInfos=new ArrayList<ReferenceInfo>(referenceInfos.size());
  }
  for (  SNode rootNode : myRootsToDelete) {
    myModel.removeRoot(rootNode);
  }
  for (  SNode rootNode : myModel.getRoots()) {
    List<ConceptDeclaration> abandonedRootConcepts=ruleManager.getAbandonedRootConcepts();
    for (    ConceptDeclaration abandonedRootConcept : abandonedRootConcepts) {
      if (rootNode.isInstanceOfConcept(abandonedRootConcept,getScope())) {
        myModel.removeRoot(rootNode);
      }
    }
  }
  for (  SNode sourceRootNode : myModel.getRoots()) {
    ruleManager.getReductionRuleManager().applyReductionRules(sourceRootNode);
  }
  for (  SNode rootNode : myNewRootNodes) {
    myModel.addRoot(rootNode);
  }
  myDelayedChanges.doAllChanges();
}
