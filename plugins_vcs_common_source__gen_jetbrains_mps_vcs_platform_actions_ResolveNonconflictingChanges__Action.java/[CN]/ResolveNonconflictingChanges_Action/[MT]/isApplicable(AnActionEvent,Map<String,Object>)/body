{
  MergeProvider provider=GitVcs.getInstance(((MPSProject)MapSequence.fromMap(_params).get("project")).getProject()).getMergeProvider();
  for (  VirtualFile file : ListSequence.fromList(ResolveNonconflictingChanges_Action.this.getConflictedFIles(_params))) {
    FileType fileType=file.getFileType();
    if (!((SetSequence.fromSet(ModelMergeTool.SUPPORTED_TYPES).contains(fileType)))) {
      continue;
    }
    IFile iFile=FileSystem.getInstance().getFileByPath(file.getPath());
    String ext=file.getExtension();
    if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
      ext=MPSExtentions.MODEL;
    }
    MergeData mergeData=null;
    try {
      mergeData=provider.loadRevisions(file);
    }
 catch (    VcsException e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Error loading revisions to merge",e);
      }
    }
    SModel baseModel=PersistenceUtil.loadModel(mergeData.ORIGINAL,ext);
    SModel mineModel=PersistenceUtil.loadModel(mergeData.CURRENT,ext);
    SModel repoModel=PersistenceUtil.loadModel(mergeData.LAST,ext);
    final MergeSession mergeSession=MergeSession.createMergeSession(baseModel,mineModel,repoModel);
    int conflictingChangesCount=Sequence.fromIterable(mergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>(){
      public boolean accept(      ModelChange c){
        return Sequence.fromIterable(mergeSession.getConflictedWith(c)).isNotEmpty();
      }
    }
).count();
    if (conflictingChangesCount == 0) {
      return true;
    }
  }
  return false;
}
