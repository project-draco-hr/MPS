{
  MergeProvider provider=GitVcs.getInstance(((MPSProject)MapSequence.fromMap(_params).get("project")).getProject()).getMergeProvider();
  for (  VirtualFile file : ListSequence.fromList(ResolveNonconflictingChanges_Action.this.getConflictingModelFiles(((MPSProject)MapSequence.fromMap(_params).get("project")).getProject(),_params))) {
    MergeData mergeData=null;
    try {
      mergeData=provider.loadRevisions(file);
    }
 catch (    VcsException e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Error loading revisions to merge",e);
      }
    }
    IFile iFile=FileSystem.getInstance().getFileByPath(file.getPath());
    String ext=file.getExtension();
    if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
      ext=MPSExtentions.MODEL;
    }
    SModel baseModel=PersistenceUtil.loadModel(new String(mergeData.ORIGINAL),ext);
    SModel mineModel=PersistenceUtil.loadModel(new String(mergeData.CURRENT),ext);
    SModel repoModel=PersistenceUtil.loadModel(new String(mergeData.LAST),ext);
    final MergeSession mergeSession=MergeSession.createMergeSession(baseModel,mineModel,repoModel);
    int conflictingChangesCount=Sequence.fromIterable(mergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>(){
      public boolean accept(      ModelChange c){
        return Sequence.fromIterable(mergeSession.getConflictedWith(c)).isNotEmpty();
      }
    }
).count();
    if (conflictingChangesCount == 0) {
      return true;
    }
  }
  return false;
}
