{
  try {
    List<VirtualFile> conflictedModelFiles=ResolveNonconflictingChanges_Action.this.getConflictingModelFiles(((MPSProject)MapSequence.fromMap(_params).get("project")).getProject(),_params);
    MergeProvider provider=GitVcs.getInstance(((MPSProject)MapSequence.fromMap(_params).get("project")).getProject()).getMergeProvider();
    com.intellij.openapi.vcs.merge.MergeSession session=(provider instanceof MergeProvider2 ? ((MergeProvider2)provider).createMergeSession(conflictedModelFiles) : null);
    for (    final VirtualFile file : ListSequence.fromList(conflictedModelFiles)) {
      MergeData mergeData=null;
      try {
        mergeData=provider.loadRevisions(file);
      }
 catch (      VcsException e) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Error loading revisions to merge",e);
        }
      }
      IFile iFile=FileSystem.getInstance().getFileByPath(file.getPath());
      String ext=file.getExtension();
      if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
        ext=MPSExtentions.MODEL;
      }
      SModel baseModel=PersistenceUtil.loadModel(new String(mergeData.ORIGINAL),ext);
      SModel mineModel=PersistenceUtil.loadModel(new String(mergeData.CURRENT),ext);
      SModel repoModel=PersistenceUtil.loadModel(new String(mergeData.LAST),ext);
      final MergeSession mergeSession=MergeSession.createMergeSession(baseModel,mineModel,repoModel);
      int conflictingChangesCount=Sequence.fromIterable(mergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>(){
        public boolean accept(        ModelChange c){
          return Sequence.fromIterable(mergeSession.getConflictedWith(c)).isNotEmpty();
        }
      }
).count();
      if (conflictingChangesCount != 0) {
        if (LOG.isInfoEnabled()) {
          LOG.info("there are still conflicted changes in " + SModelOperations.getModelName(baseModel));
        }
        continue;
      }
      if (LOG.isInfoEnabled()) {
        LOG.info("no conflicted changes in " + SModelOperations.getModelName(baseModel));
      }
      mergeSession.applyChanges(mergeSession.getAllChanges());
      if (mergeSession.hasIdsToRestore()) {
        if (LOG.isInfoEnabled()) {
          LOG.info(String.format("%s: node id duplication detected, should merge in UI.",SModelOperations.getModelName(baseModel)));
        }
        continue;
      }
      SModel resultModel=mergeSession.getResultModel();
      if (resultModel != null) {
        final Wrappers._T<String> resultContent=new Wrappers._T<String>();
        if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
          resultContent.value=PersistenceUtil.savePerRootModel(resultModel,file.getExtension().equals(MPSExtentions.MODEL_HEADER));
        }
 else {
          resultContent.value=PersistenceUtil.saveModel(resultModel,ext);
        }
        ModelAccess.instance().runWriteInEDT(new Runnable(){
          public void run(){
            try {
              file.setBinaryContent(resultContent.value.getBytes(FileUtil.DEFAULT_CHARSET));
            }
 catch (            IOException e) {
              if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("",e);
              }
            }
          }
        }
);
        check_nkvzp6_a4a81a7a0(session,file);
        VcsDirtyScopeManager.getInstance(((MPSProject)MapSequence.fromMap(_params).get("project")).getProject()).fileDirty(file);
      }
    }
  }
 catch (  Throwable t) {
    if (LOG.isEnabledFor(Level.ERROR)) {
      LOG.error("User's action execute method failed. Action:" + "ResolveNonconflictingChanges",t);
    }
  }
}
