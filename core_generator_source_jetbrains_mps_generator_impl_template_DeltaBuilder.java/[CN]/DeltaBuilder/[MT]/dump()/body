{
  for (  CopyRoot root : roots) {
    char c=root.deleted ? '-' : (root.mySubTrees.length > 0 ? '+' : '~');
    System.out.printf("%c%s\n",c,SNodeUtil.getDebugText(root.myRoot));
    for (    SubTree tree : root.mySubTrees) {
      if (tree.isCopySrcRoot()) {
        System.out.printf("    copysrc %s\n",tree.myInputNode);
      }
 else {
        System.out.printf("    %s - %d - %s\n",tree.myRoleInParent,tree.mySubTree.size(),tree.myInputNode);
      }
    }
  }
  if (hasChanges()) {
    HashSet<SNode> allReplacedNodes=new HashSet<SNode>();
    for (    CopyRoot root : roots) {
      if (!root.deleted) {
        allReplacedNodes.addAll(root.getReplacedNodes());
      }
    }
    for (    CopyRoot root : roots) {
      if (root.deleted) {
        continue;
      }
      final SModelReference inputModelRef=root.myRoot.getModel().getReference();
      final Set<SNode> replacedNodes=root.getReplacedNodes();
      TreeIterator<SNode> it=(TreeIterator<SNode>)SNodeUtil.getDescendants(root.myRoot).iterator();
      while (it.hasNext()) {
        SNode next=it.next();
        if (replacedNodes.contains(next)) {
          it.skipChildren();
          continue;
        }
        for (        SReference reference : next.getReferences()) {
          if (reference instanceof PostponedReference) {
            System.out.println("!!! unexpected PostponedReference in the input model");
          }
          if (!inputModelRef.equals(reference.getTargetSModelReference())) {
            continue;
          }
          SNode target=reference.getTargetNode();
          while (target != null) {
            if (allReplacedNodes.contains(target)) {
              System.out.printf("--> Reference in '%s' needs update, its target %s is among replaced nodes\n",reference.getRole(),target.getName());
              break;
            }
            target=target.getParent();
          }
        }
      }
    }
  }
  System.out.println();
}
