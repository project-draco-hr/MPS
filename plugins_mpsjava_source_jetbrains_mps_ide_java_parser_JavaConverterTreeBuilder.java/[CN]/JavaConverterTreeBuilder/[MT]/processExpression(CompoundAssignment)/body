{
  BaseAssignmentExpression op;
switch (x.operator) {
case CompoundAssignment.PLUS:
    op=PlusAssignmentExpression.newInstance(myCurrentModel);
  break;
case CompoundAssignment.MINUS:
op=MinusAssignmentExpression.newInstance(myCurrentModel);
break;
case CompoundAssignment.MULTIPLY:
op=MulAssignmentExpression.newInstance(myCurrentModel);
break;
case CompoundAssignment.DIVIDE:
op=DivAssignmentExpression.newInstance(myCurrentModel);
break;
case CompoundAssignment.AND:
op=AndAssignmentExpression.newInstance(myCurrentModel);
break;
case CompoundAssignment.OR:
op=OrAssignmentExpression.newInstance(myCurrentModel);
break;
case CompoundAssignment.XOR:
op=XorAssignmentExpression.newInstance(myCurrentModel);
break;
case CompoundAssignment.REMAINDER:
op=RemAssignmentExpression.newInstance(myCurrentModel);
break;
case CompoundAssignment.LEFT_SHIFT:
op=LeftShiftAssignmentExpression.newInstance(myCurrentModel);
break;
case CompoundAssignment.RIGHT_SHIFT:
op=RightShiftAssignmentExpression.newInstance(myCurrentModel);
break;
default :
throw new JavaConverterException("Unsupported operator for CompoundAssignment");
}
op.setLValue(processExpressionRefl(x.lhs));
op.setRValue(processExpressionRefl(x.expression));
return op;
}
