{
  boolean insertion=myContextMethod != null && SNodeOperations.getParent(myContextMethod) == myClassConcept;
  List<SNode> result=new ArrayList<SNode>();
  for (  SNode m : baseMethods) {
    SNode baseMethod=SNodeOperations.cast(m,"jetbrains.mps.lang.behavior.structure.ConceptMethodDeclaration");
    SNode method=SNodeOperations.cast(BehaviorReflection.invokeNonVirtual((Class<SNode>)((Class)Object.class),baseMethod,"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration","call_getMethodToImplement_69709522611978987",new Object[]{myClassConcept}),"jetbrains.mps.lang.behavior.structure.ConceptMethodDeclaration");
    SPropertyOperations.set(method,"isAbstract","" + (false));
    SLinkOperations.setTarget(method,"body",SNodeFactoryOperations.createNewNode(SNodeOperations.getModel(myClassConcept),"jetbrains.mps.baseLanguage.structure.StatementList",null),true);
    SLinkOperations.setTarget(method,"overriddenMethod",BehaviorReflection.invokeNonVirtual((Class<SNode>)((Class)Object.class),baseMethod,"jetbrains.mps.lang.behavior.structure.ConceptMethodDeclaration","call_getOverridenMethod_1225196403956",new Object[]{}),false);
    SPropertyOperations.set(method,"isVirtual","" + (false));
    if (insertion) {
      ListSequence.fromList(SLinkOperations.getTargets(myClassConcept,"method",true)).insertElement(ListSequence.fromList(SLinkOperations.getTargets(myClassConcept,"method",true)).indexOf(myContextMethod) + 1,method);
    }
 else {
      ListSequence.fromList(SLinkOperations.getTargets(myClassConcept,"method",true)).addElement(method);
    }
    update(method,baseMethod);
    ListSequence.fromList(result).addElement(method);
  }
  return result;
}
