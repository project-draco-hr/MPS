{
  List<Vector> portOrigins=new ArrayList<Vector>(portDimensions.size());
  Vector borderDir=dir.turnCounterclockwise().dir();
  Segment border=null;
  for (  Segment s : myRect.getBoundSegments()) {
    Vector sDir=s.end.sub(s.start);
    if (borderDir.isParallel(sDir) && borderDir.dotProduct(sDir) > 0) {
      border=s;
      break;
    }
  }
  if (border == null) {
    throw new IllegalStateException();
  }
  boolean reverted=false;
  if (border.start.x > border.end.x || border.start.y > border.end.y) {
    border=new Segment(border.end,border.start);
    borderDir=dir.turnClockwise().dir();
    reverted=true;
  }
  if (portDimensions.size() == 1) {
    Vector dim=portDimensions.get(0);
    Vector borderShift=border.end.sub(border.start).sub(mulCoord(dim,borderDir));
    borderShift=new Vector(borderShift.x / 2,borderShift.y / 2);
    Vector portLoc=border.start.add(borderShift);
    portOrigins.add(portLoc.add(mulCoord(SHIFT_TO_ORIGIN[dir.ordinal()],dim)));
  }
 else   if (portDimensions.size() > 1) {
    Vector childrenLen=Vector.ZERO;
    for (    Vector dim : portDimensions) {
      childrenLen=childrenLen.add(mulCoord(dim,borderDir));
    }
    Vector space=border.end.sub(border.start).sub(childrenLen);
    Vector offset=Vector.ZERO;
    for (    Vector dim : portDimensions) {
      Vector portLocation=border.start.add(offset);
      portOrigins.add(portLocation.add(mulCoord(SHIFT_TO_ORIGIN[dir.ordinal()],dim)));
      offset=offset.add(space).add(mulCoord(dim,borderDir));
    }
  }
  if (reverted) {
    Collections.reverse(portOrigins);
  }
  return portOrigins;
}
