{
  final Map<ModelChange,Bounds> left=MapSequence.fromMap(new HashMap<ModelChange,Bounds>());
  final Map<ModelChange,Bounds> right=MapSequence.fromMap(new HashMap<ModelChange,Bounds>());
  for (  ModelChange change : ListSequence.fromList(check_cuq72k_a2a11(getChangeSet(),this))) {
    Bounds leftBounds=findBounds(getLeftMessages(change),getLeftComponent());
    Bounds rightBounds=findBounds(getRightMessages(change),getRightComponent());
    if (leftBounds.length() <= 0 && rightBounds.length() <= 0) {
      continue;
    }
    MapSequence.fromMap(left).put(change,leftBounds);
    MapSequence.fromMap(right).put(change,rightBounds);
  }
  Set<ModelChange> changes=MapSequence.fromMap(left).keySet();
  DisjointSets<ModelChange> ds=new DisjointSets<ModelChange>(changes);
  for (  ModelChange a : SetSequence.fromSet(changes)) {
    for (    ModelChange b : SetSequence.fromSet(changes)) {
      if (!(areBoundsSeparate(MapSequence.fromMap(left).get(a),MapSequence.fromMap(left).get(b),myMergeAdjacent)) || !(areBoundsSeparate(MapSequence.fromMap(right).get(a),MapSequence.fromMap(right).get(b),myMergeAdjacent))) {
        ds.unite(a,b);
      }
    }
  }
  myChangeGroups=ListSequence.fromList(new ArrayList<ChangeGroup>());
  for (  Set<ModelChange> s : Sequence.fromIterable(ds.getSets())) {
    Bounds lb=SetSequence.fromSet(s).select(new ISelector<ModelChange,Bounds>(){
      public Bounds select(      ModelChange ch){
        return MapSequence.fromMap(left).get(ch);
      }
    }
).reduceLeft(new ILeftCombinator<Bounds,Bounds>(){
      public Bounds combine(      Bounds a,      Bounds b){
        return a.merge(b);
      }
    }
);
    Bounds rb=SetSequence.fromSet(s).select(new ISelector<ModelChange,Bounds>(){
      public Bounds select(      ModelChange ch){
        return MapSequence.fromMap(right).get(ch);
      }
    }
).reduceLeft(new ILeftCombinator<Bounds,Bounds>(){
      public Bounds combine(      Bounds a,      Bounds b){
        return a.merge(b);
      }
    }
);
    List<ModelChange> sortedChanges=SetSequence.fromSet(s).sort(new ISelector<ModelChange,Integer>(){
      public Integer select(      ModelChange ch){
        return (int)(MapSequence.fromMap(right).get(ch).start());
      }
    }
,true).sort(new ISelector<ModelChange,Integer>(){
      public Integer select(      ModelChange ch){
        return (int)(MapSequence.fromMap(left).get(ch).start());
      }
    }
,true).toListSequence();
    ListSequence.fromList(myChangeGroups).addElement(new ChangeGroup(lb,rb,sortedChanges,myConflictChecker));
  }
  myChangeGroups=ListSequence.fromList(myChangeGroups).sort(new ISelector<ChangeGroup,Integer>(){
    public Integer select(    ChangeGroup g){
      return (int)(g.getLeftBounds().start());
    }
  }
,true).toListSequence();
}
