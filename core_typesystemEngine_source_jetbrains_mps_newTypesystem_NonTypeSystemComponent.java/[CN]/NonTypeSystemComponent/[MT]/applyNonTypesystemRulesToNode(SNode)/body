{
  Set<Pair<NonTypesystemRule_Runtime,IsApplicableStatus>> nonTypesystemRules=myTypeChecker.getRulesManager().getNonTypesystemRules(node);
  if (nonTypesystemRules != null) {
    for (    Pair<NonTypesystemRule_Runtime,IsApplicableStatus> rule : nonTypesystemRules) {
      Pair<SNode,NonTypesystemRule_Runtime> nodeAndRule=new Pair<SNode,NonTypesystemRule_Runtime>(node,rule.o1);
      MyTypesReadListener typesReadListener=new MyTypesReadListener();
      MyLanguageCachesReadListener languageCachesReadListener=new MyLanguageCachesReadListener();
      if (isIncrementalMode()) {
        if (myCheckedNodesNonTypesystem.contains(nodeAndRule)) {
          continue;
        }
        myNodesReadListener.clear();
        NodeReadEventsCaster.setNodesReadListener(myNodesReadListener);
        TypeChecker.getInstance().addTypesReadListener(typesReadListener);
        LanguageHierarchyCache.getInstance().setReadAccessListener(languageCachesReadListener);
        myRuleAndNodeBeingChecked=new Pair<SNode,NonTypesystemRule_Runtime>(node,rule.o1);
      }
      try {
        myNodeTypesComponent.applyRuleToNode(node,rule.o1,rule.o2);
      }
  finally {
        myRuleAndNodeBeingChecked=null;
        if (isIncrementalMode()) {
          LanguageHierarchyCache.getInstance().removeReadAccessListener();
          TypeChecker.getInstance().removeTypesReadListener(typesReadListener);
          NodeReadEventsCaster.removeNodesReadListener();
        }
      }
      if (isIncrementalMode()) {
synchronized (ACCESS_LOCK) {
          myNodesReadListener.setAccessReport(true);
          addDependentNodes(node,rule.o1,new HashSet<SNode>(myNodesReadListener.myAccessedNodes));
          addDependentProperties(node,rule.o1,new HashSet<Pair<SNode,String>>(myNodesReadListener.myAccessedProperties));
          myNodesReadListener.setAccessReport(false);
          languageCachesReadListener.setAccessReport(true);
          if (languageCachesReadListener.myIsCacheAccessed) {
            addCacheDependentNodesNonTypesystem(node,rule.o1);
          }
          languageCachesReadListener.setAccessReport(false);
          typesReadListener.setAccessReport(true);
          addDependentTypeTerms(node,rule.o1,new HashSet<SNode>(typesReadListener.myAccessedNodes));
          typesReadListener.setAccessReport(false);
        }
        myNodesReadListener.clear();
      }
      myCheckedNodesNonTypesystem.add(nodeAndRule);
    }
  }
}
