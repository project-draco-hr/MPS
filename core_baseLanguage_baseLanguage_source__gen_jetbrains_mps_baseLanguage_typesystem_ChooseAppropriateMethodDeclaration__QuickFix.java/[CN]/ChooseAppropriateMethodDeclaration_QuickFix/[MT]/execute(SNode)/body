{
  if (SNodeOperations.isInstanceOf(((SNode)this.getField("methodCall")[0]),"jetbrains.mps.baseLanguage.structure.ClassCreator") && SNodeOperations.isInstanceOf(((SNode)this.getField("classifier")[0]),"jetbrains.mps.baseLanguage.structure.ClassConcept")) {
    SNode constructorCall=SNodeOperations.cast(((SNode)this.getField("methodCall")[0]),"jetbrains.mps.baseLanguage.structure.ClassCreator");
    SNode classConcept=SNodeOperations.cast(((SNode)this.getField("classifier")[0]),"jetbrains.mps.baseLanguage.structure.ClassConcept");
    List<SNode> list=SLinkOperations.getTargets(classConcept,"constructor",true);
    for (    SNode constructorDeclaration : list) {
      if (SLinkOperations.getCount(constructorDeclaration,"parameter") == SLinkOperations.getCount(constructorCall,"actualArgument")) {
        boolean good=true;
        List<SNode> parameterTypes=ResolveUtil.parameterTypes(constructorDeclaration,SNodeOperations.cast(TypeChecker.getInstance().getTypeOf(constructorCall),"jetbrains.mps.baseLanguage.structure.ClassifierType"),((SNode)this.getField("classifier")[0]));
{
          SNode parameterType;
          SNode argument;
          Iterator<SNode> parameterType_iterator=ListSequence.fromList(parameterTypes).iterator();
          Iterator<SNode> argument_iterator=ListSequence.fromList(SLinkOperations.getTargets(constructorCall,"actualArgument",true)).iterator();
          while (true) {
            if (!(parameterType_iterator.hasNext())) {
              break;
            }
            if (!(argument_iterator.hasNext())) {
              break;
            }
            parameterType=parameterType_iterator.next();
            argument=argument_iterator.next();
            if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument),parameterType))) {
              good=false;
              break;
            }
          }
        }
        if (good) {
          SLinkOperations.setTarget(constructorCall,"baseMethodDeclaration",constructorDeclaration,false);
          return;
        }
      }
    }
  }
 else   if (SNodeOperations.isInstanceOf(((SNode)this.getField("methodCall")[0]),"jetbrains.mps.baseLanguage.structure.ConstructorInvocationStatement") && SNodeOperations.isInstanceOf(((SNode)this.getField("classifier")[0]),"jetbrains.mps.baseLanguage.structure.ClassConcept")) {
    SNode classConcept=SNodeOperations.cast(((SNode)this.getField("classifier")[0]),"jetbrains.mps.baseLanguage.structure.ClassConcept");
    SNode constructorCall=SNodeOperations.cast(((SNode)this.getField("methodCall")[0]),"jetbrains.mps.baseLanguage.structure.ConstructorInvocationStatement");
    List<SNode> list=SLinkOperations.getTargets(classConcept,"constructor",true);
    for (    SNode constructorDeclaration : list) {
      if (SLinkOperations.getCount(constructorDeclaration,"parameter") == SLinkOperations.getCount(constructorCall,"actualArgument")) {
        boolean good=true;
        List<SNode> parameterTypes=ListSequence.fromList(new ArrayList<SNode>());
        for (        SNode parameter : SLinkOperations.getTargets(constructorDeclaration,"parameter",true)) {
          ListSequence.fromList(parameterTypes).addElement(SNodeOperations.copyNode(SLinkOperations.getTarget(parameter,"type",true)));
        }
{
          SNode parameterType;
          SNode argument;
          Iterator<SNode> parameterType_iterator=ListSequence.fromList(parameterTypes).iterator();
          Iterator<SNode> argument_iterator=ListSequence.fromList(SLinkOperations.getTargets(constructorCall,"actualArgument",true)).iterator();
          while (true) {
            if (!(parameterType_iterator.hasNext())) {
              break;
            }
            if (!(argument_iterator.hasNext())) {
              break;
            }
            parameterType=parameterType_iterator.next();
            argument=argument_iterator.next();
            if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument),parameterType))) {
              good=false;
              break;
            }
          }
        }
        if (good) {
          SLinkOperations.setTarget(constructorCall,"baseMethodDeclaration",constructorDeclaration,false);
          return;
        }
      }
    }
  }
 else   if (SNodeOperations.isInstanceOf(((SNode)this.getField("methodCall")[0]),"jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration") && SNodeOperations.isInstanceOf(((SNode)this.getField("classifier")[0]),"jetbrains.mps.baseLanguage.structure.EnumClass")) {
    SNode constantDeclaration=SNodeOperations.cast(((SNode)this.getField("methodCall")[0]),"jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration");
    SNode enumClass=SNodeOperations.cast(((SNode)this.getField("classifier")[0]),"jetbrains.mps.baseLanguage.structure.EnumClass");
    List<SNode> list=SLinkOperations.getTargets(enumClass,"constructor",true);
    for (    SNode constructorDeclaration : list) {
      if (SLinkOperations.getCount(constructorDeclaration,"parameter") == SLinkOperations.getCount(constantDeclaration,"actualArgument")) {
        boolean good=true;
        List<SNode> parameterTypes=ResolveUtil.parameterTypes(constructorDeclaration,SNodeOperations.cast(TypeChecker.getInstance().getTypeOf(constantDeclaration),"jetbrains.mps.baseLanguage.structure.ClassifierType"),((SNode)this.getField("classifier")[0]));
{
          SNode parameterType;
          SNode argument;
          Iterator<SNode> parameterType_iterator=ListSequence.fromList(parameterTypes).iterator();
          Iterator<SNode> argument_iterator=ListSequence.fromList(SLinkOperations.getTargets(constantDeclaration,"actualArgument",true)).iterator();
          while (true) {
            if (!(parameterType_iterator.hasNext())) {
              break;
            }
            if (!(argument_iterator.hasNext())) {
              break;
            }
            parameterType=parameterType_iterator.next();
            argument=argument_iterator.next();
            if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument),parameterType))) {
              good=false;
              break;
            }
          }
        }
        if (good) {
          SLinkOperations.setTarget(constantDeclaration,"baseMethodDeclaration",constructorDeclaration,false);
          return;
        }
      }
    }
  }
 else   if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(((SNode)this.getField("methodCall")[0])),"jetbrains.mps.baseLanguage.structure.DotExpression")) {
    SNode operandType=TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(((SNode)this.getField("methodCall")[0])),"jetbrains.mps.baseLanguage.structure.DotExpression"),"operand",true));
    if (!(SNodeOperations.isInstanceOf(operandType,"jetbrains.mps.baseLanguage.structure.ClassifierType"))) {
      return;
    }
    SNode instanceType=SNodeOperations.cast(operandType,"jetbrains.mps.baseLanguage.structure.ClassifierType");
    ClassifierAndSuperClassifiersScope scope=new ClassifierAndSuperClassifiersScope(((Classifier)SNodeOperations.getAdapter(SLinkOperations.getTarget(instanceType,"classifier",false))));
    List<SNode> mDecls=((List<SNode>)BaseAdapter.toNodes(scope.getMethodsByName(SPropertyOperations.getString(SLinkOperations.getTarget(((SNode)this.getField("methodCall")[0]),"baseMethodDeclaration",false),"name"))));
    for (    SNode methodDecl : mDecls) {
      if (SLinkOperations.getCount(methodDecl,"parameter") == SLinkOperations.getCount(((SNode)this.getField("methodCall")[0]),"actualArgument")) {
        boolean good=true;
        List<SNode> parameterTypes=ResolveUtil.parameterTypes(methodDecl,instanceType,((SNode)this.getField("classifier")[0]));
{
          SNode parameterType;
          SNode argument;
          Iterator<SNode> parameterType_iterator=ListSequence.fromList(parameterTypes).iterator();
          Iterator<SNode> argument_iterator=ListSequence.fromList(SLinkOperations.getTargets(((SNode)this.getField("methodCall")[0]),"actualArgument",true)).iterator();
          while (true) {
            if (!(parameterType_iterator.hasNext())) {
              break;
            }
            if (!(argument_iterator.hasNext())) {
              break;
            }
            parameterType=parameterType_iterator.next();
            argument=argument_iterator.next();
            if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument),parameterType))) {
              good=false;
              break;
            }
          }
        }
        if (good) {
          SLinkOperations.setTarget(((SNode)this.getField("methodCall")[0]),"baseMethodDeclaration",methodDecl,false);
          return;
        }
      }
    }
  }
}
