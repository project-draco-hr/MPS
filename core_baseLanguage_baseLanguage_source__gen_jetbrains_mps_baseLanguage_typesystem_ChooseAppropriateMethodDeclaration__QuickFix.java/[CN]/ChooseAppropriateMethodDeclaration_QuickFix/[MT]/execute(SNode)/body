{
  if (SNodeOperations.isInstanceOf(((SNode)this.getField("methodCall")[0]),"jetbrains.mps.baseLanguage.structure.ClassCreator") && SNodeOperations.isInstanceOf(((SNode)this.getField("classifier")[0]),"jetbrains.mps.baseLanguage.structure.ClassConcept")) {
    SNode constructorCall=SNodeOperations.cast(((SNode)this.getField("methodCall")[0]),"jetbrains.mps.baseLanguage.structure.ClassCreator");
    SNode classConcept=SNodeOperations.cast(((SNode)this.getField("classifier")[0]),"jetbrains.mps.baseLanguage.structure.ClassConcept");
    List<SNode> list=SLinkOperations.getTargets(classConcept,"constructor",true);
    for (    SNode constructorDeclaration : list) {
      if (SLinkOperations.getCount(constructorDeclaration,"parameter") == SLinkOperations.getCount(constructorCall,"actualArgument")) {
        boolean good=true;
        List<SNode> parameterTypes=ResolveUtil.parameterTypes(SLinkOperations.getTarget(constructorCall,"baseMethodDeclaration",false),SNodeOperations.cast(TypeChecker.getInstance().getTypeOf(constructorCall),"jetbrains.mps.baseLanguage.structure.ClassifierType"),((SNode)this.getField("classifier")[0]));
{
          SNode parameter;
          SNode argument;
          Iterator<SNode> parameter_iterator=ListSequence.fromList(parameterTypes).iterator();
          Iterator<SNode> argument_iterator=ListSequence.fromList(SLinkOperations.getTargets(constructorCall,"actualArgument",true)).iterator();
          while (true) {
            if (!(parameter_iterator.hasNext())) {
              break;
            }
            if (!(argument_iterator.hasNext())) {
              break;
            }
            parameter=parameter_iterator.next();
            argument=argument_iterator.next();
            if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument),SLinkOperations.getTarget(parameter,"type",true)))) {
              good=false;
              break;
            }
          }
        }
        if (good) {
          SLinkOperations.setTarget(constructorCall,"baseMethodDeclaration",constructorDeclaration,false);
          return;
        }
      }
    }
  }
 else   if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(((SNode)this.getField("methodCall")[0])),"jetbrains.mps.baseLanguage.structure.DotExpression")) {
    SNode operandType=TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(((SNode)this.getField("methodCall")[0])),"jetbrains.mps.baseLanguage.structure.DotExpression"),"operand",true));
    if (!(SNodeOperations.isInstanceOf(operandType,"jetbrains.mps.baseLanguage.structure.ClassifierType"))) {
      return;
    }
    SNode instanceType=SNodeOperations.cast(operandType,"jetbrains.mps.baseLanguage.structure.ClassifierType");
    ClassifierAndSuperClassifiersScope scope=new ClassifierAndSuperClassifiersScope(((Classifier)SNodeOperations.getAdapter(SLinkOperations.getTarget(instanceType,"classifier",false))));
    List<SNode> mDecls=((List<SNode>)BaseAdapter.toNodes(scope.getMethodsByName(SPropertyOperations.getString(SLinkOperations.getTarget(((SNode)this.getField("methodCall")[0]),"baseMethodDeclaration",false),"name"))));
    for (    SNode methodDecl : mDecls) {
      if (SLinkOperations.getCount(methodDecl,"parameter") == SLinkOperations.getCount(((SNode)this.getField("methodCall")[0]),"actualArgument")) {
        boolean good=true;
        List<SNode> parameterTypes=ResolveUtil.parameterTypes(methodDecl,instanceType,((SNode)this.getField("classifier")[0]));
{
          SNode parameterType;
          SNode argument;
          Iterator<SNode> parameterType_iterator=ListSequence.fromList(parameterTypes).iterator();
          Iterator<SNode> argument_iterator=ListSequence.fromList(SLinkOperations.getTargets(((SNode)this.getField("methodCall")[0]),"actualArgument",true)).iterator();
          while (true) {
            if (!(parameterType_iterator.hasNext())) {
              break;
            }
            if (!(argument_iterator.hasNext())) {
              break;
            }
            parameterType=parameterType_iterator.next();
            argument=argument_iterator.next();
            if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument),parameterType))) {
              good=false;
              break;
            }
          }
        }
        if (good) {
          SLinkOperations.setTarget(((SNode)this.getField("methodCall")[0]),"baseMethodDeclaration",methodDecl,false);
          return;
        }
      }
    }
  }
}
