{
  List<SearchResult<ModelCheckerIssue>> results=ListSequence.fromList(new ArrayList<SearchResult<ModelCheckerIssue>>());
  monitor.start("wrong aspect dependencies",1);
  int modelKind=getModelKind(model,null);
  if (modelKind == OTHER) {
    monitor.done();
    return results;
  }
  for (  SNode node : ListSequence.fromList(SModelOperations.nodes(model,null))) {
    if (monitor.isCanceled()) {
      break;
    }
    for (    final SReference ref : ListSequence.fromList(SNodeOperations.getReferences(node))) {
      if ((AttributeOperations.getAttribute(node,new IAttributeDescriptor.LinkAttribute(MetaAdapterFactory.getConcept(0xb401a68083254110L,0x8fd384331ff25befL,0xfd7f44d616L,"jetbrains.mps.lang.generator.structure.ReferenceMacro"),ref.getLink())) != null)) {
        continue;
      }
      SNode targetNode=jetbrains.mps.util.SNodeOperations.getTargetNodeSilently(ref);
      if (targetNode == null) {
        SpecificChecker.addIssue(results,node,"Unresolved reference: " + SLinkOperations.getResolveInfo(ref),ModelChecker.SEVERITY_ERROR,"unresolved reference",new IModelCheckerFix(){
          public boolean doFix(){
            return ResolverComponent.getInstance().resolve(ref,myProject.getRepository());
          }
        }
);
        continue;
      }
      SModel targetModel=SNodeOperations.getModel(targetNode);
      int targetKind=getModelKind(targetModel,ref);
      if (targetKind > modelKind) {
        SpecificChecker.addIssue(results,node,"Wrong reference: " + SLinkOperations.getResolveInfo(ref) + ", reference from "+ kindToString(modelKind)+ " to "+ kindToString(targetKind),ModelChecker.SEVERITY_ERROR,"wrong aspect dependency (" + kindToString(modelKind) + ")",null);
      }
    }
  }
  monitor.done();
  return results;
}
