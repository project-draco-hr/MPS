{
  Map<AbstractConceptDeclaration,Vertex> concepts=new HashMap<AbstractConceptDeclaration,Vertex>();
  List<AbstractConceptDeclaration> allConcepts=myLanguage.getStructureModelDescriptor().getSModel().getRootsAdapters(AbstractConceptDeclaration.class);
  for (  AbstractConceptDeclaration abstractConcept : allConcepts) {
    Vertex vertex=new Vertex(0,0,abstractConcept.getName()){
      public int getWidth(){
        return getFontMetrics(myFont).stringWidth(getName()) + 2 * HORIZONTAL_PADDING;
      }
      public int getHeight(){
        return 20;
      }
    }
;
    vertex.putUserObject(CONCEPT,abstractConcept.getNode());
    myGraph.addVertex(vertex);
    concepts.put(abstractConcept,vertex);
  }
  for (  AbstractConceptDeclaration abstractConcept : allConcepts) {
    if (abstractConcept instanceof ConceptDeclaration) {
      ConceptDeclaration conceptDeclaration=(ConceptDeclaration)abstractConcept;
      ConceptDeclaration extendedConcept=conceptDeclaration.getExtends();
      Vertex vertex=concepts.get(extendedConcept);
      if (vertex != null) {
        myGraph.connect(concepts.get(conceptDeclaration),vertex,LINK_KIND,LinkKind.INHERITANCE);
      }
    }
    for (    LinkDeclaration linkDeclaration : abstractConcept.getLinkDeclarations()) {
      AbstractConceptDeclaration targetConcept=linkDeclaration.getTarget();
      LinkKind linkKind;
      LinkMetaclass metaClass=linkDeclaration.getMetaClass();
      if (metaClass == LinkMetaclass.aggregation) {
        linkKind=LinkKind.CHILD;
      }
 else {
        linkKind=LinkKind.REFERENT;
      }
      Vertex vertex=concepts.get(targetConcept);
      if (vertex != null) {
        myGraph.connect(concepts.get(abstractConcept),vertex,LINK_KIND,linkKind);
      }
    }
  }
  Set<IVertex> residualVertices=new HashSet<IVertex>(myGraph.getVertices());
  while (!residualVertices.isEmpty()) {
    Graph currentGraph=new Graph();
    myGraphComponents.add(currentGraph);
    IVertex newVertex=residualVertices.iterator().next();
    Set<IVertex> frontier=new HashSet<IVertex>();
    Set<IVertex> processedVertices=new HashSet<IVertex>();
    frontier.add(newVertex);
    Set<IVertex> newFrontier=new HashSet<IVertex>();
    while (!frontier.isEmpty()) {
      for (      IVertex v : frontier) {
        residualVertices.remove(v);
        currentGraph.addVertex(v);
        for (        IEdge e : v.getStar()) {
          IVertex another=e.getFirst() == v ? e.getSecond() : e.getFirst();
          if (!processedVertices.contains(another)) {
            currentGraph.addVertex(another);
            newFrontier.add(another);
          }
          currentGraph.connect(e.getFirst(),e.getSecond(),LINK_KIND,e.getUserObject(LINK_KIND));
        }
        processedVertices.add(v);
      }
      frontier=newFrontier;
      newFrontier=new HashSet<IVertex>();
    }
  }
  System.err.println("components built");
}
