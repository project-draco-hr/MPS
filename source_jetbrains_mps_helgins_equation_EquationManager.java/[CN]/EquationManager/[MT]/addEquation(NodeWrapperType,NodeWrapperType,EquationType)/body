{
  NodeWrapperType rhsRepresentator=rhs.getRepresentator();
  NodeWrapperType lhsRepresentator=lhs.getRepresentator();
  if (rhsRepresentator == lhsRepresentator)   return;
  RuntimeTypeVariable varRhs=NodeWrapperType.getTypeVar(rhsRepresentator);
  RuntimeTypeVariable varLhs=NodeWrapperType.getTypeVar(lhsRepresentator);
  if (varRhs != null) {
    processEquation(rhsRepresentator,lhsRepresentator);
    return;
  }
 else {
    if (varLhs != null) {
      processEquation(lhsRepresentator,rhsRepresentator);
      return;
    }
  }
switch (eqType) {
case GREATER:
{
      if (SubtypingManager.getInstance().isStrictSubtype(lhsRepresentator,rhsRepresentator)) {
        processSubtyping(lhsRepresentator,rhsRepresentator);
        return;
      }
      break;
    }
case LESS:
{
    if (SubtypingManager.getInstance().isStrictSubtype(rhsRepresentator,lhsRepresentator)) {
      processSubtyping(rhsRepresentator,lhsRepresentator);
      return;
    }
    break;
  }
case NORMAL:
{
  if (SubtypingManager.getInstance().isStrictSubtype(rhsRepresentator,lhsRepresentator)) {
    processSubtyping(rhsRepresentator,lhsRepresentator);
    return;
  }
 else   if (SubtypingManager.getInstance().isStrictSubtype(lhsRepresentator,rhsRepresentator)) {
    processSubtyping(lhsRepresentator,rhsRepresentator);
    return;
  }
}
}
if (!compareNodes(rhsRepresentator.getNodeWrapper(),lhsRepresentator.getNodeWrapper())) {
String error="incompatible types: " + rhsRepresentator + " and "+ lhsRepresentator;
processErrorEquation(lhsRepresentator,rhsRepresentator,error);
return;
}
Set<Pair<NodeWrapperType,NodeWrapperType>> childEQs=createChildEquations(rhsRepresentator.getNodeWrapper(),lhsRepresentator.getNodeWrapper());
for (Pair<NodeWrapperType,NodeWrapperType> eq : childEQs) {
addEquation(eq.o2,eq.o1);
}
}
