{
  final List<Message> errors=new ArrayList<Message>();
  final IMessageHandler handler=new IMessageHandler(){
    public void handle(    Message msg){
      if (msg.getKind() == MessageKind.ERROR) {
        errors.add(msg);
      }
      final String message=msg.getText();
switch (msg.getKind()) {
case ERROR:
        LOG.error(message);
      break;
case INFORMATION:
    LOG.info(message);
  break;
case WARNING:
if (treatWarningsAsErrors && message.startsWith("expression can't be optimized for DB access and will be executed by collection language in-memory")) {
  LOG.error(message);
  errors.add(msg);
}
 else {
  LOG.warning(message);
}
break;
}
}
}
;
CommandProcessor.instance().executeCommand(new Runnable(){
public void run(){
for (BaseGeneratorConfiguration t : myProjectDescriptor.getRunConfigurations()) {
if (!t.getTest()) continue;
GenParameters parms;
try {
parms=GeneratorConfigUtil.calculate(MPSProject.this,t);
}
 catch (GeneratorConfigUtil.GeneratorConfigurationException e) {
errors.add(new Message(MessageKind.ERROR,"Can't create a generator configuration : " + e.getMessage()));
return;
}
getComponentSafe(GeneratorManager.class).generateModels(parms.getModels(),parms.getTarget(),new ModuleContext(parms.getModule(),MPSProject.this),new GenerateClassesGenerationType(false){
public boolean requiresCompilationInIDEABeforeGeneration(){
return false;
}
public boolean requiresCompilationInIDEAfterGeneration(){
return false;
}
protected boolean isPutClassesOnTheDisk(){
return false;
}
}
,parms.getScript(),IAdaptiveProgressMonitor.NULL_PROGRESS_MONITOR,handler);
System.out.println("");
System.out.println("");
System.out.println("");
}
}
}
);
return errors.size() == 0;
}
