{
  Stack<BlockInfo> stack=new Stack<BlockInfo>();
  for (  Instruction i : myInstructions) {
    if (i instanceof TryInstruction) {
      Program.TryFinallyInfo info=new TryFinallyInfo();
      info.myTry=(TryInstruction)i;
      myBlockInfo.add(info);
      if (!stack.isEmpty()) {
        info.myParent=stack.peek();
      }
      stack.push(info);
    }
    if (i instanceof FinallyInstruction) {
      if (stack.isEmpty() || !(stack.peek() instanceof TryFinallyInfo) || ((TryFinallyInfo)stack.peek()).myFinally != null) {
        throw new IllegalStateException("unexpected finally");
      }
      ((TryFinallyInfo)stack.peek()).myFinally=(FinallyInstruction)i;
    }
    if (i instanceof EndTryInstruction) {
      if (stack.isEmpty() || !(stack.peek() instanceof TryFinallyInfo) || ((TryFinallyInfo)stack.peek()).myEndTry != null) {
        throw new IllegalStateException("unexpected endtry");
      }
      ((TryFinallyInfo)stack.peek()).myEndTry=(EndTryInstruction)i;
      stack.pop();
    }
    if (i instanceof ClosureInstruction) {
      ClosureInfo info=new ClosureInfo();
      info.myClosure=(ClosureInstruction)i;
      myBlockInfo.add(info);
      if (!stack.isEmpty()) {
        info.myParent=stack.peek();
      }
      stack.push(info);
    }
    if (i instanceof EndClosureInstruction) {
      if (stack.isEmpty() || !(stack.peek() instanceof ClosureInfo)) {
        throw new RuntimeException("unexpected endClosure");
      }
      ((ClosureInfo)stack.peek()).myEndClosure=(EndClosureInstruction)i;
      stack.pop();
    }
  }
  if (!stack.isEmpty()) {
    throw new IllegalStateException("incomplete try blocks");
  }
}
