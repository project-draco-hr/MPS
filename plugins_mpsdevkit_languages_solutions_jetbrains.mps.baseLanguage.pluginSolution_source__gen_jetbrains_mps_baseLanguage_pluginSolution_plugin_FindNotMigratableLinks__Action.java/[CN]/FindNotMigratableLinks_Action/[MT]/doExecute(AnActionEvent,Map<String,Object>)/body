{
  try {
    final List<SNodeReference> usages=ListSequence.fromList(new ArrayList<SNodeReference>());
    ((MPSProject)MapSequence.fromMap(_params).get("project")).getRepository().getModelAccess().runReadAction(new Runnable(){
      public void run(){
        for (        SNode link : Arrays.asList(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.Classifier","method"),SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.Classifier","staticField"),SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.Classifier","staticInnerClassifiers"),SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassConcept","constructor"),SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassConcept","staticMethod"),SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassConcept","field"),SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassConcept","property"))) {
          for (          SNode node : Sequence.fromIterable(NonMigratableUsagesFinder.findNonMigratableUsages(link))) {
            ListSequence.fromList(usages).addElement(new SNodePointer(node));
          }
        }
      }
    }
);
    InternalActionsUtils.showUsagesViewForNodes(((Project)MapSequence.fromMap(_params).get("ideaProject")),usages);
  }
 catch (  Throwable t) {
    if (LOG.isEnabledFor(Priority.ERROR)) {
      LOG.error("User's action execute method failed. Action:" + "FindNotMigratableLinks",t);
    }
  }
}
