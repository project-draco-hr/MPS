{
  try {
    final List<SNodePointer> usages=ListSequence.fromList(new ArrayList<SNodePointer>());
    ModelAccess.instance().runReadAction(new Runnable(){
      public void run(){
        for (        SNode link : Arrays.asList(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.Classifier","method"),SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.Classifier","staticField"),SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.Classifier","staticInnerClassifiers"),SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassConcept","constructor"),SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassConcept","staticMethod"),SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassConcept","field"),SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassConcept","property"))) {
          SearchResults<SNode> results=FindUtils.getSearchResults(new EmptyProgressMonitor(),link,GlobalScope.getInstance(),"jetbrains.mps.lang.script.findUsages.Potentially_not_migratable_usages_Finder");
          System.out.println(results.getSearchResults().size());
          for (          SNode node : SetSequence.fromSet(results.getResultObjects())) {
            ListSequence.fromList(usages).addElement(new SNodePointer(node));
          }
        }
      }
    }
);
    InternalActionsUtils.showUsagesViewForNodes(((Project)MapSequence.fromMap(_params).get("project")),usages);
  }
 catch (  Throwable t) {
    if (log.isErrorEnabled()) {
      log.error("User's action execute method failed. Action:" + "FindNotMigratableLinks",t);
    }
  }
}
