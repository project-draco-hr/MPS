{
  List<SearchResult<ModelCheckerIssue>> results=ListSequence.fromList(new ArrayList<SearchResult<ModelCheckerIssue>>());
  for (  SNode rootNode : ListSequence.fromList(SModelOperations.getRoots(model,null))) {
    if (!(progressContext.checkAndUpdateIndicator("Checking " + SModelOperations.getModelName(model) + " for typesystem rules..."))) {
      break;
    }
    TypeCheckingContext typeCheckingContext=TypeContextManager.getInstance().getOrCreateContext(rootNode,this,true);
    typeCheckingContext.setOperationContext(operationContext);
    Set<Pair<SNode,List<IErrorReporter>>> nodeWithErrors=typeCheckingContext.checkRootAndGetErrors(true);
    for (    Pair<SNode,List<IErrorReporter>> nodeErrorReporters : SetSequence.fromSet(nodeWithErrors)) {
      final SNode node=nodeErrorReporters.o1;
      for (      IErrorReporter errorReporter : ListSequence.fromList(nodeErrorReporters.o2)) {
        final IErrorReporter reporter=errorReporter;
        final QuickFix_Runtime quickFix=check_5gkhbq_a0b0b0e0c0a(check_5gkhbq_a0a1a1a4a2a0(reporter));
        IModelCheckerFix fix=null;
        if (quickFix != null) {
          fix=new IModelCheckerFix(){
            public boolean doFix(){
              quickFix.execute(node);
              return true;
            }
          }
;
        }
        addIssue(results,node,errorReporter.reportError(),SpecificChecker.getResultCategory(errorReporter.getMessageStatus()),"type system",fix);
      }
    }
    TypeContextManager.getInstance().removeOwnerForRootNodeContext(rootNode,this);
  }
  return results;
}
