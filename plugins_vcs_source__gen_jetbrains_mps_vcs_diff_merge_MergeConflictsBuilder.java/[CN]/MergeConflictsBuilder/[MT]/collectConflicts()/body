{
  Map<Tuples._2<SNodeId,String>,List<NodeGroupChange>> mineGroupChanges=arrangeNodeGroupChanges(myMineChangeSet);
  Map<Tuples._2<SNodeId,String>,List<NodeGroupChange>> repositoryGroupChanges=arrangeNodeGroupChanges(myRepositoryChangeSet);
  for (  Tuples._2<SNodeId,String> nodeRole : SetSequence.<Tuples._2<SNodeId,String>>fromSet(MapSequence.fromMap(mineGroupChanges).keySet()).intersect(SetSequence.<Tuples._2<SNodeId,String>>fromSet(MapSequence.fromMap(repositoryGroupChanges).keySet()))) {
    List<NodeGroupChange> mine=MapSequence.<Tuples._2<SNodeId,String>,List<NodeGroupChange>>fromMap(mineGroupChanges).get(nodeRole);
    List<NodeGroupChange> repository=MapSequence.<Tuples._2<SNodeId,String>,List<NodeGroupChange>>fromMap(repositoryGroupChanges).get(nodeRole);
    for (    NodeGroupChange m : ListSequence.<NodeGroupChange>fromList(mine)) {
      for (      NodeGroupChange r : ListSequence.<NodeGroupChange>fromList(repository)) {
        if (m.getEnd() < r.getBegin() || m.getBegin() > r.getEnd()) {
        }
 else {
          if (nodeGroupChangesSymmetric(m,r)) {
            addSymmetric(m,r);
          }
 else {
            addConflict(m,r);
          }
        }
      }
    }
  }
  collectGroupChangesWithOthersConflicts(mineGroupChanges,myMineChangeSet,myRepositoryChangeSet);
  collectGroupChangesWithOthersConflicts(repositoryGroupChanges,myRepositoryChangeSet,myMineChangeSet);
  collectPropertyConflicts();
  collectReferenceConflicts();
  collectSymmetricRootDeletes();
  collectConflictingRootAdds();
  collectSymmetricImportedModelChanges();
  collectSymmetricModuleDependencyChanges();
}
