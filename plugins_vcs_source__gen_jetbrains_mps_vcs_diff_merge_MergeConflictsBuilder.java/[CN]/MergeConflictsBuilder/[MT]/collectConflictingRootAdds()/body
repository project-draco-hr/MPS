{
  Tuples._2<Map<SNodeId,AddRootChange>,Map<SNodeId,AddRootChange>> arranged;
  arranged=this.<SNodeId,AddRootChange>arrangeChanges(new _FunctionTypes._return_P1_E0<SNodeId,AddRootChange>(){
    public SNodeId invoke(    AddRootChange drc){
      return drc.getRootId();
    }
  }
,AddRootChange.class);
  for (  SNodeId addedRoot : SetSequence.<SNodeId>fromSet(MapSequence.fromMap(arranged._0()).keySet()).intersect(SetSequence.<SNodeId>fromSet(MapSequence.fromMap(arranged._1()).keySet()))) {
    AddRootChange mine=MapSequence.<SNodeId,AddRootChange>fromMap(arranged._0()).get(addedRoot);
    AddRootChange repository=MapSequence.<SNodeId,AddRootChange>fromMap(arranged._1()).get(addedRoot);
    if (SNodeCompare.nodeEquals(myMyModel.getNodeById(mine.getRootId()),myRepositoryModel.getNodeById(repository.getRootId()))) {
      addSymmetric(mine,repository);
    }
 else {
      addConflict(mine,repository);
    }
  }
}
