{
  long nextReadRun=0;
  long nextWriteRun=0;
  long nextCommandRun=0;
  try {
    while (true) {
      try {
        boolean scheduleRead, scheduleWrite, scheduleCommand;
synchronized (myLock) {
          if (myToExecuteRead.isEmpty() && myToExecuteCommand.isEmpty() && myToExecuteWrite.isEmpty()) {
            myLock.wait(100);
          }
          scheduleRead=!hasReadWorker && !myToExecuteRead.isEmpty();
          scheduleWrite=!hasWriteWorker && !myToExecuteWrite.isEmpty();
          scheduleCommand=!hasCommandWorker && !myToExecuteCommand.isEmpty();
        }
        if (scheduleRead && nextReadRun < System.currentTimeMillis()) {
          LaterInvocator.invokeLater(new ReadRunnable(),ModalityState.NON_MODAL);
          nextReadRun=System.currentTimeMillis() + INTERVAL;
        }
        if (scheduleWrite && nextWriteRun < System.currentTimeMillis()) {
          LaterInvocator.invokeLater(new WriteRunnable(),ModalityState.NON_MODAL);
          nextWriteRun=System.currentTimeMillis() + INTERVAL;
        }
        if (scheduleCommand && nextCommandRun < System.currentTimeMillis()) {
          LaterInvocator.invokeLater(new CommandRunnable(),ModalityState.NON_MODAL);
          nextCommandRun=System.currentTimeMillis() + INTERVAL;
        }
      }
 catch (      InterruptedException e) {
      }
    }
  }
 catch (  Exception e) {
    LOG.error(e);
  }
}
