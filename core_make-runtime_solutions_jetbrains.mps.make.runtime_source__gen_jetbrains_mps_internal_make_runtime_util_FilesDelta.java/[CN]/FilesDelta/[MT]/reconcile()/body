{
  String[] pathsToKeep=MapSequence.fromMap(files).where(new IWhereFilter<IMapping<IFile,FilesDelta.Status>>(){
    public boolean accept(    IMapping<IFile,FilesDelta.Status> f){
      return f.value() != FilesDelta.Status.DELETED;
    }
  }
).<String>select(new ISelector<IMapping<IFile,FilesDelta.Status>,String>(){
    public String select(    IMapping<IFile,FilesDelta.Status> f){
      return straighten(urlToPath(f.key().getPath()));
    }
  }
).sort(new ISelector<String,Comparable<?>>(){
    public Comparable<?> select(    String p){
      return p;
    }
  }
,true).toListSequence().toGenericArray(String.class);
  List<IFile> toDelete=ListSequence.fromList(new ArrayList<IFile>());
  Queue<IFile> dirs=QueueSequence.fromQueueAndArray(new LinkedList<IFile>(),rootDir);
  while (QueueSequence.fromQueue(dirs).isNotEmpty()) {
    IFile dir=QueueSequence.fromQueue(dirs).removeFirstElement();
    String dirpath=straighten(urlToPath(dir.getPath()));
    int diridx=Arrays.binarySearch(pathsToKeep,dirpath);
    diridx=(diridx < 0 ? -1 - diridx : diridx);
    for (    Tuples._2<IFile,String> fp : Sequence.fromIterable(((Iterable<IFile>)dir.getChildren())).<Tuples._2<IFile,String>>select(new ISelector<IFile,Tuples._2<IFile,String>>(){
      public Tuples._2<IFile,String> select(      IFile f){
        return MultiTuple.<IFile,String>from(f,straighten(urlToPath(f.getPath())));
      }
    }
).sort(new ISelector<Tuples._2<IFile,String>,Comparable<?>>(){
      public Comparable<?> select(      Tuples._2<IFile,String> t){
        return t._1();
      }
    }
,true)) {
      int fidx=Arrays.binarySearch(pathsToKeep,fp._1());
      if (fp._0().isDirectory()) {
        fidx=(fidx < 0 ? -1 - fidx : fidx);
        if (fidx >= pathsToKeep.length || !(startsWith(pathsToKeep[fidx],fp._1()))) {
          ListSequence.fromList(toDelete).addElement(fp._0());
          if (fidx >= pathsToKeep.length) {
            break;
          }
        }
 else         if (fidx < pathsToKeep.length) {
          QueueSequence.fromQueue(dirs).addLastElement(fp._0());
        }
      }
 else       if (fidx < 0 && (diridx >= pathsToKeep.length || !(same(dirpath,pathsToKeep[diridx])))) {
        ListSequence.fromList(toDelete).addElement(fp._0());
      }
    }
  }
  boolean res=true;
  for (  IFile td : toDelete) {
    LOG.debug("Reconciled: deleting " + td);
    res&=td.delete();
  }
  return res;
}
