{
  String[] pathsToKeep=MapSequence.fromMap(files).where(new IWhereFilter<IMapping<IFile,FilesDelta.Status>>(){
    public boolean accept(    IMapping<IFile,FilesDelta.Status> f){
      return f.value() != FilesDelta.Status.DELETED;
    }
  }
).select(new ISelector<IMapping<IFile,FilesDelta.Status>,String>(){
    public String select(    IMapping<IFile,FilesDelta.Status> f){
      String path=straighten(urlToPath(f.key().getAbsolutePath()));
      return (f.key().isDirectory() ? asDir(path) : path);
    }
  }
).sort(new ISelector<String,Comparable<?>>(){
    public Comparable<?> select(    String p){
      return p;
    }
  }
,true).toListSequence().toGenericArray(String.class);
  List<IFile> toDelete=ListSequence.fromList(new ArrayList<IFile>());
  Queue<IFile> dirs=QueueSequence.fromQueueAndArray(new LinkedList<IFile>(),rootDir);
  while (QueueSequence.fromQueue(dirs).isNotEmpty()) {
    IFile dir=QueueSequence.fromQueue(dirs).removeFirstElement();
    String dirpath=asDir(straighten(urlToPath(dir.getAbsolutePath())));
    int diridx=Arrays.binarySearch(pathsToKeep,dirpath);
    diridx=(diridx < 0 ? -1 - diridx : diridx);
    for (    Tuples._2<IFile,String> fp : Sequence.fromIterable(((Iterable<IFile>)dir.getChildren())).select(new ISelector<IFile,Tuples._2<IFile,String>>(){
      public Tuples._2<IFile,String> select(      IFile f){
        return MultiTuple.<IFile,String>from(f,straighten(urlToPath(f.getAbsolutePath())));
      }
    }
).sort(new ISelector<Tuples._2<IFile,String>,Comparable<?>>(){
      public Comparable<?> select(      Tuples._2<IFile,String> t){
        return t._1();
      }
    }
,true)) {
      if (fp._0().isDirectory()) {
        int fidx=Arrays.binarySearch(pathsToKeep,asDir(fp._1()));
        fidx=(fidx < 0 ? -1 - fidx : fidx);
        if (fidx >= pathsToKeep.length || !(startsWith(pathsToKeep[fidx],fp._1()))) {
          ListSequence.fromList(toDelete).addElement(fp._0());
          if (fidx >= pathsToKeep.length) {
            break;
          }
        }
 else         if (fidx < pathsToKeep.length) {
          QueueSequence.fromQueue(dirs).addLastElement(fp._0());
        }
      }
 else {
        int fidx=Arrays.binarySearch(pathsToKeep,fp._1());
        if (fidx < 0 && (diridx >= pathsToKeep.length || !(same(dirpath,pathsToKeep[diridx])))) {
          ListSequence.fromList(toDelete).addElement(fp._0());
        }
      }
    }
  }
  return toDelete;
}
