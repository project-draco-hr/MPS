{
  String[] pathsToKeep=MapSequence.fromMap(files).where(new IWhereFilter<IMapping<IFile,FilesDelta.Status>>(){
    public boolean accept(    IMapping<IFile,FilesDelta.Status> f){
      return f.value() != FilesDelta.Status.DELETED;
    }
  }
).select(new ISelector<IMapping<IFile,FilesDelta.Status>,String>(){
    public String select(    IMapping<IFile,FilesDelta.Status> f){
      return (f.key().isDirectory() ? DirUtil.normalizeAsDir(f.key().getPath()) : DirUtil.normalize(f.key().getPath()));
    }
  }
).sort(new ISelector<String,Comparable<?>>(){
    public Comparable<?> select(    String p){
      return p;
    }
  }
,true).toListSequence().toGenericArray(String.class);
  List<IFile> filesToDelete=ListSequence.fromList(new ArrayList<IFile>());
  Queue<IFile> dirQueue=QueueSequence.fromQueueAndArray(new LinkedList<IFile>(),rootDir);
  while (QueueSequence.fromQueue(dirQueue).isNotEmpty()) {
    IFile dir=QueueSequence.fromQueue(dirQueue).removeFirstElement();
    String dirpath=DirUtil.normalizeAsDir(dir.getPath());
    int diridx=Arrays.binarySearch(pathsToKeep,dirpath);
    for (    Tuples._2<IFile,String> fileAndPath : Sequence.fromIterable(getChildren(dir)).select(new ISelector<IFile,Tuples._2<IFile,String>>(){
      public Tuples._2<IFile,String> select(      IFile f){
        return MultiTuple.<IFile,String>from(f,DirUtil.normalize(f.getPath()));
      }
    }
).sort(new ISelector<Tuples._2<IFile,String>,Comparable<?>>(){
      public Comparable<?> select(      Tuples._2<IFile,String> t){
        return t._1();
      }
    }
,true)) {
      if (fileAndPath._0().isDirectory()) {
        int fidx=Arrays.binarySearch(pathsToKeep,DirUtil.normalizeAsDir(fileAndPath._1()));
        fidx=(fidx < 0 ? -1 - fidx : fidx);
        if (fidx >= pathsToKeep.length || !(DirUtil.startsWith(pathsToKeep[fidx],fileAndPath._1()))) {
          ListSequence.fromList(filesToDelete).addElement(fileAndPath._0());
          if (fidx >= pathsToKeep.length) {
            break;
          }
        }
 else         if (fidx < pathsToKeep.length) {
          QueueSequence.fromQueue(dirQueue).addLastElement(fileAndPath._0());
        }
      }
 else {
        int fidx=Arrays.binarySearch(pathsToKeep,fileAndPath._1());
        if (fidx < 0 && diridx < 0) {
          ListSequence.fromList(filesToDelete).addElement(fileAndPath._0());
        }
      }
    }
  }
  return filesToDelete;
}
