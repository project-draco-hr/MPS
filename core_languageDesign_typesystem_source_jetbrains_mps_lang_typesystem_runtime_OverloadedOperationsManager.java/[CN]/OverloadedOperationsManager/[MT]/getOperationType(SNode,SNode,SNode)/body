{
  Set<OverloadedOperationsTypesProvider> operationsTypesProviderSet=myOperationsToTypeProviders.getRules(operation);
  if (operationsTypesProviderSet.isEmpty()) {
    return null;
  }
  SubtypingManager subtypingManager=myTypeChecker.getSubtypingManager();
  List<OverloadedOperationsTypesProvider> filteredProviders=new ArrayList<OverloadedOperationsTypesProvider>();
  for (  OverloadedOperationsTypesProvider provider : operationsTypesProviderSet) {
    if (provider.isApplicable(subtypingManager,leftOperandType,rightOperandType)) {
      filteredProviders.add(provider);
    }
  }
  final boolean[] severalRules=new boolean[]{false};
  Collections.sort(filteredProviders,new Comparator<OverloadedOperationsTypesProvider>(){
    public int compare(    OverloadedOperationsTypesProvider o1,    OverloadedOperationsTypesProvider o2){
      int i1=(o1.myLeftTypeIsExact ? 1 : 0) + (o1.myRightTypeIsExact ? 1 : 0);
      int i2=(o2.myLeftTypeIsExact ? 1 : 0) + (o2.myRightTypeIsExact ? 1 : 0);
      int i=i2 - i1;
      if (i == 0) {
        severalRules[0]=true;
      }
      return i;
    }
  }
);
  if (severalRules[0]) {
    LOG.warning("several overloaded rules found for operation",operation);
  }
  for (  OverloadedOperationsTypesProvider provider : filteredProviders) {
    SNode result=provider.getOperationType(operation,leftOperandType,rightOperandType);
    if (result != null) {
      return result;
    }
  }
  return null;
}
