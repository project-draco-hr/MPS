{
  Map<SNode,Map<SNode,EquationInfo>> map=sub ? mySubToSuper : mySuperToSub;
  SubTyping subTyping=new SubTyping(myState);
  boolean stateChanged=false;
  for (  SNode node : new HashSet<SNode>(map.keySet())) {
    Set<SNode> concreteTypes=getConcrete(map.get(node).keySet(),shallow);
    if (concreteTypes == null || concreteTypes.isEmpty()) {
      continue;
    }
    if (TypesUtil.isVariable(node)) {
      SNode type=sub ? subTyping.createMeet(concreteTypes) : subTyping.createLCS(concreteTypes);
      myState.addEquation(node,type,null);
    }
 else     if (myState.isConcrete(node,shallow)) {
      for (      SNode concreteType : concreteTypes) {
        EquationInfo info=map.get(node).get(concreteType);
        if (sub) {
          myState.addInequality(node,concreteType,isWeak,checkOnly,info);
          remove(node,concreteType);
        }
 else {
          myState.addInequality(concreteType,node,isWeak,checkOnly,info);
          remove(concreteType,node);
        }
      }
    }
    stateChanged=true;
  }
  return stateChanged;
}
