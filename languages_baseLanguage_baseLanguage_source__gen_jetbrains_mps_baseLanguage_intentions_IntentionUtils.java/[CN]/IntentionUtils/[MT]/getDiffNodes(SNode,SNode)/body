{
  if (neq_k79hya_a0a0g(SNodeOperations.getConceptDeclaration(node1),SNodeOperations.getConceptDeclaration(node2))) {
    return MultiTuple.<SNode,SNode>from(node1,node2);
  }
  SNode concept=SNodeOperations.getConceptDeclaration(node1);
  Set<String> propertyNames=SetSequence.fromSet(new HashSet<String>());
  collectPropertyNames(propertyNames,node1);
  collectPropertyNames(propertyNames,node2);
  for (  String property : SetSequence.fromSet(propertyNames)) {
    if (neq_k79hya_a0a0h0g(node1.getProperty(property),node2.getProperty(property))) {
      return MultiTuple.<SNode,SNode>from(node1,node2);
    }
  }
  Set<String> refNames=SetSequence.fromSet(new HashSet<String>());
  collectReferenceNames(refNames,node1);
  collectReferenceNames(refNames,node2);
  for (  String refLink : SetSequence.fromSet(refNames)) {
    if (node1.getReferenceTarget(refLink) != node2.getReferenceTarget(refLink)) {
      return MultiTuple.<SNode,SNode>from(node1,node2);
    }
  }
  Tuples._2<SNode,SNode> currentResult=null;
  Set<String> childNames=SetSequence.fromSet(new HashSet<String>());
  collectChildNames(childNames,node1);
  collectChildNames(childNames,node2);
  for (  String childLink : SetSequence.fromSet(childNames)) {
    List<SNode> children1=IterableUtil.asList(node1.getChildren(childLink));
    List<SNode> children2=IterableUtil.asList(node2.getChildren(childLink));
    if (children1.size() != children2.size()) {
      return MultiTuple.<SNode,SNode>from(node1,node2);
    }
{
      Iterator<SNode> child1_it=ListSequence.fromList(children1).iterator();
      Iterator<SNode> child2_it=ListSequence.fromList(children2).iterator();
      SNode child1_var;
      SNode child2_var;
      while (child1_it.hasNext() && child2_it.hasNext()) {
        child1_var=child1_it.next();
        child2_var=child2_it.next();
        Tuples._2<SNode,SNode> currentChildDiff=getDiffNodes(child1_var,child2_var);
        if (currentChildDiff != null) {
          if (currentResult == null) {
            currentResult=currentChildDiff;
          }
 else {
            return MultiTuple.<SNode,SNode>from(node1,node2);
          }
        }
      }
    }
  }
  return currentResult;
}
