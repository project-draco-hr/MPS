{
  if (neq_k79hya_a0a0g(SNodeOperations.getConceptDeclaration(node1),SNodeOperations.getConceptDeclaration(node2))) {
    return MultiTuple.<SNode,SNode>from(node1,node2);
  }
  SNode concept=SNodeOperations.getConceptDeclaration(node1);
  for (  SNode _property : ListSequence.fromList(new ConceptAndSuperConceptsScope(concept).getPropertyDeclarations())) {
    SNode property=((SNode)_property);
    if (neq_k79hya_a0b0e0g(node1.getProperty(SPropertyOperations.getString(property,"name")),node2.getProperty(SPropertyOperations.getString(property,"name")))) {
      return MultiTuple.<SNode,SNode>from(node1,node2);
    }
  }
  for (  SNode _link : ListSequence.fromList(new ConceptAndSuperConceptsScope(concept).getLinkDeclarationsExcludingOverridden())) {
    SNode linkDeclaration=(SNode)_link;
    if (SPropertyOperations.hasValue(linkDeclaration,"metaClass","reference","reference")) {
      if (SLinkOperations.getTargetNode(SNodeOperations.getReference(node1,linkDeclaration)) != SLinkOperations.getTargetNode(SNodeOperations.getReference(node2,linkDeclaration))) {
        return MultiTuple.<SNode,SNode>from(node1,node2);
      }
    }
  }
  Tuples._2<SNode,SNode> currentResult=null;
  for (  SNode _link : ListSequence.fromList(new ConceptAndSuperConceptsScope(concept).getLinkDeclarationsExcludingOverridden())) {
    SNode linkDeclaration=(SNode)_link;
    if (SPropertyOperations.hasValue(linkDeclaration,"metaClass","aggregation","reference")) {
      List<SNode> children1=SNodeOperations.getChildren(node1,linkDeclaration);
      List<SNode> children2=SNodeOperations.getChildren(node2,linkDeclaration);
      if (ListSequence.fromList(children1).count() != ListSequence.fromList(children2).count()) {
        return MultiTuple.<SNode,SNode>from(node1,node2);
      }
{
        Iterator<SNode> child1_it=ListSequence.fromList(children1).iterator();
        Iterator<SNode> child2_it=ListSequence.fromList(children2).iterator();
        SNode child1_var;
        SNode child2_var;
        while (child1_it.hasNext() && child2_it.hasNext()) {
          child1_var=child1_it.next();
          child2_var=child2_it.next();
          Tuples._2<SNode,SNode> currentChildDiff=getDiffNodes(child1_var,child2_var);
          if (currentChildDiff != null) {
            if (currentResult == null) {
              currentResult=currentChildDiff;
            }
 else {
              return MultiTuple.<SNode,SNode>from(node1,node2);
            }
          }
        }
      }
    }
  }
  return currentResult;
}
