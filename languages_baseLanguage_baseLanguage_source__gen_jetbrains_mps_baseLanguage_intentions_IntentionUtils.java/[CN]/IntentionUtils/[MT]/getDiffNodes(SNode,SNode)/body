{
  if (neq_k79hya_a0a0g(SNodeOperations.getConceptDeclaration(node1),SNodeOperations.getConceptDeclaration(node2))) {
    return MultiTuple.<SNode,SNode>from(node1,node2);
  }
  SNode concept=SNodeOperations.getConceptDeclaration(node1);
  for (  SNode _property : ListSequence.fromList(new ConceptAndSuperConceptsScope(concept).getPropertyDeclarations())) {
    SNode property=((SNode)_property);
    if (neq_k79hya_a0b0e0g(node1.getProperty(SPropertyOperations.getString(property,"name")),node2.getProperty(SPropertyOperations.getString(property,"name")))) {
      return MultiTuple.<SNode,SNode>from(node1,node2);
    }
  }
  Set<String> refNames=SetSequence.fromSet(new HashSet<String>());
  collectReferenceNames(refNames,node1);
  collectReferenceNames(refNames,node2);
  for (  String refLink : SetSequence.fromSet(refNames)) {
    if (node1.getReferenceTarget(refLink) != node2.getReferenceTarget(refLink)) {
      return MultiTuple.<SNode,SNode>from(node1,node2);
    }
  }
  Tuples._2<SNode,SNode> currentResult=null;
  Set<String> childNames=SetSequence.fromSet(new HashSet<String>());
  collectChildNames(childNames,node1);
  collectChildNames(childNames,node2);
  for (  String childLink : SetSequence.fromSet(childNames)) {
    List<SNode> children1=IterableUtil.asList(node1.getChildren(childLink));
    List<SNode> children2=IterableUtil.asList(node2.getChildren(childLink));
    if (children1.size() != children2.size()) {
      return MultiTuple.<SNode,SNode>from(node1,node2);
    }
{
      Iterator<SNode> child1_it=ListSequence.fromList(children1).iterator();
      Iterator<SNode> child2_it=ListSequence.fromList(children2).iterator();
      SNode child1_var;
      SNode child2_var;
      while (child1_it.hasNext() && child2_it.hasNext()) {
        child1_var=child1_it.next();
        child2_var=child2_it.next();
        Tuples._2<SNode,SNode> currentChildDiff=getDiffNodes(child1_var,child2_var);
        if (currentChildDiff != null) {
          if (currentResult == null) {
            currentResult=currentChildDiff;
          }
 else {
            return MultiTuple.<SNode,SNode>from(node1,node2);
          }
        }
      }
    }
  }
  return currentResult;
}
