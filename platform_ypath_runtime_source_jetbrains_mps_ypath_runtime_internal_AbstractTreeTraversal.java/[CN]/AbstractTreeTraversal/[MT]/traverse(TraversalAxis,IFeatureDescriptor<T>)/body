{
switch (axis) {
case DESCENDANTS:
    return new DescedantsOrThisTreeTraversal<T>(new ChildrenTreeTraversal<T>(this,featureDesc),featureDesc);
case SELF_DESCENDANTS:
  return new DescedantsOrThisTreeTraversal<T>(this,featureDesc);
case CHILDREN:
return new ChildrenTreeTraversal<T>(this,featureDesc);
case ANCESTORS:
return new AncestorsOrThisTreeTraversal<T>(new ParentTreeTraversal<T>(this,featureDesc),featureDesc);
case SELF_ANCESTORS:
return new AncestorsOrThisTreeTraversal<T>(this,featureDesc);
case FOLLOWING_SIBLINGS:
return new SiblingsTreeTraversal<T>(this,new ISiblingsFilter<T>(){
private boolean accepting;
public boolean accept(T t){
this.accepting=false;
return true;
}
public boolean accept(T sibling,T thisNode){
if (sibling == thisNode || (sibling != null && sibling.equals(thisNode))) {
this.accepting=true;
return false;
}
return accepting;
}
}
,featureDesc);
case SELF_FOLLOWING_SIBLINGS:
return new SiblingsTreeTraversal<T>(this,new ISiblingsFilter<T>(){
private boolean accepting;
public boolean accept(T t){
this.accepting=false;
return true;
}
public boolean accept(T sibling,T thisNode){
if (sibling == thisNode || (sibling != null && sibling.equals(thisNode))) {
this.accepting=true;
}
return accepting;
}
}
,featureDesc);
case PRECEDING_SIBLINGS:
return new SiblingsTreeTraversal<T>(this,new ISiblingsFilter<T>(){
private boolean accepting;
public boolean accept(T t){
this.accepting=true;
return true;
}
public boolean accept(T sibling,T thisNode){
if (sibling == thisNode || (sibling != null && sibling.equals(thisNode))) {
this.accepting=false;
}
return accepting;
}
}
,featureDesc);
case PRECEDING_SIBLINGS_SELF:
return new SiblingsTreeTraversal<T>(this,new ISiblingsFilter<T>(){
private boolean accepting;
public boolean accept(T t){
this.accepting=true;
return true;
}
public boolean accept(T sibling,T thisNode){
if (sibling == thisNode || (sibling != null && sibling.equals(thisNode))) {
this.accepting=false;
return true;
}
return accepting;
}
}
,featureDesc);
default :
break;
}
return null;
}
