{
  if (root == null) {
    return false;
  }
  invalidate();
  if (myCheckedRoot && SetSequence.fromSet(myInvalidNodes).isEmpty()) {
    return false;
  }
  Queue<SNode> nodesToCheck=QueueSequence.fromQueue(new LinkedList<SNode>());
  QueueSequence.fromQueue(nodesToCheck).addLastElement(root);
  while (QueueSequence.fromQueue(nodesToCheck).isNotEmpty()) {
    SNode node=QueueSequence.fromQueue(nodesToCheck).removeFirstElement();
    if (SNodeOperations.isInstanceOf(node,MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L,0x9b92103b95ca8c0cL,0x50ef06e32fec9043L,"jetbrains.mps.lang.core.structure.ISkipConstraintsChecking"))) {
      continue;
    }
    if (!(myCheckedRoot) || SetSequence.fromSet(myInvalidNodes).contains(node)) {
      try {
        myCurrentNode=node;
        addDependency(node);
        for (        AbstractConstraintsChecker checker : checkers) {
          checker.checkNode(node,this,repository);
        }
      }
  finally {
        myCurrentNode=null;
      }
    }
    QueueSequence.fromQueue(nodesToCheck).addSequence(ListSequence.fromList(SNodeOperations.getChildren(node)));
  }
  SetSequence.fromSet(myInvalidNodes).clear();
  myCheckedRoot=true;
  myUpdateInspector=true;
  return true;
}
