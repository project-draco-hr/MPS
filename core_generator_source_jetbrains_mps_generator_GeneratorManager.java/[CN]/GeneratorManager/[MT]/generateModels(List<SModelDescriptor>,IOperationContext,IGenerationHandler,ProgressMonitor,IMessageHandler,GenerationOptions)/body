{
  final boolean[] result=new boolean[1];
  final TransientModelsComponent transientModelsComponent=myProject.getComponent(TransientModelsComponent.class);
  transientModelsComponent.startGeneration(options.getNumberOfModelsToKeep());
  options.getGenerationTracer().startTracing();
  ModelAccess.instance().requireWrite(new Runnable(){
    public void run(){
      for (      SModelDescriptor d : inputModels) {
        if (d instanceof DefaultSModelDescriptor && ((DefaultSModelDescriptor)d).needsReloading()) {
          ((DefaultSModelDescriptor)d).reloadFromDisk();
          LOG.info("Model " + d + " reloaded from disk.");
        }
        transientModelsComponent.createModule(d.getModule());
      }
    }
  }
);
  GeneratorLoggerAdapter logger=new GeneratorLoggerAdapter(messages,options.isShowInfo(),options.isShowWarnings(),options.isKeepModelsWithWarnings());
  final GenerationController gc=new GenerationController(inputModels,transientModelsComponent,options,generationHandler,logger,invocationContext,new CancellationMonitor(monitor));
  ModelAccess.instance().requireRead(new Runnable(){
    @Override public void run(){
      result[0]=UndoHelper.getInstance().runNonUndoableAction(new Computable<Boolean>(){
        @Override public Boolean compute(){
          final boolean success=gc.generate(monitor);
          return success;
        }
      }
);
    }
  }
);
  ModelAccess.instance().requireWrite(new Runnable(){
    @Override public void run(){
      CleanupManager.getInstance().cleanup();
    }
  }
);
  if (result[0]) {
    try {
      ModelAccess.instance().requireWrite(new Runnable(){
        public void run(){
        }
      }
);
    }
 catch (    RuntimeException e) {
      LOG.error(e);
    }
  }
  options.getGenerationTracer().finishTracing();
  ModelAccess.instance().requireWrite(new Runnable(){
    public void run(){
      transientModelsComponent.publishAll();
      CleanupManager.getInstance().cleanup();
    }
  }
);
  generationHandler.generationCompleted();
  return result[0];
}
