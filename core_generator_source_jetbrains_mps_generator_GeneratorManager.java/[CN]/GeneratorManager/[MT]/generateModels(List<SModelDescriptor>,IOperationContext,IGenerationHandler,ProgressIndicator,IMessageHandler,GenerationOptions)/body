{
  final boolean[] result=new boolean[1];
  int i;
  for (i=0; i < 3 && !ModelAccess.instance().tryWrite(new Runnable(){
    public void run(){
      TransientModelsComponent transientModelsComponent=myProject.getComponent(TransientModelsComponent.class);
      transientModelsComponent.startGeneration(options.getNumberOfModelsToKeep());
      options.getGenerationTracer().startTracing();
      fireBeforeGeneration(inputModels,options,invocationContext);
      GeneratorLoggerAdapter logger=new GeneratorLoggerAdapter(messages,options.isShowInfo(),options.isShowWarnings(),options.isKeepModelsWithWarnings());
      final GenerationController gc=new GenerationController(inputModels,transientModelsComponent,options,generationHandler,logger,invocationContext,progress);
      result[0]=UndoHelper.getInstance().runNonUndoableAction(new Computable<Boolean>(){
        @Override public Boolean compute(){
          boolean success=gc.generate();
          if (success) {
            fireModelsGenerated(Collections.unmodifiableList(inputModels),success);
          }
          return success;
        }
      }
);
      options.getGenerationTracer().finishTracing();
      fireAfterGeneration(inputModels,options,invocationContext);
      transientModelsComponent.publishAll();
      CleanupManager.getInstance().cleanup();
    }
  }
); ++i) {
    try {
      Thread.sleep((1 << i) * 100);
    }
 catch (    InterruptedException ignore) {
    }
  }
  if (i >= 3) {
    throw new RuntimeException("Failed to acquire write lock");
  }
  generationHandler.generationCompleted();
  return result[0];
}
