{
  if (context == null || !(context instanceof IncrementalTypecheckingContext))   return;
  ((IncrementalTypecheckingContext)context).runTypeCheckingAction(new Runnable(){
    @Override public void run(){
      IncrementalTypechecking typesComponent=context.getBaseNodeTypesComponent();
      if (!wasCheckedOnce || !context.isCheckedRoot(true) || context.messagesChanged(editorContext.getEditorComponent().getClass())) {
        try {
          myMessagesChanged=true;
          context.checkIfNotChecked(rootNode,false);
        }
 catch (        Throwable t) {
          LOG.error(t);
          typesComponent.setCheckedTypesystem();
          return;
        }
      }
      if (!wasCheckedOnce || !typesComponent.isCheckedNonTypesystem()) {
        try {
          myMessagesChanged=true;
          context.setIsNonTypesystemComputation();
          typesComponent.applyNonTypesystemRulesToRoot(editorContext.getOperationContext(),context);
          typesComponent.setCheckedNonTypesystem();
        }
 catch (        Throwable t) {
          LOG.error(t);
          typesComponent.setCheckedNonTypesystem();
        }
 finally {
          context.resetIsNonTypesystemComputation();
        }
      }
      for (      Pair<SNode,List<IErrorReporter>> errorNode : context.getNodesWithErrors()) {
        List<IErrorReporter> errors=new ArrayList<IErrorReporter>(errorNode.o2);
        Collections.sort(errors,new Comparator<IErrorReporter>(){
          public int compare(          IErrorReporter o1,          IErrorReporter o2){
            return o2.getMessageStatus().compareTo(o1.getMessageStatus());
          }
        }
);
        boolean instantIntentionApplied=false;
        for (        IErrorReporter errorReporter : errors) {
          MessageStatus status=errorReporter.getMessageStatus();
          String errorString=errorReporter.reportError();
          HighlighterMessage message=HighlightUtil.createHighlighterMessage(errorNode.o1,NameUtil.capitalize(status.getPresentation()) + ": " + errorString,errorReporter,TypesEditorChecker.this,editorContext);
          List<QuickFixProvider> intentionProviders=message.getIntentionProviders();
          final SNode quickFixNode=errorNode.o1;
          if (intentionProviders.size() == 1 && intentionProviders.get(0) != null && intentionProviders.get(0).isExecutedImmediately() && !IMMEDIATE_QFIX_DISABLED) {
            QuickFixProvider intentionProvider=intentionProviders.get(0);
            if (!instantIntentionApplied) {
              final QuickFix_Runtime intention=intentionProvider.getQuickFix();
              if (intention != null) {
                instantIntentionApplied=true;
                if (!myOnceExecutedQuickFixes.contains(intention)) {
                  myOnceExecutedQuickFixes.add(intention);
                  LaterInvocator.invokeLater(new Runnable(){
                    public void run(){
                      EditorCell selectedCell=editorContext.getSelectedCell();
                      if (selectedCell == null)                       return;
                      boolean restoreCaretPosition=false;
                      int caretX=0;
                      int caretY=0;
                      Project p=(editorContext != null && editorContext.getOperationContext() != null ? editorContext.getOperationContext().getProject() : null);
                      if (p == null) {
                        return;
                      }
                      if (selectedCell instanceof EditorCell_Label) {
                        EditorCell_Label cell_label=(EditorCell_Label)selectedCell;
                        restoreCaretPosition=jetbrains.mps.util.SNodeOperations.isAncestor(quickFixNode,cell_label.getSNode());
                        caretX=cell_label.getCaretX();
                        caretY=cell_label.getBaseline();
                        boolean last=cell_label.getCaretPosition() == cell_label.getText().length();
                        boolean first=cell_label.getCaretPosition() == 0;
                        if (last) {
                          caretX=caretX - 1;
                        }
                        if (first) {
                          caretY=caretY + 1;
                        }
                      }
                      ModelAccess.instance().runUndoTransparentCommand(new Runnable(){
                        public void run(){
                          intention.execute(quickFixNode);
                        }
                      }
,p);
                      if (restoreCaretPosition) {
                        editorContext.flushEvents();
                        EditorCell rootCell=editorContext.getEditorComponent().getRootCell();
                        EditorCell leaf=rootCell.findLeaf(caretX,caretY);
                        if (leaf != null) {
                          editorContext.getEditorComponent().changeSelection(leaf);
                          leaf.setCaretX(caretX);
                        }
                      }
                    }
                  }
,ModalityState.NON_MODAL);
                }
              }
            }
          }
 else {
            messages.add(message);
          }
        }
      }
    }
  }
);
}
