{
  Set<RelationBlock> blocks=new THashSet<RelationBlock>(myNodesToBlocksInc.getByFirst(node));
  final Set<Block> stateBlocks=myState.getBlocks();
  for (Iterator<RelationBlock> it=blocks.iterator(); it.hasNext(); ) {
    final RelationBlock next=it.next();
    if (!stateBlocks.contains(next) || isRecursive(next)) {
      it.remove();
    }
  }
  alreadyPassed.add(node);
  blocks=getRelationBlocks(blocks,relation);
  for (  RelationBlock block : blocks) {
    if (block.isCheckOnly()) {
      continue;
    }
    SNode left=myState.getRepresentative(block.getLeftNode());
    SNode right=myState.getRepresentative(block.getRightNode());
    if (right == left) {
      continue;
    }
    SNode cur=isLeft ? left : right;
    SNode other=isLeft ? right : left;
    if (cur == node) {
      if (!TypesUtil.isVariable(other)) {
        SNode type=myState.expand(other);
        collected.add(type);
        typesToBlocks.put(type,block);
      }
 else {
        if (!alreadyPassed.contains(other)) {
          collectNodesTransitive(other,collected,isLeft,typesToBlocks,relation,alreadyPassed);
        }
      }
    }
  }
}
