{
  Set<SNode> nodes=new LinkedHashSet<SNode>();
  ManyToManyMap<SNode,SNode> inputsToOutputs=new ManyToManyMap<SNode,SNode>();
  ManyToManyMap<SNode,InequalityBlock> nodesToBlocks=new ManyToManyMap<SNode,InequalityBlock>();
  for (  InequalityBlock inequality : inequalities) {
    SNode input=myState.getRepresentative(inequality.getInput());
    SNode output=myState.getRepresentative(inequality.getOutput());
    if (input != null) {
      if (input != output) {
        inputsToOutputs.addLink(input,output);
        nodesToBlocks.addLink(input,inequality);
        nodes.add(input);
        if (!TypesUtil.isVariable(input) && !TypesUtil.isVariable(output)) {
          for (          SNode inputVar : TypesUtil.getVariables(input)) {
            for (            SNode outputVar : TypesUtil.getVariables(output)) {
              inputsToOutputs.addLink(myState.getRepresentative(inputVar),myState.getRepresentative(outputVar));
            }
          }
        }
      }
      nodesToBlocks.addLink(output,inequality);
      nodes.add(output);
    }
  }
  if (nodes.isEmpty()) {
    return;
  }
  List<SNode> sortedNodes=sort(inputsToOutputs,nodes);
  Map<SNode,InequalityBlock> typesToBlocks=new HashMap<SNode,InequalityBlock>();
  for (  SNode node : sortedNodes) {
    if (!TypesUtil.isVariable(node)) {
      continue;
    }
    Set<InequalityBlock> blocks=nodesToBlocks.getByFirst(node);
    Set<SNode> superTypes=new LinkedHashSet<SNode>();
    Set<SNode> subTypes=new LinkedHashSet<SNode>();
    for (    InequalityBlock block : blocks) {
      if (block.getRelationKind().isCheckOnly()) {
        continue;
      }
      SNode left=myState.getRepresentative(block.getLeftNode());
      SNode right=myState.getRepresentative(block.getRightNode());
      if (right == left) {
        continue;
      }
      if (left == node && !TypesUtil.isVariable(right)) {
        superTypes.add(right);
        typesToBlocks.put(right,block);
      }
      if (right == node && !TypesUtil.isVariable(left)) {
        subTypes.add(left);
        typesToBlocks.put(left,block);
      }
    }
    SubTyping subTyping=new SubTyping(myState);
    if (TypesUtil.isVariable(node)) {
      SNode result=null;
      EquationInfo info=null;
      if (!subTypes.isEmpty()) {
        result=subTyping.createLCS(subTypes);
        InequalityBlock block=typesToBlocks.get(result);
        info=(block != null) ? block.getEquationInfo() : typesToBlocks.get(subTypes.iterator().next()).getEquationInfo();
      }
 else       if (!superTypes.isEmpty()) {
        result=subTyping.createMeet(superTypes);
        InequalityBlock block=typesToBlocks.get(result);
        info=(block != null) ? block.getEquationInfo() : typesToBlocks.get(superTypes.iterator().next()).getEquationInfo();
      }
      if (result != null) {
        myState.addEquation(node,result,info);
      }
    }
 else {
    }
  }
}
