{
  final ArrayDeque<Entry> weakEntries=new ArrayDeque<Entry>();
  for (  Entry entry : myRulePriorityEntries) {
    if (!entry.isStrict() && !entry.isTrivial()) {
      weakEntries.add(entry);
    }
  }
  if (Boolean.TRUE.booleanValue()) {
    for (    Entry weak : weakEntries) {
      weak.makeStrict();
    }
    return;
  }
  while (!weakEntries.isEmpty()) {
    Entry weak=weakEntries.removeFirst();
    myRulePriorityEntries.remove(weak);
    Collection<Entry> toAdd=new ArrayList<Entry>();
    for (    Entry entry : myRulePriorityEntries) {
      if (entry.isTrivial()) {
        continue;
      }
      final boolean substituteForSooner=entry.later().equals(weak.sooner());
      final boolean dependsOnWeak=entry.sooner().equals(weak.later());
      if (!substituteForSooner && !dependsOnWeak) {
        continue;
      }
      final Entry newEntry;
      HashSet<MappingPriorityRule> mergedRules=new HashSet<MappingPriorityRule>(entry.getRules());
      mergedRules.addAll(weak.getRules());
      if (substituteForSooner) {
        newEntry=new Entry(entry.sooner(),weak.later(),entry.isStrict(),mergedRules);
      }
 else {
        assert dependsOnWeak;
        newEntry=new Entry(weak.sooner(),entry.later(),entry.isStrict(),mergedRules);
      }
      toAdd.add(newEntry);
      if (!newEntry.isStrict() && !newEntry.isTrivial()) {
        weakEntries.add(newEntry);
      }
    }
    if (toAdd.isEmpty()) {
      toAdd.add(weak.makeStrict());
    }
 else {
      HashSet<Group> addedSooner=new HashSet<Group>();
      HashSet<Group> addedLater=new HashSet<Group>();
      for (      Entry e : toAdd) {
        addedSooner.add(e.sooner());
        addedLater.add(e.later());
      }
      addedSooner.remove(weak.sooner());
      addedLater.remove(weak.later());
      TransitiveClosure<Group> closureBuilder=new TransitiveClosure<Group>();
      for (      Entry e : myRulePriorityEntries) {
        if (!e.isTrivial()) {
          closureBuilder.feed(e.sooner(),e.later());
        }
      }
      HashSet<Group> closure=new HashSet<Group>();
      for (      Group l : addedSooner) {
        closure.addAll(closureBuilder.closure(l));
      }
      closure.retainAll(addedLater);
      if (closure.isEmpty()) {
        toAdd.add(weak.makeStrict());
      }
    }
    myRulePriorityEntries.addAll(toAdd);
  }
}
