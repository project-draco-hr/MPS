{
  myMessagesChanged=false;
  final Set<EditorMessage> messages=new LinkedHashSet<EditorMessage>();
  final TypeCheckingContext context=editorContext.getNodeEditorComponent().getTypeCheckingContext();
  if (context != null) {
    context.runTypeCheckingAction(new Runnable(){
      @Override public void run(){
        NodeTypesComponent typesComponent=context.getBaseNodeTypesComponent();
        if (!wasCheckedOnce || !context.isCheckedRoot(true)) {
          try {
            myMessagesChanged=true;
            context.checkRoot();
          }
 catch (          Throwable t) {
            LOG.error(t);
            typesComponent.setCheckedTypesystem();
            return;
          }
        }
        if (!wasCheckedOnce || !typesComponent.isCheckedNonTypesystem()) {
          try {
            myMessagesChanged=true;
            context.setIsNonTypesystemComputation();
            typesComponent.applyNonTypesystemRulesToRoot(operationContext);
            typesComponent.setCheckedNonTypesystem();
          }
 catch (          Throwable t) {
            LOG.error(t);
            typesComponent.setCheckedNonTypesystem();
          }
 finally {
            context.resetIsNonTypesystemComputation();
          }
        }
        for (        Pair<SNode,List<IErrorReporter>> errorNode : context.getNodesWithErrors()) {
          List<IErrorReporter> errors=new ArrayList<IErrorReporter>(errorNode.o2);
          Collections.sort(errors,new Comparator<IErrorReporter>(){
            public int compare(            IErrorReporter o1,            IErrorReporter o2){
              return o2.getMessageStatus().compareTo(o1.getMessageStatus());
            }
          }
);
          boolean instantIntentionApplied=false;
          for (          IErrorReporter errorReporter : errors) {
            MessageStatus status=errorReporter.getMessageStatus();
            String errorString=errorReporter.reportError();
            HighlighterMessage message=HighlightUtil.createHighlighterMessage(errorNode.o1,NameUtil.capitalize(status.getPresentation()) + ": " + errorString,errorReporter,TypesEditorChecker.this,editorContext);
            QuickFixProvider intentionProvider=errorReporter.getIntentionProvider();
            final SNode quickFixNode=errorNode.o1;
            if (intentionProvider != null && intentionProvider.isExecutedImmediately() && !IMMEDIATE_QFIX_DISABLED) {
              if (!instantIntentionApplied) {
                final QuickFix_Runtime intention=intentionProvider.getQuickFix();
                if (intention != null) {
                  instantIntentionApplied=true;
                  if (!myOnceExecutedQuickFixes.contains(intention)) {
                    myOnceExecutedQuickFixes.add(intention);
                    LaterInvocator.invokeLater(new Runnable(){
                      public void run(){
                        EditorCell selectedCell=editorContext.getSelectedCell();
                        if (selectedCell == null)                         return;
                        boolean restoreCaretPosition=false;
                        int caretX=0;
                        int caretY=0;
                        if (selectedCell instanceof EditorCell_Label) {
                          EditorCell_Label cell_label=(EditorCell_Label)selectedCell;
                          restoreCaretPosition=cell_label.getSNode().getAncestors(true).contains(quickFixNode);
                          caretX=cell_label.getCaretX();
                          caretY=cell_label.getBaseline();
                          boolean last=cell_label.getCaretPosition() == cell_label.getText().length();
                          boolean first=cell_label.getCaretPosition() == 0;
                          if (last) {
                            caretX=caretX - 1;
                          }
                          if (first) {
                            caretY=caretY + 1;
                          }
                        }
                        ModelAccess.instance().runWriteActionInCommand(new Runnable(){
                          public void run(){
                            CommandProcessor.getInstance().runUndoTransparentAction(new Runnable(){
                              public void run(){
                                intention.execute(quickFixNode);
                              }
                            }
);
                          }
                        }
);
                        if (restoreCaretPosition) {
                          editorContext.flushEvents();
                          EditorCell rootCell=editorContext.getNodeEditorComponent().getRootCell();
                          EditorCell leaf=rootCell.findLeaf(caretX,caretY);
                          if (leaf != null) {
                            editorContext.getNodeEditorComponent().changeSelection(leaf);
                            leaf.setCaretX(caretX);
                          }
                        }
                      }
                    }
,ModalityState.NON_MODAL);
                  }
                }
              }
            }
 else {
              if (intentionProvider != null) {
                intentionProvider.setIsError(status == MessageStatus.ERROR);
              }
              message.setIntentionProvider(intentionProvider);
            }
            messages.add(message);
          }
        }
      }
    }
);
  }
  return messages;
}
