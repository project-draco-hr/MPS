{
  List<MethodMatch> found=new ArrayList<MethodMatch>();
  for (  SNode node : ListSequence.fromList(SNodeOperations.getDescendants(root,"jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{}))) {
    SNode current=node;
    MethodDuplicatesFinder.MethodMatchModifier modifier=new MethodDuplicatesFinder.MethodMatchModifier();
    boolean hasNoErrors=true;
    for (    SNode nodeToFind : ListSequence.fromList(this.myNodesToFind)) {
      if ((current == null) || SetSequence.fromSet(this.myUsedNodes).contains(current)) {
        hasNoErrors=false;
        break;
      }
 else {
        modifier.getMatch().putNode(current);
        if (!(ExtractMethodFactory.isRefactoringAvailable(modifier.getMatch().getNodes())) || !(MatchingUtil.matchNodes(current,nodeToFind,modifier,true))) {
          hasNoErrors=false;
          break;
        }
        current=SNodeOperations.getNextSibling(current);
      }
    }
    if (hasNoErrors) {
      MethodMatch resultMatch=modifier.getMatch();
      resultMatch.createRefactoring();
      if (resultMatch.checkMatch()) {
        for (        SNode resultNode : ListSequence.fromList(resultMatch.getNodes())) {
          SetSequence.fromSet(this.myUsedNodes).addElement(resultNode);
        }
        found.add(resultMatch);
      }
    }
  }
  return found;
}
