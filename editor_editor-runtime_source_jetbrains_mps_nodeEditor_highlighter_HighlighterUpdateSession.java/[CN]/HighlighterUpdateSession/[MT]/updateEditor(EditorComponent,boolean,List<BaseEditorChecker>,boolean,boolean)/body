{
  if (editor == null || editor.getRootCell() == null)   return false;
  final NodeHighlightManager highlightManager=editor.getHighlightManager();
  boolean anyMessageChanged=false;
  for (  final BaseEditorChecker checker : checkersToRecheck) {
    final LinkedHashSet<EditorMessage> messages=new LinkedHashSet<EditorMessage>();
    boolean changed=runLoPrioRead(new Computable<Boolean>(){
      @Override public Boolean compute(){
        if (myHighlighter.isPausedOrStopping())         return false;
        SNode node=editor.getEditedNode();
        if (node == null)         return false;
        if (!SNodeUtil.isAccessible(node,MPSModuleRepository.getInstance())) {
          return null;
        }
        EditorContext editorContext=editor.getEditorContext();
        IOperationContext operationContext=editor.getOperationContext();
        if (operationContext.isValid()) {
          try {
            messages.addAll(checker.createMessagesProtected(node,myEvents,wasCheckedOnce,editorContext,new HighlighterUpdateSessionCancellable(myHighlighter,editor),applyQuickFixes));
            return checker.areMessagesChangedProtected();
          }
 catch (          IndexNotReadyException ex) {
            highlightManager.clearForOwner(checker,true);
            checker.clearProtected(node,editor);
            throw ex;
          }
        }
        return false;
      }
    }
);
    if (myHighlighter.isStopping())     return false;
    if (editor instanceof InspectorEditorComponent && recreateInspectorMessages) {
      changed=true;
    }
    if (changed) {
      anyMessageChanged=true;
      highlightManager.clearForOwner(checker,false);
      for (      EditorMessage message : messages) {
        highlightManager.mark(message);
      }
    }
  }
  if (myHighlighter.isStopping())   return false;
  if (anyMessageChanged) {
    highlightManager.repaintAndRebuildEditorMessages();
    editor.updateStatusBarMessage();
  }
  return anyMessageChanged;
}
