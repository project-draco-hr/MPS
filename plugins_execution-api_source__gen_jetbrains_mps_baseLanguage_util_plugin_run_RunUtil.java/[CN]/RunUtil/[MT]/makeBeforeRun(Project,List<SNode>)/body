{
  if (ThreadUtils.isEventDispatchThread()) {
    throw new RuntimeException("Can't run make from the event dispatch thread");
  }
  final Wrappers._T<List<SModel>> descriptors=new Wrappers._T<List<SModel>>();
  ModelAccess.instance().runReadAction(new Runnable(){
    public void run(){
      descriptors.value=ListSequence.fromListWithValues(new ArrayList<SModel>(),ListSequence.fromList(nodes).select(new ISelector<SNode,SModel>(){
        public SModel select(        SNode it){
          return (SModel)SNodeOperations.getModel(it);
        }
      }
).distinct().where(new IWhereFilter<SModel>(){
        public boolean accept(        SModel it){
          return ModelGenerationStatusManager.getInstance().generationRequired(it);
        }
      }
));
    }
  }
);
  if (ListSequence.fromList(descriptors.value).isEmpty()) {
    return true;
  }
  MakeSession session=new MakeSession(new ProjectOperationContext(ProjectHelper.toMPSProject(project)),null,true);
  if (IMakeService.INSTANCE.get().openNewSession(session)) {
    Future<IResult> future=IMakeService.INSTANCE.get().make(session,new ModelsToResources(new ProjectOperationContext(ProjectHelper.toMPSProject(project)),descriptors.value).resources(false));
    IResult result=null;
    try {
      result=future.get();
    }
 catch (    CancellationException ignore) {
    }
catch (    InterruptedException ignore) {
    }
catch (    ExecutionException ignore) {
    }
    return result != null && result.isSucessful();
  }
  return true;
}
