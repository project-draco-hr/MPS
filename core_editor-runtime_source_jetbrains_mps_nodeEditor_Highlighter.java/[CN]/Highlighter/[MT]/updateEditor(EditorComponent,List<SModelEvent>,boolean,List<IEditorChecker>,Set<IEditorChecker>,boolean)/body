{
  if (editor == null || editor.getRootCell() == null) {
    return false;
  }
  final NodeHighlightManager highlightManager=editor.getHighlightManager();
  boolean anyMessageChanged=false;
  for (  final IEditorChecker checker : checkersToRecheck) {
    final LinkedHashSet<EditorMessage> messages=new LinkedHashSet<EditorMessage>();
    final EditorMessageOwner[] owners=new EditorMessageOwner[1];
    final boolean[] messagesChangedContainer={false};
    Runnable runnable=new Runnable(){
      public void run(){
        if (myStopThread) {
          return;
        }
        SNode node=editor.getEditedNode();
        if (node == null || node.isDisposed())         return;
        owners[0]=checker.getOwner(node,editor);
        EditorContext editorContext=editor.getEditorContext();
        if (editorContext != null) {
          IOperationContext operationContext=editor.getOperationContext();
          if (operationContext.isValid()) {
            try {
              messages.addAll(checker.createMessages(node,operationContext,events,wasCheckedOnce,editorContext));
              messagesChangedContainer[0]=messagesChangedContainer[0] || checker.messagesChanged();
            }
 catch (            IndexNotReadyException ex) {
              highlightManager.clearForOwner(owners[0],true);
              checker.clear(node,editor);
              throw ex;
            }
          }
        }
      }
    }
;
    ModelAccess.instance().runReadAction(runnable);
    if (myStopThread) {
      return false;
    }
    boolean messagesChanged=messagesChangedContainer[0];
    if (editor instanceof InspectorEditorComponent && recreateInspectorMessages) {
      messagesChanged=true;
    }
    if (messagesChanged) {
      anyMessageChanged=true;
      EditorMessageOwner owner=owners[0];
      if (owner != null) {
        highlightManager.clearForOwner(owner,false);
      }
      for (      EditorMessage message : messages) {
        highlightManager.mark(message);
      }
    }
  }
  for (  final IEditorChecker checker : checkersToRemove) {
    final EditorMessageOwner[] owners=new EditorMessageOwner[1];
    Runnable runnable=new Runnable(){
      public void run(){
        if (myStopThread) {
          return;
        }
        SNode node=editor.getEditedNode();
        if (node == null)         return;
        owners[0]=checker.getOwner(node,editor);
      }
    }
;
    ModelAccess.instance().runReadAction(runnable);
    if (myStopThread) {
      return false;
    }
    highlightManager.clearForOwner(owners[0],false);
    anyMessageChanged=true;
  }
  if (myStopThread) {
    return false;
  }
  if (anyMessageChanged) {
    highlightManager.repaintAndRebuildEditorMessages();
    editor.updateStatusBarMessage();
  }
  return anyMessageChanged;
}
