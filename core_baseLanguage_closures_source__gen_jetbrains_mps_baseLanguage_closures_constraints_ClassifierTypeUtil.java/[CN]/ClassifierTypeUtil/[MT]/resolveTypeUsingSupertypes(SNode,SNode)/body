{
  List<SNode> visitedClassifiers=ListSequence.<SNode>fromList(new ArrayList<SNode>());
  List<SNode> concretes=ListSequence.<SNode>fromList(new LinkedList<SNode>());
  ListSequence.<SNode>fromList(concretes).addElement(concrete);
  SNode resType=type;
  while (!(ListSequence.<SNode>fromList(concretes).isEmpty())) {
    SNode ct=SNodeOperations.as(ListSequence.<SNode>fromList(concretes).removeElementAt(0),"jetbrains.mps.baseLanguage.structure.ClassifierType");
    if (ListSequence.<SNode>fromList(visitedClassifiers).contains(SLinkOperations.getTarget(ct,"classifier",false)) || ListSequence.<SNode>fromList(SLinkOperations.getTargets(ct,"parameter",true)).count() == 0) {
      continue;
    }
    ListSequence.<SNode>fromList(visitedClassifiers).addElement(SLinkOperations.getTarget(ct,"classifier",false));
    for (    SNode sup : TypeChecker.getInstance().getSubtypingManager().collectImmediateSupertypes(ct)) {
{
        IMatchingPattern pattern_zgotlq_a0d0e0f=HUtil.createMatchingPatternByConceptFQName("jetbrains.mps.baseLanguage.structure.ClassifierType");
        SNode coercedNode_zgotlq_a0d0e0f=TypeChecker.getInstance().getRuntimeSupport().coerce_(sup,pattern_zgotlq_a0d0e0f);
        if (coercedNode_zgotlq_a0d0e0f != null) {
          ListSequence.<SNode>fromList(concretes).addElement(coercedNode_zgotlq_a0d0e0f);
        }
 else {
        }
      }
    }
    resType=resolveType(resType,ct);
    if (ListSequence.<SNode>fromList(SNodeOperations.getDescendants(resType,"jetbrains.mps.baseLanguage.structure.TypeVariableReference",false,new String[]{})).isEmpty()) {
      break;
    }
  }
  return resType;
}
