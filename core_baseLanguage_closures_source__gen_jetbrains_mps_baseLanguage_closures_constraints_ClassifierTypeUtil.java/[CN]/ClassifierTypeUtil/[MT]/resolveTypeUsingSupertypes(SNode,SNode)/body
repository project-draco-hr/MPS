{
  List<SNode> visitedClassifiers=new ArrayList<SNode>();
  LinkedList<SNode> concretes=new LinkedList<SNode>();
  concretes.addLast(concrete);
  SNode resType=type;
  while (!(concretes.isEmpty())) {
    SNode ct=concretes.removeFirst();
    if (visitedClassifiers.contains(SLinkOperations.getTarget(ct,"classifier",false)) || SLinkOperations.getCount(ct,"parameter") == 0) {
      continue;
    }
    visitedClassifiers.add(SLinkOperations.getTarget(ct,"classifier",false));
    for (    SNode sup : TypeChecker.getInstance().getSubtypingManager().collectImmediateSupertypes(ct)) {
{
        IMatchingPattern pattern_0=HUtil.createMatchingPatternByConceptFQName("jetbrains.mps.baseLanguage.structure.ClassifierType");
        SNode coercedNode_0=TypeChecker.getInstance().getRuntimeSupport().coerce(sup,pattern_0);
        if (coercedNode_0 != null) {
          concretes.addLast(coercedNode_0);
        }
      }
    }
    resType=resolveType(resType,ct);
    if (((List)SNodeOperations.getDescendants(resType,"jetbrains.mps.baseLanguage.structure.TypeVariableReference",false)).isEmpty()) {
      break;
    }
  }
  return resType;
}
