{
  List<SNode> visitedClassifiers=new ArrayList<SNode>();
  List<SNode> concretes=new LinkedList<SNode>();
  ListSequence.fromList(concretes).addElement(concrete);
  SNode resType=type;
  while (!(ListSequence.fromList(concretes).isEmpty())) {
    SNode ct=ListSequence.fromList(concretes).removeElementAt(0);
    if (visitedClassifiers.contains(SLinkOperations.getTarget(ct,"classifier",false)) || SLinkOperations.getCount(ct,"parameter") == 0) {
      continue;
    }
    ListSequence.fromList(visitedClassifiers).addElement(SLinkOperations.getTarget(ct,"classifier",false));
    for (    SNode sup : TypeChecker.getInstance().getSubtypingManager().collectImmediateSupertypes(ct)) {
{
        IMatchingPattern pattern_0=HUtil.createMatchingPatternByConceptFQName("jetbrains.mps.baseLanguage.structure.ClassifierType");
        SNode coercedNode_0=TypeChecker.getInstance().getRuntimeSupport().coerce_(sup,pattern_0);
        if (coercedNode_0 != null) {
          ListSequence.fromList(concretes).addElement(coercedNode_0);
        }
 else {
        }
      }
    }
    resType=resolveType(resType,ct);
    if (((List)SNodeOperations.getDescendants(resType,"jetbrains.mps.baseLanguage.structure.TypeVariableReference",false)).isEmpty()) {
      break;
    }
  }
  return resType;
}
