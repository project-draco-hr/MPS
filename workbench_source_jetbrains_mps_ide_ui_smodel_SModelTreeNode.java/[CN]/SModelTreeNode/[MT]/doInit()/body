{
  try {
    myInitializing=true;
    removeAllChildren();
    myPackageNodes.clear();
    myRootGroups.clear();
    for (    SNodeGroupTreeNode group : myRootGroups) {
      add(group);
    }
    SModel model=getSModel();
    Condition<SNode> condition=new Condition<SNode>(){
      public boolean met(      SNode object){
        return !(BaseAdapter.fromNode(object) instanceof AttributeConcept);
      }
    }
;
    List<SNode> filteredRoots=CollectionUtil.filter(model.getRoots(),new AndCondition<SNode>(condition,myNodesCondition));
    List<SNode> sortedRoots=SortUtil.sortNodesByPresentation(filteredRoots);
    for (    SNode sortedRoot : sortedRoots) {
      MPSTreeNodeEx treeNode=createSNodeTreeNode(sortedRoot,getOperationContext(),myNodesCondition);
      MPSTreeNode group=getNodeGroupFor(sortedRoot);
      if (group != null) {
        group.add(treeNode);
      }
 else {
        add(treeNode);
      }
    }
    if (myModelDescriptor != null) {
      DefaultTreeModel treeModel=(DefaultTreeModel)getTree().getModel();
      List<SModelDescriptor> sortedModels=SortUtil.sortModels(myModelDescriptor.getModule().getOwnModelDescriptors());
      List<SModelDescriptor> subfolderModels=getSubfolderModels(sortedModels);
      for (      SModelDescriptor subfolderModel : subfolderModels) {
        SModelTreeNode newChildModel=new SModelTreeNode(subfolderModel,null,getOperationContext(),false);
        int index=subfolderModels.indexOf(subfolderModel);
        treeModel.insertNodeInto(newChildModel,this,index);
      }
    }
    DefaultTreeModel treeModel=(DefaultTreeModel)getTree().getModel();
    treeModel.nodeStructureChanged(this);
  }
  finally {
    myInitialized=true;
    myInitializing=false;
  }
}
