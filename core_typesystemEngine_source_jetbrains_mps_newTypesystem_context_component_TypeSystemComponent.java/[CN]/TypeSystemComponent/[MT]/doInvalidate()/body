{
  if (isInvalidationWasPerformed()) {
    return isInvalidationResult();
  }
  boolean result;
  Set<SNode> invalidatedNodes_A=new THashSet<SNode>();
  Set<SNode> invalidatedNodes_B=new THashSet<SNode>();
  Set<SNode> newNodesToInvalidate_A=new THashSet<SNode>();
  Set<SNode> currentNodesToInvalidate_A=getCurrentNodesToInvalidate();
  Set<SNode> nodesToInvalidate_B=new THashSet<SNode>();
  if (isCacheWasRebuilt()) {
    currentNodesToInvalidate_A.addAll(myNodesDependentOnCaches);
  }
  boolean initial=true;
  while (!currentNodesToInvalidate_A.isEmpty()) {
    for (    SNode nodeToInvalidate : currentNodesToInvalidate_A) {
      if (invalidatedNodes_A.contains(nodeToInvalidate))       continue;
      boolean recalc=nodeToInvalidate.getModel() != null;
      invalidateNodeTypeSystem(nodeToInvalidate,recalc);
      invalidatedNodes_A.add(nodeToInvalidate);
      Set<SNode> nodes=myNodesToDependentNodes_A.get(nodeToInvalidate);
      if (nodes != null) {
        newNodesToInvalidate_A.addAll(nodes);
      }
      nodes=myNodesToDependentNodes_B.get(nodeToInvalidate);
      if (nodes != null) {
        nodesToInvalidate_B.addAll(nodes);
      }
    }
    currentNodesToInvalidate_A=newNodesToInvalidate_A;
    newNodesToInvalidate_A=new THashSet<SNode>();
  }
  for (  SNode nodeToInvalidate : nodesToInvalidate_B) {
    if (invalidatedNodes_A.contains(nodeToInvalidate))     continue;
    if (invalidatedNodes_B.contains(nodeToInvalidate))     continue;
    invalidateNodeTypeSystem(nodeToInvalidate,false);
    invalidatedNodes_B.add(nodeToInvalidate);
  }
  result=!invalidatedNodes_A.isEmpty() || !invalidatedNodes_B.isEmpty();
  clearNodeTypes();
  setInvalidationResult(result);
  return result;
}
