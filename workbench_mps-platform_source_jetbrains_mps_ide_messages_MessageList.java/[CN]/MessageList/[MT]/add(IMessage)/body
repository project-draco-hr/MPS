{
  if (MPSCore.getInstance().isTestMode())   return;
  myMessagesInProgress.incrementAndGet();
  myMessagesQueue.add(message);
  myUpdateQueue.queue(new Update(myUpdateIdentity){
    @Override public void run(){
      if (isDisposed()) {
        return;
      }
      final List<IMessage> messagesToAdd=new ArrayList<IMessage>();
      int maxWidth=-1;
      while (!myMessagesQueue.isEmpty()) {
        IMessage message=myMessagesQueue.remove();
        myMessagesInProgress.decrementAndGet();
        if (isVisible(message)) {
          messagesToAdd.add(message);
        }
        myMessages.add(message);
        updateMessageCounters(message,1);
        maxWidth=Math.max(maxWidth,getMessageWidth(message));
      }
      int toRemoveCount=0;
      if (myMessages.size() + messagesToAdd.size() > MAX_SIZE) {
        for (int i=0; i < messagesToAdd.size(); i++) {
          IMessage toRemove=myMessages.remove();
          updateMessageCounters(toRemove,-1);
          if (isVisible(toRemove)) {
            toRemoveCount++;
          }
        }
      }
      if (toRemoveCount > 0) {
        myModel.removeFirst(toRemoveCount);
      }
      myModel.addAll(messagesToAdd);
      int index=myModel.getSize() - 1;
      if (myList.getAutoscrolls()) {
        myList.getSelectionModel().setSelectionInterval(index,index);
      }
      if (myMessagesInProgress.get() == 0) {
        myList.ensureIndexIsVisible(index);
      }
      if (maxWidth > myList.getFixedCellWidth()) {
        myList.setFixedCellWidth(maxWidth);
      }
      updateHeader();
      updateActions();
    }
    private void updateMessageCounters(    IMessage m,    int delta){
      if (m.getKind() == MessageKind.ERROR) {
        myErrors+=delta;
      }
      if (m.getKind() == MessageKind.WARNING) {
        myWarnings+=delta;
      }
      if (m.getKind() == MessageKind.INFORMATION) {
        myInfos+=delta;
      }
      if (m.getHintObject() != null) {
        myHintObjects+=delta;
      }
    }
  }
);
}
