{
  ClassifierUpdater updater=new ClassifierUpdater(false,new SReferenceHandler(){
    public SReference createSReference(    SNode source,    String pack,    SNodeId targetNodeId,    String role,    String resolveInfo,    String rootPresentation){
      return null;
    }
  }
);
  ClassifierLoader loader=new ClassifierLoader(new ClassBytesProvider(){
    @Nullable public byte[] getClass(    String p0){
      return null;
    }
  }
,updater);
  ClassReader reader=new ClassReader(inputData.getContent());
  ASMClass ac=new ASMClass(reader);
  CharSequence data=inputData.getContentAsText();
  char[] charsArray=CharArrayUtil.fromSequenceWithoutCopying(data);
  if (charsArray == null) {
    charsArray=CharArrayUtil.fromSequence(data);
  }
  final Map<ModelPersistence.IndexEntry,Integer> res;
  try {
    res=ModelPersistence.index(charsArray);
  }
 catch (  ModelReadException e) {
    return Collections.emptyMap();
  }
  HashMap<IdIndexEntry,Integer> result=new HashMap<IdIndexEntry,Integer>();
  for (  Map.Entry<ModelPersistence.IndexEntry,Integer> ie : res.entrySet()) {
    result.put(new IdIndexEntry(ie.getKey().data,ie.getKey().caseSensitive),ie.getValue());
  }
  return result;
}
