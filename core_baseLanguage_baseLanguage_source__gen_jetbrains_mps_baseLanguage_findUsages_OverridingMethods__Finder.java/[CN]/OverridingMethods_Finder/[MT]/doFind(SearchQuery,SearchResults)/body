{
  SNode searchedNode=(SNode)searchQuery.getNode();
  results.getSearchedNodePointers().add(new SNodePointer(searchedNode));
  List<SearchResult> derivedClassesResults=new ArrayList<SearchResult>();
  try {
    GeneratedFinder _finder=(GeneratedFinder)Class.forName("jetbrains.mps.baseLanguage.findUsages.DerivedClasses_Finder").newInstance();
    SNode _node=SNodeOperations.getParent(searchedNode,null,false,false);
    IScope _scope;
    _scope=searchQuery.getScope();
    boolean rightConcept=_node.isInstanceOfConcept("jetbrains.mps.baseLanguage.structure.ClassConcept");
    if (!(rightConcept)) {
      OverridingMethods_Finder.LOG.error("Trying to use finder that is not applicable to the concept. Returning empty results." + "[finder: \"" + _finder.getDescription() + "\" ; concept: "+ searchQuery.getNodePointer().getNode().getConceptFqName());
    }
 else {
      boolean isApplicable=_finder.isApplicable(_node);
      if (!(isApplicable)) {
        OverridingMethods_Finder.LOG.error("Trying to use finder that is not applicable to the node. Returning empty results." + "[finder: \"" + _finder.getDescription() + "\" ; node: "+ searchQuery.getNodePointer().getNode().toString());
      }
 else {
        SearchResults results_=_finder.find(new SearchQuery(_node,_scope));
        for (        SearchResult result : results_.getSearchResults()) {
          derivedClassesResults.add(result);
        }
      }
    }
  }
 catch (  Throwable t) {
    OverridingMethods_Finder.LOG.error("Error instantiating finder \"" + "jetbrains.mps.baseLanguage.findUsages.DerivedClasses_Finder" + "\"  Message:"+ t.getMessage());
  }
{
    ICursor<SearchResult> _zCursor=CursorFactory.createCursor(derivedClassesResults);
    try {
      while (_zCursor.moveToNext()) {
        SearchResult result=_zCursor.getCurrent();
{
          SNode classNode=(SNode)result.getNodePointer().getNode();
          Iterable<SNode> methodsOfSameKind;
          if (SNodeOperations.isInstanceOf(searchedNode,"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration")) {
            methodsOfSameKind=SLinkOperations.getTargets(classNode,"method",true);
          }
 else {
            methodsOfSameKind=SLinkOperations.getTargets(classNode,"staticMethod",true);
          }
{
            ICursor<SNode> _zCursor1=CursorFactory.createCursor(methodsOfSameKind);
            try {
              while (_zCursor1.moveToNext()) {
                SNode sMethod=_zCursor1.getCurrent();
                if (SPropertyOperations.getString(sMethod,"name").equals(SPropertyOperations.getString(searchedNode,"name")) && SLinkOperations.getCount(sMethod,"parameter") == SLinkOperations.getCount(searchedNode,"parameter")) {
                  if (BaseMethodDeclaration_Behavior.call_hasSameSignature_1204901126405(sMethod,searchedNode)) {
                    results.getSearchResults().add(new SearchResult(new SNodePointer(sMethod),"Overriding Methods"));
                  }
                }
              }
            }
  finally {
              _zCursor1.release();
            }
          }
        }
      }
    }
  finally {
      _zCursor.release();
    }
  }
}
