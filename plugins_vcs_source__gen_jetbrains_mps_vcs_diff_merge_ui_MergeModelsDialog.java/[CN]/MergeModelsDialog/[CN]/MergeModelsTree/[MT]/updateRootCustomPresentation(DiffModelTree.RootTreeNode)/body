{
  List<ModelChange> changes=(rootTreeNode.getRootId() == null ? ListSequence.<ModelChange>fromList(myMergeContext.getMetadataChanges()).<ModelChange>select(new ISelector<ModelChange,ModelChange>(){
    public ModelChange select(    ModelChange ch){
      return (ModelChange)ch;
    }
  }
).toListSequence() : myMergeContext.getChangesForRoot(rootTreeNode.getRootId()));
  changes=ListSequence.<ModelChange>fromList(changes).where(new IWhereFilter<ModelChange>(){
    public boolean accept(    ModelChange ch){
      return !(myMergeContext.isChangeResolved(ch));
    }
  }
).toListSequence();
  int conflictedCount=ListSequence.<ModelChange>fromList(changes).where(new IWhereFilter<ModelChange>(){
    public boolean accept(    ModelChange ch){
      return Sequence.<ModelChange>fromIterable(myMergeContext.getConflictedWith(ch)).isNotEmpty();
    }
  }
).count();
  int nonConflictedCount=ListSequence.<ModelChange>fromList(changes).count() - conflictedCount;
  ChangeType compositeChangeType=null;
  rootTreeNode.setTooltipText(generateUnresolvedChangesText(ListSequence.<ModelChange>fromList(changes).count(),conflictedCount));
  if (conflictedCount != 0) {
    compositeChangeType=ChangeType.CONFLICTED;
    rootTreeNode.setAdditionalText("with conflicts");
  }
 else {
    if (nonConflictedCount == 0) {
      if (rootTreeNode.getRootId() != null && myMergeContext.getResultModel().getNodeById(rootTreeNode.getRootId()) == null) {
        rootTreeNode.setText(String.format("<html><s>%s</s></html>",rootTreeNode.getText()));
      }
    }
 else {
      compositeChangeType=ChangeType.CHANGE;
      if (ListSequence.<ModelChange>fromList(changes).all(new IWhereFilter<ModelChange>(){
        public boolean accept(        ModelChange ch){
          return ch instanceof AddRootChange || ch instanceof DeleteRootChange;
        }
      }
)) {
        compositeChangeType=ListSequence.<ModelChange>fromList(changes).first().getType();
      }
      int myChangesCount=ListSequence.<ModelChange>fromList(changes).where(new IWhereFilter<ModelChange>(){
        public boolean accept(        ModelChange ch){
          return myMergeContext.isMyChange(ch);
        }
      }
).count();
      if (myChangesCount == nonConflictedCount) {
        rootTreeNode.setAdditionalText("local");
      }
 else       if (myChangesCount == 0) {
        rootTreeNode.setAdditionalText("remote");
      }
 else {
        rootTreeNode.setAdditionalText("both modified");
      }
    }
  }
  if (compositeChangeType != null) {
    rootTreeNode.setColor(ChangeColors.getForTree(compositeChangeType));
  }
}
