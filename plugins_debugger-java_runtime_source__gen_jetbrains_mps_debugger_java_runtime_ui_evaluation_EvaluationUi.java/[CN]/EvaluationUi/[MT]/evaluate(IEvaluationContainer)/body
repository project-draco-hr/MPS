{
  if (!(myDebugSession.getEvaluationProvider().canEvaluate())) {
    setErrorText("Program should be paused on breakpoint to evaluate");
    return;
  }
  try {
    final Class clazz=model.generateClass();
    setEvaluating(model);
    final ThreadReference thread=check_4q63yg_a0c0b0m(myDebugSession.getUiState().getThread());
    myDebugSession.getEventsProcessor().scheduleEvaluation(new _FunctionTypes._void_P0_E0(){
      public void invoke(){
        try {
          Evaluator evaluator=model.createEvaluatorInstance(clazz);
          IValueProxy evaluatedValue=evaluator.evaluate();
          if (evaluatedValue != null) {
            JavaValue value=ValueUtil.getInstance().fromJDI(evaluatedValue.getJDIValue(),thread);
            value.initSubvalues();
            setSuccess(value,model);
          }
 else {
            setFailure(null,"Evaluation returned null.",model);
          }
        }
 catch (        EvaluationException e) {
          setFailure(e,null,model);
        }
catch (        Throwable t) {
          setFailure(t,null,model);
          LOG.error(t);
        }
      }
    }
,thread);
  }
 catch (  InvalidEvaluatedExpressionException e) {
    setFailure(e.getCause(),null,model);
  }
catch (  InvocationTargetEvaluationException e) {
    setFailure(e.getCause(),null,model);
    LOG.error(e.getCause());
  }
catch (  EvaluationException e) {
    setFailure(e,null,model);
  }
catch (  Throwable t) {
    setFailure(t,null,model);
    LOG.error(t);
  }
}
