{
  ModelAccess.assertLegalRead();
  if (node == null)   return null;
synchronized (myLock) {
    SNodePointer nodePointer=new SNodePointer(node);
    List<Triplet<TypeCheckingContext,ITypeContextOwner,Integer>> contextWithOwners=myTypeCheckingContexts.get(nodePointer);
    if (contextWithOwners == null && !createIfAbsent)     return null;
    if (contextWithOwners == null) {
      contextWithOwners=new ArrayList<Triplet<TypeCheckingContext,ITypeContextOwner,Integer>>(4);
      myTypeCheckingContexts.put(nodePointer,contextWithOwners);
    }
    for (ListIterator<Triplet<TypeCheckingContext,ITypeContextOwner,Integer>> it=contextWithOwners.listIterator(); it.hasNext(); ) {
      Triplet<TypeCheckingContext,ITypeContextOwner,Integer> p=it.next();
      if (p.second() == owner) {
        TypeCheckingContext context=p.first();
        if (jetbrains.mps.util.SNodeOperations.isDisposed(context.getNode())) {
          removeContextForNode(nodePointer);
          LOG.error("Type Checking Context had a disposed node inside. Node: " + node + " model: "+ node.getModel());
          return getOrCreateContext(node,owner,createIfAbsent);
        }
        it.set(new Triplet<TypeCheckingContext,ITypeContextOwner,Integer>(p.first(),p.second(),p.third() + 1));
        return context;
      }
    }
    if (!createIfAbsent)     return null;
    TypeCheckingContext newTypeCheckingContext=owner.createTypecheckingContext(node,this);
    addModelListener(node);
    contextWithOwners.add(new Triplet<TypeCheckingContext,ITypeContextOwner,Integer>(newTypeCheckingContext,owner,1));
    if (contextWithOwners.size() > 100) {
      if (!myReported) {
        myReported=true;
        LOG.warning("Type checking context for node " + node.getPresentation() + " has too much owners");
      }
    }
    myTypeCheckingContexts.put(nodePointer,contextWithOwners);
    return newTypeCheckingContext;
  }
}
