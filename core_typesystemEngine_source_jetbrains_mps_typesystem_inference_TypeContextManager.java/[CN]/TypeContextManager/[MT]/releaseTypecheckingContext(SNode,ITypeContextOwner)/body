{
  ModelAccess.assertLegalRead();
  if (node == null)   return;
  final SModel model=node.getModel();
  final SNodeId rootNodeId=node.getContainingRoot().getNodeId();
  if (model == null)   return;
synchronized (myLock) {
    ConcurrentMap<SNodeId,List<TypecheckingContextHolder>> modelContexts=myTypeCheckingContexts.get(model);
    if (modelContexts == null)     return;
    List<TypecheckingContextHolder> contextWithOwners=modelContexts.get(rootNodeId);
    if (contextWithOwners == null)     return;
    for (ListIterator<TypecheckingContextHolder> it=contextWithOwners.listIterator(); it.hasNext(); ) {
      TypecheckingContextHolder contextHolder=it.next();
      ITypeContextOwner o=contextHolder.getOwner();
      if (o == contextOwner) {
        if (!contextOwner.reuseTypecheckingContext()) {
          contextHolder.release();
          if (!contextHolder.isActive()) {
            it.remove();
          }
        }
 else {
          contextHolder.release();
          if (!contextHolder.isActive()) {
            it.remove();
          }
        }
        break;
      }
    }
    if (contextWithOwners.isEmpty()) {
      modelContexts.remove(rootNodeId);
      if (modelContexts.isEmpty()) {
        myTypeCheckingContexts.remove(model);
        stopListening(model);
      }
    }
  }
}
