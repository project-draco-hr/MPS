{
  Deque<SNode> stack=DequeSequence.fromDeque(new LinkedList<SNode>());
  DequeSequence.fromDeque(stack).pushElement(startNode);
  while (DequeSequence.fromDeque(stack).isNotEmpty()) {
    SNode node=DequeSequence.fromDeque(stack).popElement();
    SModel ourModel=node.getModel();
    DequeSequence.fromDeque(stack).addSequence(ListSequence.fromList(SNodeOperations.getChildren(node)));
    Iterable<? extends SReference> refs=node.getReferences();
    List<SReference> newRefs=ListSequence.fromList(new ArrayList<SReference>());
    for (    SReference ref : Sequence.fromIterable(refs)) {
      if (!(ref instanceof DynamicReference)) {
        continue;
      }
      if (pass == 0) {
        if (ref.getRole().equals("baseMethodDeclaration")) {
          continue;
        }
        if (ref.getRole().equals("fieldDeclaration")) {
          continue;
        }
      }
 else       if (SNodeOperations.getConceptDeclaration(node) == SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.DotExpression")) {
        if (Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(SNodeOperations.cast(node,"jetbrains.mps.baseLanguage.structure.DotExpression"),"operand",true))).any(new IWhereFilter<SReference>(){
          public boolean accept(          SReference it){
            SReference ref=it;
            return ref instanceof DynamicReference;
          }
        }
)) {
          continue;
        }
      }
      SNode target=ref.getTargetNode();
      if (target == null) {
        continue;
      }
      SModelReference targetModel=target.getModel().getReference();
      SReference staticRef=StaticReference.create(ref.getRole(),node,target.getModel().getReference(),target.getNodeId());
      ListSequence.fromList(newRefs).addElement(staticRef);
    }
    if (ListSequence.fromList(newRefs).isNotEmpty()) {
      MapSequence.fromMap(result).put(node.getReference(),newRefs);
    }
  }
}
