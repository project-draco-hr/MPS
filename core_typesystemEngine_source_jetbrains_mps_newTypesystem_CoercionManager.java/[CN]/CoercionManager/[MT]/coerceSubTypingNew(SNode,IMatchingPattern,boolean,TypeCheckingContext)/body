{
  if (subtype == null)   return null;
  if (pattern.match(subtype))   return subtype;
  if (!CoerceUtil.canBeCoerced(subtype,pattern.getConceptFQName()))   return null;
  if (CoerceUtil.concept_MeetType.equals(subtype.getConcept())) {
    List<SNode> children=new ArrayList<SNode>(IterableUtil.asCollection(subtype.getChildren(CoerceUtil.link_MeetType_argument)));
    for (    SNode child : children) {
      SNode result=coerceSubTypingNew(child,pattern,isWeak,context);
      if (result != null)       return result;
    }
    return null;
  }
  if (CoerceUtil.concept_JoinType.equals(subtype.getConcept())) {
    List<SNode> children=new ArrayList<SNode>(IterableUtil.asCollection(subtype.getChildren(CoerceUtil.link_JoinType_argument)));
    SNode lcs=SubtypingUtil.createLeastCommonSupertype(children,context);
    return coerceSubTypingNew(lcs,pattern,isWeak,context);
  }
  return NodeReadAccessCasterInEditor.runReadTransparentAction(new Computable<SNode>(){
    @Override public SNode compute(){
      Pair<Boolean,SNode> answer=getCoerceCacheAnswer(subtype,pattern,isWeak);
      if (answer != null && answer.o1) {
        return answer.o2;
      }
      CoercionMatcher coercionMatcher=new CoercionMatcher(pattern);
      SNode result=searchInSuperTypes(subtype,coercionMatcher,isWeak);
      SubtypingCache subtypingCache=myTypeChecker.getSubtypingCache();
      if (subtypingCache != null) {
        subtypingCache.cacheCoerce(subtype,pattern,result,isWeak);
      }
      return result;
    }
  }
);
}
