{
  if (subtype == null)   return null;
  if (pattern.match(subtype))   return subtype;
  if (!CoerceUtil.canBeCoerced(subtype,pattern.getConceptFQName()))   return null;
  if ("jetbrains.mps.lang.typesystem.structure.MeetType".equals(subtype.getConcept().getId())) {
    List<SNode> children=((List)subtype.getChildren("argument"));
    for (    SNode child : children) {
      SNode result=coerceSubTypingNew(child,pattern,isWeak,context);
      if (result != null)       return result;
    }
    return null;
  }
  final TypeCheckingContext typeCheckingContext=context;
  if ("jetbrains.mps.lang.typesystem.structure.JoinType".equals(subtype.getConcept().getId())) {
    List<SNode> children=((List)subtype.getChildren("argument"));
    SNode lcs=SubtypingUtil.createLeastCommonSupertype(children,typeCheckingContext);
    return coerceSubTypingNew(lcs,pattern,isWeak,context);
  }
  return NodeReadAccessCasterInEditor.runReadTransparentAction(new Computable<SNode>(){
    public SNode compute(){
      Pair<Boolean,SNode> answer=getCoerceCacheAnswer(subtype,pattern,isWeak);
      if (answer != null && answer.o1) {
        return answer.o2;
      }
      CoercionMatcher coercionMatcher=new CoercionMatcher(pattern);
      SNode result=searchInSuperTypes(subtype,coercionMatcher,isWeak);
      SubtypingCache subtypingCache=myTypeChecker.getSubtypingCache();
      if (subtypingCache != null) {
        subtypingCache.cacheCoerce(subtype,pattern,result,isWeak);
      }
      return result;
    }
  }
);
}
