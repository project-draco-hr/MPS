{
  reset();
  for (  Generator generator : generators) {
    for (    SNode m : GenerationFacade.getOwnMappings(generator)) {
      myPriorityMap.put(m,new HashMap<SNode,PriorityData>());
    }
  }
  for (  Generator generator : generators) {
    GeneratorDescriptor descriptor=(GeneratorDescriptor)generator.getModuleDescriptor();
    List<MappingPriorityRule> rules;
    if (descriptorWorkingCopy != null && descriptorWorkingCopy.getGeneratorUID().equals(descriptor.getGeneratorUID())) {
      rules=descriptorWorkingCopy.getPriorityRules();
    }
 else {
      rules=descriptor.getPriorityRules();
    }
    for (    MappingPriorityRule rule : rules) {
      processRule(rule,generator);
    }
  }
  for (  SNode mapping : myPriorityMap.keySet()) {
    checkSelfLocking(mapping);
  }
  myCoherentMappings=PriorityMapUtil.joinIntersectingCoherentMappings(myCoherentMappings);
  PriorityMapUtil.makeLockedByAllCoherentIfLockedByOne(myCoherentMappings,myPriorityMap);
  PriorityMapUtil.makeLocksEqualsForCoherentMappings(myCoherentMappings,myPriorityMap,myConflictingRules);
  boolean need_more_passes=true;
  while (need_more_passes) {
    need_more_passes=false;
    iterate_all_mappings:     for (    SNode lockedMapping : myPriorityMap.keySet()) {
      while (true) {
        List<SNode> weakLockMappings=PriorityMapUtil.getWeakLockMappingsForLockedMapping(lockedMapping,myPriorityMap);
        if (weakLockMappings.isEmpty())         break;
        for (        SNode weakLockMapping : weakLockMappings) {
          PriorityMapUtil.replaceWeakLock(lockedMapping,weakLockMapping,myPriorityMap);
          checkSelfLocking(lockedMapping);
          List<SNode> lockedMappings_1=PriorityMapUtil.getLockedMappingsForLockMapping(lockedMapping,myPriorityMap);
          for (          SNode lockedMapping_1 : lockedMappings_1) {
            Map<SNode,PriorityData> locks_1=myPriorityMap.get(lockedMapping_1);
            PriorityData priorityDataToApply=locks_1.get(lockedMapping);
            boolean newLockAdded=PriorityMapUtil.addLock(lockedMapping_1,weakLockMapping,priorityDataToApply,myPriorityMap);
            checkSelfLocking(lockedMapping_1);
            if (newLockAdded) {
              if (myPriorityMap.get(lockedMapping_1).get(weakLockMapping).isWeak()) {
                need_more_passes=true;
                break iterate_all_mappings;
              }
            }
          }
        }
      }
    }
  }
  for (  Map<SNode,PriorityData> locks : myPriorityMap.values()) {
    for (    PriorityData priorityData : locks.values()) {
      if (!priorityData.isStrict()) {
        throw new RuntimeException("Unexpected weak priority");
      }
    }
  }
  List<List<SNode>> mappingSets=createMappingSets();
  for (  Map<SNode,PriorityData> grtPriMappings : myPriorityMap.values()) {
    for (    PriorityData priorityData : grtPriMappings.values()) {
      myConflictingRules.addAll(priorityData.myCauseRules);
    }
  }
  return mappingSets;
}
