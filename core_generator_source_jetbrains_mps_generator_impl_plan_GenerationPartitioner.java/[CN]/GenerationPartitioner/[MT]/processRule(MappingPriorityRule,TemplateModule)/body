{
  MappingConfig_AbstractRef left=rule.getLeft();
  MappingConfig_AbstractRef right=rule.getRight();
  if (left == null || right == null)   return;
  Collection<TemplateMappingConfiguration> lhs=getMappingsFromRef(left,generator,generator.getAlias());
  Collection<TemplateMappingConfiguration> rhs=getMappingsFromRef(right,generator,generator.getAlias());
  if (lhs.isEmpty() || rhs.isEmpty()) {
    final String lang=generator.getSourceLanguage().getNamespace();
    if (lhs.isEmpty() && rhs.isEmpty()) {
      final String msg=String.format("Generator for language %s defines priority rule %s, both sides of the rule miss mapping configuration. The rule doesn't affect the generation and is ignored.",lang,rule);
      myConflicts.registerInvalid(generator.getReference(),msg,rule);
    }
 else {
      final String msg=String.format("Generator for language %s defines invalid priority rule %s, with no mapping configurations specified at one side. The rule is ignored.",lang,rule);
      myConflicts.registerInvalid(generator.getReference(),msg,rule);
    }
    return;
  }
switch (rule.getType()) {
case STRICTLY_TOGETHER:
    Set<TemplateMappingConfiguration> coherentMappings=new HashSet<TemplateMappingConfiguration>(rhs);
  coherentMappings.addAll(lhs);
mySolver.registerCoherent(coherentMappings,rule);
return;
case STRICTLY_BEFORE:
case BEFORE_OR_TOGETHER:
mySolver.establishDependency(lhs,rhs,rule);
return;
case AFTER_OR_TOGETHER:
case STRICTLY_AFTER:
mySolver.establishDependency(rhs,lhs,rule);
return;
default :
throw new IllegalStateException(String.valueOf(rule.getType()));
}
}
