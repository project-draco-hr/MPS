{
  MappingConfig_AbstractRef left=rule.getLeft();
  MappingConfig_AbstractRef right=rule.getRight();
  if (left == null || right == null)   return;
  final RuleHelper lhsHelper=new RuleHelper(generator,left);
  final RuleHelper rhsHelper=new RuleHelper(generator,right);
  Collection<TemplateMappingConfiguration> lhs=lhsHelper.getAllMappings();
  Collection<TemplateMappingConfiguration> rhs=rhsHelper.getAllMappings();
  if (lhs.isEmpty() || rhs.isEmpty()) {
    final String lang=generator.getSourceLanguage().getNamespace();
    if (lhs.isEmpty() && rhs.isEmpty()) {
      final String msg=String.format("Generator for language %s defines priority rule %s, both sides of the rule miss mapping configuration. The rule doesn't affect the generation and is ignored.",lang,rule);
      myConflicts.registerInvalid(generator.getModuleReference(),msg,rule);
    }
 else {
      final String msg=String.format("Generator for language %s defines invalid priority rule %s, with no mapping configurations specified at one side. The rule is ignored.",lang,rule);
      myConflicts.registerInvalid(generator.getModuleReference(),msg,rule);
    }
    return;
  }
  for (  TemplateModule l : lhsHelper.getInvolvedGenerators()) {
    for (    TemplateModule r : rhsHelper.getInvolvedGenerators()) {
      myExplicitDependencies.add(new Pair<TemplateModule,TemplateModule>(l,r));
    }
  }
switch (rule.getType()) {
case STRICTLY_TOGETHER:
    Set<TemplateMappingConfiguration> coherentMappings=new HashSet<TemplateMappingConfiguration>(rhs);
  coherentMappings.addAll(lhs);
mySolver.registerCoherent(coherentMappings,rule);
return;
case STRICTLY_BEFORE:
case BEFORE_OR_TOGETHER:
mySolver.establishDependency(lhs,rhs,rule);
return;
case AFTER_OR_TOGETHER:
case STRICTLY_AFTER:
mySolver.establishDependency(rhs,lhs,rule);
return;
default :
throw new IllegalStateException(String.valueOf(rule.getType()));
}
}
