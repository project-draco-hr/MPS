{
  Map<SNode,Map<SNode,EquationInfo>> map=sub ? mySubToSuper : mySuperToSub;
  SubTyping subTyping=new SubTyping(myState);
  boolean stateChanged=false;
  for (  SNode node : new HashSet<SNode>(map.keySet())) {
    Map<SNode,EquationInfo> otherMap=map.get(node);
    if (otherMap == null) {
      continue;
    }
    Set<SNode> concreteTypes=getConcrete(otherMap.keySet(),shallow);
    if (concreteTypes == null || concreteTypes.isEmpty()) {
      continue;
    }
    Set<SNode> expandedConcreteTypes=myState.getEquations().expandSet(concreteTypes);
    if (TypesUtil.isVariable(node)) {
      SNode type=sub ? subTyping.createMeet(expandedConcreteTypes) : subTyping.createLCS(expandedConcreteTypes);
      for (      SNode concreteType : expandedConcreteTypes) {
        if (sub) {
          removeAndTrack(node,concreteType);
        }
 else {
          removeAndTrack(concreteType,node);
        }
      }
      myState.addEquation(node,type,null);
    }
 else     if (myState.isConcrete(node,shallow)) {
      for (      SNode concreteType : expandedConcreteTypes) {
        EquationInfo info=map.get(node).get(concreteType);
        if (sub) {
          removeAndTrack(node,concreteType);
          myState.addRelation(node,concreteType,myKind,info);
        }
 else {
          removeAndTrack(concreteType,node);
          myState.addRelation(concreteType,node,myKind,info);
        }
      }
    }
    stateChanged=true;
  }
  return stateChanged;
}
