{
  reset();
  for (  Generator generator : generators) {
    myAllMappings.addAll(generator.getOwnMappings());
  }
  for (  MappingConfiguration mapping : myAllMappings) {
    if (!myPriorityMap.containsKey(mapping)) {
      myPriorityMap.put(mapping,new HashMap<MappingConfiguration,PriorityData>());
    }
  }
  for (  Generator generator : generators) {
    GeneratorDescriptor descriptor=(GeneratorDescriptor)generator.getModuleDescriptor();
    List<MappingPriorityRule> rules;
    if (descriptorWorkingCopy != null && descriptorWorkingCopy.getGeneratorUID().equals(descriptor.getGeneratorUID())) {
      rules=descriptorWorkingCopy.getPriorityRules();
    }
 else {
      rules=descriptor.getPriorityRules();
    }
    for (    MappingPriorityRule rule : rules) {
      processRule(rule,generator);
    }
  }
{
    Collection<Map<MappingConfiguration,PriorityData>> grtPriMappings=myPriorityMap.values();
    for (    MappingConfiguration processedMapping : processedMappings) {
      for (      Map<MappingConfiguration,PriorityData> grtPriMapping : grtPriMappings) {
        grtPriMapping.remove(processedMapping);
      }
    }
    for (    MappingConfiguration processedMapping : processedMappings) {
      if (myPriorityMap.containsKey(processedMapping) && !myPriorityMap.get(processedMapping).isEmpty()) {
        for (        PriorityData priorityData : myPriorityMap.get(processedMapping).values()) {
          myConflictingRules.add(priorityData.causeRule);
        }
      }
      myPriorityMap.remove(processedMapping);
    }
    for (    MappingConfiguration deferredMapping : deferredMappings) {
      if (!myPriorityMap.containsKey(deferredMapping)) {
        myPriorityMap.put(deferredMapping,new HashMap<MappingConfiguration,PriorityData>());
      }
    }
  }
  List<List<MappingConfiguration>> mappingSets=createMappingSets();
  for (  Map<MappingConfiguration,PriorityData> grtPriMappings : myPriorityMap.values()) {
    for (    PriorityData priorityData : grtPriMappings.values()) {
      if (!myConflictingRules.contains(priorityData.causeRule)) {
        myConflictingRules.add(priorityData.causeRule);
      }
    }
  }
  return mappingSets;
}
