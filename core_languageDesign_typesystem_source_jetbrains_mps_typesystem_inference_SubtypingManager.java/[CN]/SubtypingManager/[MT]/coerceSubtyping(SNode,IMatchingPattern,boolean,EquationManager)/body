{
  if (subtype == null)   return null;
  if (pattern.match(subtype))   return subtype;
  if ("jetbrains.mps.lang.typesystem.structure.MeetType".equals(subtype.getConceptFqName())) {
    List<SNode> children=subtype.getChildren("argument");
    for (    SNode child : children) {
      SNode result=coerceSubtyping(child,pattern,isWeak,equationManager);
      if (result != null)       return result;
    }
    return null;
  }
  SubtypingCache cache=myTypeChecker.getSubtypingCache();
  if (cache != null) {
    Pair<Boolean,SNode> nodePair=cache.getCoerced(subtype,pattern,isWeak);
    if (nodePair.o1) {
      return nodePair.o2;
    }
  }
  cache=myTypeChecker.getGlobalSubtypingCache();
  if (cache != null) {
    Pair<Boolean,SNode> nodePair=cache.getCoerced(subtype,pattern,isWeak);
    if (nodePair.o1) {
      return nodePair.o2;
    }
  }
  CoersionMatcher coersionMatcher=new CoersionMatcher(pattern);
  boolean success=searchInSupertypes(NodeWrapper.fromNode(subtype,equationManager,true),coersionMatcher,equationManager,null,isWeak);
  SNode result;
  if (!success) {
    result=null;
  }
 else {
    result=coersionMatcher.getResult();
  }
  SubtypingCache subtypingCache=myTypeChecker.getSubtypingCache();
  if (subtypingCache != null) {
    subtypingCache.addCacheEntry(subtype,pattern,result,isWeak);
  }
  subtypingCache=myTypeChecker.getGlobalSubtypingCache();
  if (subtypingCache != null) {
    subtypingCache.addCacheEntry(subtype,pattern,result,isWeak);
  }
  return result;
}
