{
  if (inputModels.isEmpty()) {
    return true;
  }
  final IOperationContext invocationContext=inputModels.get(0).o2;
  final DefaultMessageHandler messages=new DefaultMessageHandler(invocationContext.getProject());
  final GenerationSettings settings=GenerationSettings.getInstance();
  final boolean saveTransientModels;
  if (settings.isSaveTransientModels()) {
    Object[] options={"Save Transient Models","Not this time","No, and cancel saving"};
    int option=JOptionPane.showOptionDialog(invocationContext.getMainFrame(),"Would you like to save transient models?","",JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[0]);
    if (option == 0) {
      saveTransientModels=true;
    }
 else {
      saveTransientModels=false;
      if (option == 2) {
        settings.setSaveTransientModels(false);
      }
      if (option == -1) {
        return false;
      }
    }
  }
 else {
    saveTransientModels=false;
  }
  if (DumbService.getInstance(project).isDumb()) {
    DumbService.getInstance(project).showDumbModeNotification("Generation is not available until indices are built.");
    return false;
  }
  if (!skipRequirementsGeneration && generateRequirements(settings)) {
    boolean wasSaveTransientModels=settings.isSaveTransientModels();
    try {
      final Set<SModelDescriptor> requirements=new LinkedHashSet<SModelDescriptor>();
      ModelAccess.instance().runReadAction(new Runnable(){
        public void run(){
          for (          Pair<SModelDescriptor,IOperationContext> inputModel : inputModels) {
            requirements.addAll(getModelsToGenerateBeforeGeneration(inputModel.o1,inputModel.o2));
          }
        }
      }
);
      for (      Pair<SModelDescriptor,IOperationContext> inputModel : inputModels) {
        requirements.remove(inputModel.o1);
      }
      if (!requirements.isEmpty()) {
        int result=2;
        if (settings.getGenerateRequirementsPolicy() == GenerationSettings.GenerateRequirementsPolicy.ASK) {
          final StringBuffer message=new StringBuffer("The following models might be required for generation\n" + "but aren't generated. Do you want to generate them?\n");
          for (          SModelDescriptor sm : requirements) {
            message.append("\n").append(sm.getSModelReference().getSModelFqName());
          }
          if (IdeMain.getTestMode() != TestMode.CORE_TEST) {
            DialogWrapper questionDialog=new GenerateRequirementsDialog(project,settings,message.toString());
            questionDialog.show();
            result=questionDialog.getExitCode();
          }
        }
 else {
          result=0;
        }
        if (result == 1)         return false;
        if (result == 0) {
          generateModels(invocationContext,new ArrayList<SModelDescriptor>(requirements),getDefaultGenerationHandler(),rebuildAll,true);
        }
      }
    }
  finally {
      settings.setSaveTransientModels(wasSaveTransientModels);
    }
  }
  ModelAccess.instance().runWriteActionInCommand(new Runnable(){
    public void run(){
      SModelRepository.getInstance().saveAll();
    }
  }
);
  showMessageView(project);
  IdeEventQueue.getInstance().flushQueue();
  final boolean[] result=new boolean[]{false};
  ProgressManager.getInstance().run(new Modal(invocationContext.getProject(),"Generation",true){
    public void run(    @NotNull ProgressIndicator progress){
      GeneratorManager generatorManager=project.getComponent(GeneratorManager.class);
      result[0]=generatorManager.generateModels(inputModels,generationHandler,progress,messages,saveTransientModels,rebuildAll);
    }
  }
);
  return result[0];
}
