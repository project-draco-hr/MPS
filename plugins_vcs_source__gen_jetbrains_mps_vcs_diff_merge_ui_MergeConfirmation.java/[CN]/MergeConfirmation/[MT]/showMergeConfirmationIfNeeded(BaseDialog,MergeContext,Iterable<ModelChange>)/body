{
  List<ModelChange> changes=Sequence.fromIterable(allRelevantChanges).where(new IWhereFilter<ModelChange>(){
    public boolean accept(    ModelChange ch){
      return !(mergeContext.isChangeResolved(ch));
    }
  }
).toListSequence();
  Iterable<ModelChange> conflictedChanges=ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>(){
    public boolean accept(    ModelChange ch){
      return Sequence.fromIterable(mergeContext.getConflictedWith(ch)).isNotEmpty();
    }
  }
);
  if (Sequence.fromIterable(conflictedChanges).count() != 0) {
    return showUnresolvedConflictsConfirmation(dialog,Sequence.fromIterable(conflictedChanges).count());
  }
 else   if (ListSequence.fromList(changes).count() != 0) {
    return showUnresolvedChangesConfirmation(dialog,ListSequence.fromList(changes).count());
  }
  return SAVE_AS_IS;
}
