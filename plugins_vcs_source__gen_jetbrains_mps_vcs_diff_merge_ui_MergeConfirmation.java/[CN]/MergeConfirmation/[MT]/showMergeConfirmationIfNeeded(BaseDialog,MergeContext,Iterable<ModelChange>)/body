{
  List<ModelChange> changes=Sequence.<ModelChange>fromIterable(allRelevantChanges).where(new IWhereFilter<ModelChange>(){
    public boolean accept(    ModelChange ch){
      return !(mergeContext.isChangeResolved(ch));
    }
  }
).toListSequence();
  Iterable<ModelChange> conflictedChanges=ListSequence.<ModelChange>fromList(changes).where(new IWhereFilter<ModelChange>(){
    public boolean accept(    ModelChange ch){
      return Sequence.<ModelChange>fromIterable(mergeContext.getConflictedWith(ch)).isNotEmpty();
    }
  }
);
  if (Sequence.<ModelChange>fromIterable(conflictedChanges).count() != 0) {
    return showUnresolvedConflictsConfirmation(dialog,Sequence.<ModelChange>fromIterable(conflictedChanges).count());
  }
 else   if (ListSequence.<ModelChange>fromList(changes).count() != 0) {
    return showUnresolvedChangesConfirmation(dialog,ListSequence.<ModelChange>fromList(changes).count());
  }
  return SAVE_AS_IS;
}
