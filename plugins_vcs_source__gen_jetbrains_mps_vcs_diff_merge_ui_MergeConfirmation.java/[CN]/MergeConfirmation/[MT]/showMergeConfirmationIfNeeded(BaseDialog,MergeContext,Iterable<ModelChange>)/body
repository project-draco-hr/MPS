{
  List<ModelChange> changes=Sequence.fromIterable(allRelevantChanges).where(new IWhereFilter<ModelChange>(){
    public boolean accept(    ModelChange ch){
      return !(mergeContext.isChangeResolved(ch));
    }
  }
).toListSequence();
  Iterable<ModelChange> conflictedChanges=ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>(){
    public boolean accept(    ModelChange ch){
      return Sequence.fromIterable(mergeContext.getConflictedWith(ch)).isNotEmpty();
    }
  }
);
  if (Sequence.fromIterable(conflictedChanges).count() != 0) {
    if (Messages.showYesNoDialog(dialog,String.format("You have %s left. You should resolve them manually.\n" + "Are you sure want to close merge roots dialog without resolving them?",NameUtil.formatNumericalString(Sequence.fromIterable(conflictedChanges).count(),"unresolved conflicting change")),"Unresolved Conflicting Changes",Messages.getWarningIcon()) == 0) {
      return SAVE_AS_IS;
    }
 else {
      return RETURN;
    }
  }
 else   if (ListSequence.fromList(changes).count() != 0) {
    int answer=Messages.showYesNoCancelDialog(dialog,String.format("You have %s left. Do you want to resolve them automatically?",NameUtil.formatNumericalString(ListSequence.fromList(changes).count(),"unresolved change")),"Unresolved Changes",Messages.getQuestionIcon());
    if (answer == 0) {
      return RESOLVE_AUTOMATICALLY;
    }
 else     if (answer == 1) {
      return SAVE_AS_IS;
    }
 else {
      return RETURN;
    }
  }
  return SAVE_AS_IS;
}
