{
  myReadyRules.clear();
  final BlockedReductionsData ruleBlocks=myGenerator.getBlockedReductionsData();
  final FastNodeFinder nodeFinder=((jetbrains.mps.smodel.SModelInternal)inputModel).getFastNodeFinder();
  for (  TemplateWeavingRule rule : rules) {
    String applicableConcept=rule.getApplicableConcept();
    if (applicableConcept == null) {
      myGenerator.getLogger().error(rule.getRuleNode(),"rule has no applicable concept defined");
      continue;
    }
    boolean includeInheritors=rule.applyToInheritors();
    for (    SNode applicableNode : nodeFinder.getNodes(applicableConcept,includeInheritors)) {
      if (ruleBlocks.isWeavingBlocked(applicableNode,rule)) {
        continue;
      }
      QueryExecutionContext executionContext=myGenerator.getExecutionContext(applicableNode);
      if (executionContext == null) {
        continue;
      }
      TemplateExecutionEnvironment environment=new TemplateExecutionEnvironmentImpl(new TemplateProcessor(myGenerator),executionContext);
      try {
        DefaultTemplateContext context=new DefaultTemplateContext(applicableNode);
        if (executionContext.isApplicable(rule,environment,context)) {
          myReadyRules.add(new ArmedWeavingRule(rule,environment,applicableNode));
          ruleBlocks.blockWeaving(applicableNode,rule);
        }
      }
 catch (      GenerationCanceledException ex) {
        throw ex;
      }
catch (      GenerationFailureException ex) {
        throw ex;
      }
catch (      GenerationException ex) {
        myGenerator.getLogger().error(rule.getRuleNode(),"internal error: " + ex.toString());
      }
    }
  }
}
