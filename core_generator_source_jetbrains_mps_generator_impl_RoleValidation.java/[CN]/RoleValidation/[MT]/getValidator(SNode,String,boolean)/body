{
  if (child && RuleUtil.link_BaseConcept_attrs_name.equals(role)) {
    return successValidatorMany;
  }
  final SConcept concept=sourceNode.getConcept();
  String conceptFQName=concept.getQualifiedName();
  Map<String,RoleValidator> vmap=validators.get(conceptFQName);
  if (vmap == null) {
    validators.put(conceptFQName,vmap=new HashMap<String,RoleValidator>());
  }
  RoleValidator validator=vmap.get(role);
  if (validator != null) {
    return validator;
  }
  SAbstractLink link=concept.getLink(role);
  if (link == null || link.isReference() == child) {
    String relationKind=child ? "child" : "referent";
    String msg;
    if (link == null) {
      msg=String.format("concept '%s' cannot have %s with role '%s'",concept.getQualifiedName(),relationKind,role);
    }
 else {
      msg=String.format("%s '%s' in concept '%s' doesn't match declared kind:%s",relationKind,role,concept.getQualifiedName(),link.isReference() ? "referent" : "child");
    }
    Status s=new Status(msg);
    validator=new RoleValidator(s);
  }
 else {
    if (!myShowBadChildWarning) {
      validator=link.isMultiple() ? successValidatorMany : successValidatorOne;
    }
 else {
      validator=new AcceptableTargetValidator(link);
    }
  }
  vmap.put(role,validator);
  return validator;
}
