{
  Set<SNode> nodes=subtypingGraphVertices();
  for (  SNode node2 : nodes) {
    for (    SNode node1 : nodes) {
      for (      SNode node3 : nodes) {
        if (node1 == node2 || node2 == node3 || node1 == node3)         continue;
        Map<SNode,SNode> supertypes1=mySubtypesToSupertypesMap.get(node1);
        if (supertypes1 == null)         continue;
        Map<SNode,SNode> supertypes2=mySubtypesToSupertypesMap.get(node2);
        if (supertypes2 == null)         continue;
        if (supertypes1.keySet().contains(node2) && supertypes2.keySet().contains(node3)) {
          mySubtypesToSupertypesMap.get(node1).put(node3,supertypes1.get(node2));
          mySupertypesToSubtypesMap.get(node3).put(node1,supertypes1.get(node2));
        }
      }
    }
  }
  for (  SNode node : subtypingGraphVertices()) {
    if (node instanceof RuntimeTypeVariable)     continue;
    Map<SNode,SNode> supertypes=mySubtypesToSupertypesMap.get(node);
    if (supertypes == null)     continue;
    for (    SNode supertype : new HashSet<SNode>(supertypes.keySet())) {
      if (supertype instanceof RuntimeTypeVariable)       continue;
      addInequation(node,supertype,supertypes.get(supertype));
      supertypes.remove(supertype);
      mySupertypesToSubtypesMap.get(supertype).remove(node);
    }
  }
  for (  SNode node : subtypingGraphVertices()) {
    Map<SNode,SNode> supertypes=mySubtypesToSupertypesMap.get(node);
    if (supertypes == null)     continue;
    for (    SNode supertype : new HashSet<SNode>(supertypes.keySet())) {
      Map<SNode,SNode> supertypesSupertypes=mySubtypesToSupertypesMap.get(supertype);
      if (supertypesSupertypes == null)       continue;
      for (      SNode supertypesSubtype : supertypesSupertypes.keySet()) {
        if (supertypesSubtype == node) {
          addEquation(node,supertype,supertypesSupertypes.get(supertypesSubtype));
        }
      }
    }
  }
  for (  SNode node : subtypingGraphVertices()) {
    if (node instanceof RuntimeTypeVariable) {
      Map<SNode,SNode> subtypes=mySupertypesToSubtypesMap.get(node);
      if (subtypes == null)       continue;
      Set<SNode> concreteSubtypes=new HashSet<SNode>();
      Set<SNode> nodesToCheck=new HashSet<SNode>();
      for (      SNode subtype : new HashSet<SNode>(subtypes.keySet())) {
        if (subtype instanceof RuntimeTypeVariable) {
          continue;
        }
        concreteSubtypes.add(subtype);
        nodesToCheck.add(subtypes.get(subtype));
        subtypes.remove(subtype);
        mySubtypesToSupertypesMap.get(subtype).remove(node);
      }
      SNode nodeToCheck=nodesToCheck.isEmpty() ? null : nodesToCheck.iterator().next();
      Set<SNode> lcs=SubtypingManager.lowestCommonSupertypes(concreteSubtypes);
      if (lcs.isEmpty()) {
        TypeChecker.reportTypeError(nodeToCheck,"can't find common supertype");
      }
 else {
        addEquation(node,lcs.iterator().next(),nodeToCheck);
      }
    }
  }
  for (  SNode node : subtypingGraphVertices()) {
    if (node instanceof RuntimeTypeVariable) {
      Map<SNode,SNode> supertypes=mySubtypesToSupertypesMap.get(node);
      if (supertypes == null)       continue;
      if (supertypes.size() == 1) {
        SNode supertype=supertypes.keySet().iterator().next();
        Map<SNode,SNode> subtypes=mySupertypesToSubtypesMap.get(node);
        if (subtypes == null || subtypes.isEmpty()) {
          supertypes.remove(supertype);
          mySupertypesToSubtypesMap.get(supertype).remove(node);
          addEquation(supertype,node,supertypes.get(supertype));
        }
      }
    }
  }
}
