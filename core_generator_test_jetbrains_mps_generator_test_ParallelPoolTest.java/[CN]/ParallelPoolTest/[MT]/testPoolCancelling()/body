{
  int cores=Runtime.getRuntime().availableProcessors();
  if (cores < 3) {
    return;
  }
  long amountFor2secs=get2SecsOperation();
  long start=System.currentTimeMillis();
  GenerationTaskPool pool=new GenerationTaskPool(new EmptyProgressMonitor(){
    @Override public boolean isCanceled(){
      return true;
    }
  }
,4);
  final CustomTask[] generationTasks=createTasks(amountFor2secs * 4,4,pool);
  for (  GenerationTask t : generationTasks) {
    pool.addTask(t);
  }
  boolean canceledExc=false;
  try {
    Thread.sleep(1000);
    pool.waitForCompletion();
  }
 catch (  GenerationCanceledException e) {
    canceledExc=true;
  }
catch (  GenerationFailureException e) {
  }
catch (  InterruptedException e) {
  }
  Assert.assertTrue(canceledExc);
  long end=System.currentTimeMillis();
  for (  CustomTask t : generationTasks) {
    Assert.assertTrue("task should be cancelled",t.isCancelled());
    Assert.assertFalse("task should not be finished",t.isFinished());
  }
  LOG.info("Total " + (end - start) / 1000. + " seconds, when cancelled after 1 sec.");
  Assert.assertTrue((end - start) < 1500 && (end - start) > 970);
  pool.dispose();
}
