{
  final ProgressMonitor monitor=new ProgressMonitorAdapter(indicator);
  monitor.start("Resolving...",ListSequence.fromList(myConflictedModelFiles).count());
  try {
    for (    final VirtualFile file : ListSequence.fromList(myConflictedModelFiles)) {
      monitor.step(file.getCanonicalPath());
      MergeData mergeData=null;
      try {
        mergeData=myProvider.loadRevisions(file);
      }
 catch (      VcsException e) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Error loading revisions to merge",e);
        }
      }
      final IFile iFile=FileSystem.getInstance().getFileByPath(file.getPath());
      final Wrappers._T<String> ext=new Wrappers._T<String>(file.getExtension());
      if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
        ext.value=MPSExtentions.MODEL;
      }
      final SModel baseModel=PersistenceUtil.loadModel(mergeData.ORIGINAL,ext.value);
      final SModel mineModel=PersistenceUtil.loadModel(mergeData.CURRENT,ext.value);
      final SModel repoModel=PersistenceUtil.loadModel(mergeData.LAST,ext.value);
      final Wrappers._T<MergeSession> mergeSession=new Wrappers._T<MergeSession>(null);
      ProjectHelper.getModelAccess(myProject).runReadAction(new Runnable(){
        public void run(){
          mergeSession.value=MergeSession.createMergeSession(baseModel,mineModel,repoModel);
        }
      }
);
      int conflictingChangesCount=Sequence.fromIterable(mergeSession.value.getAllChanges()).where(new IWhereFilter<ModelChange>(){
        public boolean accept(        ModelChange c){
          return Sequence.fromIterable(mergeSession.value.getConflictedWith(c)).isNotEmpty();
        }
      }
).count();
      if (conflictingChangesCount != 0) {
        if (LOG.isInfoEnabled()) {
          LOG.info("there are still conflicted changes in " + SModelOperations.getModelName(baseModel));
        }
        monitor.advance(1);
        if (monitor.isCanceled()) {
          return;
        }
        continue;
      }
      if (LOG.isInfoEnabled()) {
        LOG.info("no conflicted changes in " + SModelOperations.getModelName(baseModel));
      }
      ProjectHelper.getModelAccess(myProject).runWriteInEDT(new Runnable(){
        public void run(){
          mergeSession.value.applyChanges(mergeSession.value.getAllChanges());
          SModel resultModel=mergeSession.value.getResultModel();
          if (resultModel == null) {
          }
 else           if (mergeSession.value.hasIdsToRestore()) {
            if (LOG.isInfoEnabled()) {
              LOG.info(String.format("%s: node id duplication detected, should merge in UI.",SModelOperations.getModelName(baseModel)));
            }
          }
 else {
            String resultContent;
            if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
              resultContent=PersistenceUtil.savePerRootModel(resultModel,file.getExtension().equals(MPSExtentions.MODEL_HEADER));
            }
 else {
              resultContent=PersistenceUtil.saveModel(resultModel,ext.value);
            }
            try {
              file.setBinaryContent(resultContent.getBytes(FileUtil.DEFAULT_CHARSET));
            }
 catch (            IOException e) {
              if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("",e);
              }
            }
            check_2bxr1q_a4a0c0a0a81a0a2a7g(mySession,file);
            VcsDirtyScopeManager.getInstance(myProject).fileDirty(file);
          }
        }
      }
);
      monitor.advance(1);
      if (monitor.isCanceled()) {
        return;
      }
    }
  }
  finally {
    monitor.done();
  }
}
