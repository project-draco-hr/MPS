{
  final ProgressMonitor monitor=new ProgressMonitorAdapter(indicator);
  monitor.start("Resolving...",ListSequence.fromList(myConflictedModelFiles).count());
  final ModelAccess ma=ProjectHelper.getModelAccess(myProject);
  try {
    for (    final VirtualFile file : ListSequence.fromList(myConflictedModelFiles)) {
      monitor.step(file.getCanonicalPath());
      MergeData mergeData=null;
      try {
        mergeData=myProvider.loadRevisions(file);
      }
 catch (      VcsException e) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Error loading revisions to merge",e);
        }
      }
      final IFile iFile=FileSystem.getInstance().getFileByPath(file.getPath());
      final Wrappers._T<String> ext=new Wrappers._T<String>(file.getExtension());
      if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
        ext.value=MPSExtentions.MODEL;
      }
      final SModel baseModel=loadModel(mergeData.ORIGINAL,ext.value);
      final SModel mineModel=loadModel(mergeData.CURRENT,ext.value);
      final SModel repoModel=loadModel(mergeData.LAST,ext.value);
      if (baseModel == null || mineModel == null || repoModel == null) {
        continue;
      }
      final Wrappers._T<MergeSession> mergeSession=new Wrappers._T<MergeSession>(null);
      ma.runReadAction(new Runnable(){
        public void run(){
          mergeSession.value=MergeSession.createMergeSession(baseModel,mineModel,repoModel);
        }
      }
);
      int conflictingChangesCount=Sequence.fromIterable(mergeSession.value.getAllChanges()).where(new IWhereFilter<ModelChange>(){
        public boolean accept(        ModelChange c){
          return Sequence.fromIterable(mergeSession.value.getConflictedWith(c)).isNotEmpty();
        }
      }
).count();
      if (conflictingChangesCount != 0) {
        if (LOG.isInfoEnabled()) {
          LOG.info("there are still conflicted changes in " + SModelOperations.getModelName(baseModel));
        }
        monitor.advance(1);
        if (monitor.isCanceled()) {
          return;
        }
        continue;
      }
      if (LOG.isInfoEnabled()) {
        LOG.info("no conflicting changes in " + SModelOperations.getModelName(baseModel));
      }
      final Wrappers._T<String> resultContent=new Wrappers._T<String>(null);
      ma.runReadAction(new Runnable(){
        public void run(){
          mergeSession.value.applyChanges(mergeSession.value.getAllChanges());
          SModel resultModel=mergeSession.value.getResultModel();
          if (resultModel == null) {
          }
 else           if (mergeSession.value.hasIdsToRestore()) {
            if (LOG.isInfoEnabled()) {
              LOG.info(String.format("%s: node id duplication detected, should merge in UI.",SModelOperations.getModelName(baseModel)));
            }
          }
 else {
            try {
              if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
                resultContent.value=PersistenceUtil.savePerRootModel(resultModel,file.getExtension().equals(MPSExtentions.MODEL_HEADER));
              }
 else {
                resultContent.value=PersistenceUtil.saveModel(resultModel,ext.value);
              }
            }
 catch (            Throwable error) {
              if (LOG.isEnabledFor(Level.WARN)) {
                LOG.warn("Cannot save merge resulting model " + SModelOperations.getModelName(resultModel),error);
              }
            }
          }
        }
      }
);
      if (resultContent.value != null) {
        ThreadUtils.runInUIThreadAndWait(new Runnable(){
          public void run(){
            ma.runWriteAction(new Runnable(){
              public void run(){
                try {
                  file.setBinaryContent(resultContent.value.getBytes(FileUtil.DEFAULT_CHARSET));
                  check_2bxr1q_a1a0a0a0a0a0a0w0a0d0k6(mySession,file);
                  VcsDirtyScopeManager.getInstance(myProject).fileDirty(file);
                  ListSequence.fromList(myResolvedModelFiles).addElement(file);
                }
 catch (                IOException e) {
                  if (LOG.isEnabledFor(Level.ERROR)) {
                    LOG.error("Cannot save merge result into " + file.getPath(),e);
                  }
                }
              }
            }
);
          }
        }
);
      }
      monitor.advance(1);
      if (monitor.isCanceled()) {
        return;
      }
    }
  }
  finally {
    monitor.done();
  }
}
