{
  final ProgressMonitor monitor=new ProgressMonitorAdapter(indicator);
  monitor.start("Resolving...",ListSequence.fromList(myConflictedModelFiles).count());
  final ModelAccess ma=ProjectHelper.getModelAccess(myProject);
  try {
    for (    final VirtualFile file : ListSequence.fromList(myConflictedModelFiles)) {
      monitor.step(file.getCanonicalPath());
      MergeData mergeData=null;
      try {
        mergeData=myProvider.loadRevisions(file);
      }
 catch (      VcsException e) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Error loading revisions to merge",e);
        }
      }
      final IFile iFile=FileSystem.getInstance().getFileByPath(file.getPath());
      final Wrappers._T<String> ext=new Wrappers._T<String>(file.getExtension());
      if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
        ext.value=MPSExtentions.MODEL;
      }
      final SModel baseModel=loadModel(mergeData.ORIGINAL,ext.value);
      final SModel mineModel=loadModel(mergeData.CURRENT,ext.value);
      final SModel repoModel=loadModel(mergeData.LAST,ext.value);
      if (baseModel == null || mineModel == null || repoModel == null) {
        continue;
      }
      final Wrappers._T<MergeSession> mergeSession=new Wrappers._T<MergeSession>(null);
      ma.runReadAction(new Runnable(){
        public void run(){
          mergeSession.value=MergeSession.createMergeSession(baseModel,mineModel,repoModel);
        }
      }
);
      int conflictingChangesCount=Sequence.fromIterable(mergeSession.value.getAllChanges()).where(new IWhereFilter<ModelChange>(){
        public boolean accept(        ModelChange c){
          return Sequence.fromIterable(mergeSession.value.getConflictedWith(c)).isNotEmpty();
        }
      }
).count();
      if (conflictingChangesCount != 0) {
        if (LOG.isInfoEnabled()) {
          LOG.info("there are still conflicted changes in " + SModelOperations.getModelName(baseModel));
        }
        monitor.advance(1);
        if (monitor.isCanceled()) {
          return;
        }
        continue;
      }
      if (LOG.isInfoEnabled()) {
        LOG.info("no conflicted changes in " + SModelOperations.getModelName(baseModel));
      }
      ma.runReadAction(new Runnable(){
        public void run(){
          mergeSession.value.applyChanges(mergeSession.value.getAllChanges());
        }
      }
);
      ThreadUtils.runInUIThreadAndWait(new Runnable(){
        public void run(){
          ma.runWriteAction(new Runnable(){
            public void run(){
              SModel resultModel=mergeSession.value.getResultModel();
              if (resultModel == null) {
              }
 else               if (mergeSession.value.hasIdsToRestore()) {
                if (LOG.isInfoEnabled()) {
                  LOG.info(String.format("%s: node id duplication detected, should merge in UI.",SModelOperations.getModelName(baseModel)));
                }
              }
 else {
                String resultContent;
                if (FilePerRootDataSource.isPerRootPersistenceFile(iFile)) {
                  resultContent=PersistenceUtil.savePerRootModel(resultModel,file.getExtension().equals(MPSExtentions.MODEL_HEADER));
                }
 else {
                  resultContent=PersistenceUtil.saveModel(resultModel,ext.value);
                }
                try {
                  file.setBinaryContent(resultContent.getBytes(FileUtil.DEFAULT_CHARSET));
                  check_2bxr1q_a1a2a0b0a0a0a0a12a0a3a01g(mySession,file);
                  VcsDirtyScopeManager.getInstance(myProject).fileDirty(file);
                  ListSequence.fromList(myResolvedModelFiles).addElement(file);
                }
 catch (                IOException e) {
                  if (LOG.isEnabledFor(Level.ERROR)) {
                    LOG.error("Cannot save merge result into " + file.getPath(),e);
                  }
                }
              }
            }
          }
);
        }
      }
);
      monitor.advance(1);
      if (monitor.isCanceled()) {
        return;
      }
    }
  }
  finally {
    monitor.done();
  }
}
