{
  ModelConstraintsManager cm=ModelConstraintsManager.getInstance();
  final ConstraintsDescriptor descriptor=ConceptRegistry.getInstance().getConceptDescriptorForInstanceNode(node).constraints();
  final CheckingNodeContext checkingNodeContext=new CheckingNodeContext();
  if (SNodeOperations.getParent(node) != null) {
    component.addDependency(SNodeOperations.getParent(node));
  }
  if (SNodeOperations.getParent(node) != null && !(jetbrains.mps.smodel.SNodeOperations.isUnknown(SNodeOperations.getParent(node)))) {
    final SNode link=SNodeOperations.getContainingLinkDeclaration(node);
    if (link == null) {
      component.addError(node,"Child in a role with unknown link",null);
      return;
    }
    boolean canBeChild=component.runCheckingAction(new _FunctionTypes._return_P0_E0<Boolean>(){
      public Boolean invoke(){
        return ModelConstraintsManager.canBeChild(descriptor,node.getConceptFqName(),operationContext,SNodeOperations.getParent(node),link,checkingNodeContext);
      }
    }
);
    if (!(canBeChild)) {
      SNode rule=checkingNodeContext.getBreakingNodeAndClearContext();
      component.addError(node,"Node " + node + " cannot be child of node "+ SNodeOperations.getParent(node),rule);
    }
  }
  if (node.isRoot()) {
    boolean canBeRoot=component.runCheckingAction(new _FunctionTypes._return_P0_E0<Boolean>(){
      public Boolean invoke(){
        return ModelConstraintsManager.canBeRoot(descriptor,operationContext,node.getConceptFqName(),SNodeOperations.getModel(node),checkingNodeContext);
      }
    }
);
    if (!(canBeRoot)) {
      SNode rule=checkingNodeContext.getBreakingNodeAndClearContext();
      component.addError(node,"Not rootable concept added as root",rule);
    }
  }
  for (  SNode child : SNodeOperations.getChildren(node)) {
    component.addDependency(child);
    final SNode childConcept=SNodeOperations.getConceptDeclaration(child);
    final SNode childLink=SNodeOperations.getContainingLinkDeclaration(child);
    if (childLink == null) {
      continue;
    }
    boolean canBeParent=component.runCheckingAction(new _FunctionTypes._return_P0_E0<Boolean>(){
      public Boolean invoke(){
        return ModelConstraintsManager.canBeParent(descriptor,node,childConcept,childLink,operationContext,checkingNodeContext);
      }
    }
);
    if (!(canBeParent)) {
      SNode rule=checkingNodeContext.getBreakingNodeAndClearContext();
      component.addError(node,"Node " + node + " cannot be parent of node "+ child,rule);
    }
    if (!(ModelConstraintsManager.canBeAncestor(node,childConcept,operationContext,checkingNodeContext))) {
      SNode rule=SNodeOperations.cast(checkingNodeContext.getBreakingNodeAndClearContext(),"jetbrains.mps.lang.constraints.structure.ConstraintFunction_CanBeAnAncestor");
      component.addError(child,"Concept " + SLinkOperations.getTarget(SNodeOperations.as(SNodeOperations.getParent(rule),"jetbrains.mps.lang.constraints.structure.ConceptConstraints"),"concept",false) + " cannot be ancestor of node "+ child,rule);
    }
  }
  SNode concept=SNodeOperations.getConceptDeclaration(node);
  component.addDependency(concept);
  ConceptAndSuperConceptsScope chs=new ConceptAndSuperConceptsScope(concept);
  for (  SNode parentConcept : chs.getConcepts()) {
    component.addDependency(parentConcept);
  }
  List<PropertyDeclaration> props=chs.getAdapters(PropertyDeclaration.class);
  for (  PropertyDeclaration p : ListSequence.fromList(props)) {
    final PropertySupport ps=PropertySupport.getPropertySupport(p.getNode());
    final String propertyName=p.getName();
    if (propertyName == null) {
      LOG.error("Property declaration has a null name, declaration id: " + p.getNode().getSNodeId() + ", model: "+ p.getModel().getSModelFqName());
      continue;
    }
    final String value=ps.fromInternalValue(node.getProperty(propertyName));
    final INodePropertyValidator propertyValidator=ps.getValidator(node,propertyName);
    boolean canSetValue=component.runCheckingAction(new _FunctionTypes._return_P0_E0<Boolean>(){
      public Boolean invoke(){
        return ps.canSetValue(propertyValidator,node,propertyName,value,operationContext.getScope());
      }
    }
);
    if (!(canSetValue)) {
      if ("name".equals(p.getName()) && "AnonymousClass".equals(SPropertyOperations.getString(concept,"name"))) {
        continue;
      }
      component.addError(node,"Property constraint violation for property \"" + p.getName() + "\"",null,new PropertyMessageTarget(p.getName()));
    }
  }
}
