{
  if (!isPackaged())   return;
  ModuleDescriptor descriptor=getModuleDescriptor();
  if (descriptor == null)   return;
  final IFile bundleHomeFile=FileSystem.getInstance().getBundleHome(getDescriptorFile());
  if (bundleHomeFile == null)   return;
  IFile bundleParent=bundleHomeFile.getParent();
  if (bundleParent == null || !bundleParent.exists())   return;
  String packagedSourcesPath=getModuleSourceDir() != null ? getModuleSourceDir().getPath() : null;
  boolean addBundleAsModelRoot=false;
  final DeploymentDescriptor dd=descriptor.getDeploymentDescriptor();
  String libPath=dd == null ? FileUtil.getCanonicalPath(PathManager.getHomePath() + File.separator + "lib").toLowerCase() : null;
  List<String> toRemovePaths=new ArrayList<String>();
  for (  String path : descriptor.getAdditionalJavaStubPaths()) {
    String canonicalPath=FileUtil.getCanonicalPath(path).toLowerCase();
    if (packagedSourcesPath == null || !canonicalPath.startsWith(packagedSourcesPath)) {
      String shrinked=MacrosFactory.forModule(this).shrinkPath(path);
      if (MacrosFactory.containsNonMPSMacros(shrinked))       continue;
    }
    if (dd == null && canonicalPath.startsWith(libPath)) {
      continue;
    }
    toRemovePaths.add(path);
  }
  descriptor.getAdditionalJavaStubPaths().removeAll(toRemovePaths);
  List<ModelRootDescriptor> toRemove=new ArrayList<ModelRootDescriptor>();
  for (  ModelRootDescriptor mrd : descriptor.getModelRootDescriptors()) {
    if (!mrd.getType().equals(PersistenceRegistry.JAVA_CLASSES_ROOT))     continue;
    String path=mrd.getMemento().get("path");
    String canonicalPath=FileUtil.getCanonicalPath(path).toLowerCase();
    String suffix=descriptor.getCompileInMPS() ? CLASSES_GEN : CLASSES;
    if (canonicalPath.endsWith(suffix)) {
      String classes=MacrosFactory.forModule(this).expandPath("${module}/" + suffix);
      addBundleAsModelRoot=FileUtil.getCanonicalPath(classes).equalsIgnoreCase(canonicalPath);
    }
 else     if (FileUtil.getCanonicalPath(bundleHomeFile.getPath()).equalsIgnoreCase(canonicalPath)) {
      addBundleAsModelRoot=true;
    }
    if (packagedSourcesPath == null || !canonicalPath.startsWith(packagedSourcesPath)) {
      String shrinked=MacrosFactory.forModule(this).shrinkPath(path);
      if (MacrosFactory.containsNonMPSMacros(shrinked))       continue;
    }
    if (dd == null && canonicalPath.startsWith(libPath)) {
      continue;
    }
    toRemove.add(mrd);
  }
  descriptor.getModelRootDescriptors().removeAll(toRemove);
  if (addBundleAsModelRoot) {
    descriptor.getModelRootDescriptors().add(ModelRootDescriptor.getJavaStubsModelRoot(bundleHomeFile.getPath()));
  }
  if (dd == null) {
    return;
  }
  for (  String jarFile : dd.getLibraries()) {
    IFile jar=jarFile.startsWith("/") ? FileSystem.getInstance().getFileByPath(PathManager.getHomePath() + jarFile) : bundleParent.getDescendant(jarFile);
    if (jar.exists()) {
      String path=jar.getPath();
      descriptor.getAdditionalJavaStubPaths().add(path);
      descriptor.getModelRootDescriptors().add(ModelRootDescriptor.getJavaStubsModelRoot(path));
    }
  }
}
