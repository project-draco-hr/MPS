{
  List<SReference> toResolve=ListSequence.fromList(new ArrayList<SReference>());
  Map<SModelReference,SModelReference> models=MapSequence.fromMap(new HashMap<SModelReference,SModelReference>());
  for (  SNode node : ListSequence.fromList(SModelOperations.getNodes(model,null))) {
    for (    SReference ref : Sequence.fromIterable(SNodeOperations.getReferences(node))) {
      SModelReference targetModelRef=ref.getTargetSModelReference();
      if (targetModelRef == null || !(JAVA_STUB.equals(targetModelRef.getStereotype()))) {
        continue;
      }
      SModelFqName modelName=new SModelFqName(targetModelRef.getLongName(),null);
      SModelDescriptor modelDescr=SModelRepository.getInstance().getModelDescriptor(modelName);
      if (modelDescr == null) {
        continue;
      }
      MapSequence.fromMap(models).put(targetModelRef,modelDescr.getSModelReference());
      ListSequence.fromList(toResolve).addElement(ref);
    }
  }
  Iterable<SModelReference> modelsToAdd=Sequence.fromIterable(MapSequence.fromMap(models).values()).where(new IWhereFilter<SModelReference>(){
    public boolean accept(    SModelReference it){
      return !(jetbrains.mps.smodel.SModelOperations.getImportedModelUIDs(model).contains(it));
    }
  }
);
  Sequence.fromIterable(modelsToAdd).visitAll(new IVisitor<SModelReference>(){
    public void visit(    SModelReference it){
      model.addModelImport(it,false);
    }
  }
);
  final Map<SModelReference,Boolean> modelsUsed=MapSequence.fromMap(new HashMap<SModelReference,Boolean>());
  int cnt=0;
  int delta=0;
  do {
    cnt+=delta;
    delta=0;
    for (    SReference ref : ListSequence.fromList(toResolve).toGenericArray(SReference.class)) {
      SNode node=ref.getSourceNode();
      final SModelReference modelRef=MapSequence.fromMap(models).get(ref.getTargetSModelReference());
      final String resolveInfo=SLinkOperations.getResolveInfo(ref);
      if (modelRef == null || resolveInfo == null) {
        continue;
      }
      final ISearchScope scope=SNodeOperations.getReferentSearchScope(node,SLinkOperations.getRole(ref),context);
      if (scope == null) {
        continue;
      }
      List<SNode> resolved=TypeContextManager.getInstance().runResolveAction(new Computable<List<SNode>>(){
        public List<SNode> compute(){
          return scope.getNodes(new Condition<SNode>(){
            public boolean met(            SNode n){
              return modelRef.equals(SNodeOperations.getModel(n).getSModelReference()) && resolveInfo.equals(n.getResolveInfo());
            }
          }
);
        }
      }
);
      if (ListSequence.fromList(resolved).count() > 1) {
        if (log.isErrorEnabled()) {
          log.error("more than 1 possible resolution for " + SLinkOperations.getResolveInfo(ref));
        }
      }
      if (ListSequence.fromList(resolved).count() > 0) {
        node.setReferent(SLinkOperations.getRole(ref),ListSequence.fromList(resolved).first());
        MapSequence.fromMap(modelsUsed).put(ref.getTargetSModelReference(),true);
        ListSequence.fromList(toResolve).removeElement(ref);
        ++delta;
      }
    }
    if (log.isErrorEnabled()) {
      log.error("delta=" + delta);
    }
  }
 while (delta > 0);
  Sequence.fromIterable(modelsToAdd).where(new IWhereFilter<SModelReference>(){
    public boolean accept(    SModelReference it){
      return MapSequence.fromMap(modelsUsed).get(it);
    }
  }
).visitAll(new IVisitor<SModelReference>(){
    public void visit(    SModelReference it){
      if (log.isWarnEnabled()) {
        log.warn("import of model " + it.getLongName() + " added");
      }
    }
  }
);
  Sequence.fromIterable(modelsToAdd).visitAll(new IVisitor<SModelReference>(){
    public void visit(    SModelReference it){
      model.deleteModelImport(it);
    }
  }
);
  new MissingDependenciesFixer(null,model.getModelDescriptor()).fix(false);
  if (log.isInfoEnabled()) {
    log.info(cnt + " stub references were re-resolved. " + " ("+ ListSequence.fromList(toResolve).count()+ ")");
  }
}
