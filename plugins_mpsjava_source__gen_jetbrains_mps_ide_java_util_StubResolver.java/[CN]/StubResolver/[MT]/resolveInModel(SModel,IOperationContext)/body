{
  Map<SModelReference,SModelReference> models=MapSequence.fromMap(new HashMap<SModelReference,SModelReference>());
  List<SReference> toResolve=getReferencesToResolve(model,models);
  Iterable<SModelReference> modelsToAdd=Sequence.fromIterable(MapSequence.fromMap(models).values()).where(new IWhereFilter<SModelReference>(){
    public boolean accept(    SModelReference it){
      return !(jetbrains.mps.smodel.SModelOperations.getImportedModelUIDs(model).contains(it));
    }
  }
);
  Sequence.fromIterable(modelsToAdd).visitAll(new IVisitor<SModelReference>(){
    public void visit(    SModelReference it){
      model.addModelImport(it,false);
    }
  }
);
  final Set<SModelReference> modelsUsed=SetSequence.fromSet(new HashSet<SModelReference>());
  int cnt=0;
  int delta=0;
  do {
    cnt+=delta;
    delta=0;
    for (    SReference ref : ListSequence.fromList(toResolve).toGenericArray(SReference.class)) {
      SNode node=ref.getSourceNode();
      final SModelReference modelRef=MapSequence.fromMap(models).get(ref.getTargetSModelReference());
      final String resolveInfo=SLinkOperations.getResolveInfo(ref);
      if (modelRef == null || resolveInfo == null) {
        continue;
      }
      final ISearchScope scope=SNodeOperations.getReferentSearchScope(node,SLinkOperations.getRole(ref),context);
      if (scope == null) {
        continue;
      }
      List<SNode> resolved=TypeContextManager.getInstance().runResolveAction(new Computable<List<SNode>>(){
        public List<SNode> compute(){
          return scope.getNodes(new Condition<SNode>(){
            public boolean met(            SNode n){
              return modelRef.equals(SNodeOperations.getModel(n).getSModelReference()) && resolveInfo.equals(n.getResolveInfo());
            }
          }
);
        }
      }
);
      if (ListSequence.fromList(resolved).count() > 1) {
        if (log.isErrorEnabled()) {
          log.error("more than 1 possible resolution for " + SLinkOperations.getResolveInfo(ref) + " in model "+ modelRef.getLongName());
        }
      }
      if (ListSequence.fromList(resolved).count() > 0) {
        node.setReferent(SLinkOperations.getRole(ref),ListSequence.fromList(resolved).first());
        SetSequence.fromSet(modelsUsed).addElement(ref.getTargetSModelReference());
        ListSequence.fromList(toResolve).removeElement(ref);
        ++delta;
      }
    }
    if (log.isErrorEnabled()) {
      log.error("delta=" + delta);
    }
  }
 while (delta > 0);
  Sequence.fromIterable(modelsToAdd).where(new IWhereFilter<SModelReference>(){
    public boolean accept(    SModelReference it){
      return SetSequence.fromSet(modelsUsed).contains(it);
    }
  }
).visitAll(new IVisitor<SModelReference>(){
    public void visit(    SModelReference it){
      if (log.isWarnEnabled()) {
        log.warn("import of model " + it.getLongName() + " added");
      }
    }
  }
);
  Sequence.fromIterable(modelsToAdd).visitAll(new IVisitor<SModelReference>(){
    public void visit(    SModelReference it){
      model.deleteModelImport(it);
    }
  }
);
  new MissingDependenciesFixer(null,model.getModelDescriptor()).fix(false);
  if (log.isInfoEnabled()) {
    log.info(cnt + " stub references were re-resolved. " + " ("+ ListSequence.fromList(toResolve).count()+ ")");
  }
}
