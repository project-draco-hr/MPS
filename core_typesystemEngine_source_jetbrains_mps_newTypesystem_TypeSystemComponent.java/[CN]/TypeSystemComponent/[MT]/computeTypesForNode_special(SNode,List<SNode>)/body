{
  SNode type=null;
  SNode prevNode=null;
  SNode node=initialNode;
  long start=System.currentTimeMillis();
  myState.setTargetNode(initialNode);
  while (node != null) {
    List<SNode> additionalNodes=new ArrayList<SNode>(givenAdditionalNodes);
    additionalNodes.addAll(myAdditionalNodes);
    myAdditionalNodes.clear();
    if (prevNode != null) {
      additionalNodes.add(prevNode);
    }
    computeTypesSpecial(node,false,additionalNodes,false,initialNode);
    type=typeCalculated(initialNode);
    if (type == null) {
      if (node.isRoot()) {
        myNodeTypesComponent.getTypeCheckingContext().setSingleTypeComputation(false);
        computeTypes(node,true,true,new ArrayList<SNode>(0),true,initialNode);
        type=getType(initialNode);
        if (type == null && node != initialNode && myState.getInequalitySystem() == null && !myNodeTypesComponent.getTypeCheckingContext().isInEditorQueries()) {
          LOG.error("No typesystem rule for " + initialNode.getDebugText() + " in root "+ initialNode.getContainingRoot()+ ": type calculation took "+ (System.currentTimeMillis() - start)+ " ms",new Throwable(),new SNodePointer(initialNode));
        }
        return type;
      }
      prevNode=node;
      node=node.getParent();
    }
 else {
      return type;
    }
  }
  return type;
}
