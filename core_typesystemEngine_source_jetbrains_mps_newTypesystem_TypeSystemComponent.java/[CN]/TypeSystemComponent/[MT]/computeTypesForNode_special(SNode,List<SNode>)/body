{
  SNode type=null;
  SNode prevNode=null;
  SNode node=initialNode;
  if (myTypeChecker.getRulesManager().getInferenceRules(node).isEmpty()) {
    return null;
  }
  long start=System.currentTimeMillis();
  myState.setTargetNode(initialNode);
  while (node != null) {
    List<SNode> additionalNodes=new ArrayList<SNode>(givenAdditionalNodes);
    if (prevNode != null) {
      additionalNodes.add(prevNode);
    }
    computeTypesSpecial(node,false,additionalNodes,false,initialNode);
    type=typeCalculated(initialNode);
    if (type == null) {
      if (node.isRoot()) {
        typeCalculated(initialNode);
        computeTypes(node,true,true,new ArrayList<SNode>(0),true,initialNode);
        type=getType(initialNode);
        if (type == null && node != initialNode) {
          LOG.error("No typesystem rule for " + initialNode.getDebugText() + ": type calculation took "+ (System.currentTimeMillis() - start)+ " ms",new SNodePointer(initialNode));
        }
        return type;
      }
      prevNode=node;
      node=node.getParent();
    }
 else {
      return type;
    }
  }
  return type;
}
