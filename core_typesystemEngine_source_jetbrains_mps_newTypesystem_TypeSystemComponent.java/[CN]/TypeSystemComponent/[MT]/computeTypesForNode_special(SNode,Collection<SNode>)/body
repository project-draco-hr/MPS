{
  SNode type=null;
  SNode prevNode=null;
  SNode node=initialNode;
  long start=System.currentTimeMillis();
  myState.setTargetNode(initialNode);
  while (node != null) {
    Collection<SNode> additionalNodes=givenAdditionalNodes;
    if (prevNode != null) {
      additionalNodes=new ArrayList<SNode>(additionalNodes);
      additionalNodes.add(prevNode);
    }
    computeTypesSpecial(node,false,additionalNodes,false,initialNode);
    type=typeCalculated(initialNode);
    if (type == null) {
      if (node.isRoot()) {
        myNodeTypesComponent.getTypeCheckingContext().setSingleTypeComputation(false);
        System.out.println("Root: " + initialNode.getDebugText());
        type=getType(initialNode);
        if (type == null && node != initialNode && myState.getInequalitySystem() == null && !myNodeTypesComponent.getTypeCheckingContext().isInEditorQueries()) {
          LOG.error("No typesystem rule for " + initialNode.getDebugText() + " in root "+ initialNode.getContainingRoot()+ ": type calculation took "+ (System.currentTimeMillis() - start)+ " ms",new Throwable(),new SNodePointer(initialNode));
        }
        return type;
      }
      prevNode=node;
      node=node.getParent();
    }
 else {
      return type;
    }
  }
  return type;
}
