{
  int cnt=0;
  boolean found;
  do {
    found=false;
    for (    SReference ref : ListSequence.fromList(toResolve).toGenericArray(SReference.class)) {
      SNode node=ref.getSourceNode();
      final SModelReference modelRef=MapSequence.fromMap(models).get(ref.getTargetSModelReference());
      final String resolveInfo=SLinkOperations.getResolveInfo(ref);
      if (modelRef == null || resolveInfo == null) {
        continue;
      }
      final Scope refScope=ModelConstraints.getScope(ref);
      if (refScope instanceof ErrorScope) {
        continue;
      }
      List<SNode> resolved=TypeContextManager.getInstance().runResolveAction(new Computable<IListSequence<SNode>>(){
        public IListSequence<SNode> compute(){
          return Sequence.fromIterable(refScope.getAvailableElements(null)).where(new IWhereFilter<SNode>(){
            public boolean accept(            SNode n){
              return modelRef.equals(SNodeOperations.getModel(n).getReference()) && resolveInfo.equals(jetbrains.mps.util.SNodeOperations.getResolveInfo(n));
            }
          }
).toListSequence();
        }
      }
);
      if (ListSequence.fromList(resolved).count() > 1) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("more than 1 possible resolution for " + SLinkOperations.getResolveInfo(ref) + " in model "+ SModelStereotype.withoutStereotype(modelRef.getModelName()));
        }
      }
      if (ListSequence.fromList(resolved).isNotEmpty()) {
        SNodeAccessUtil.setReferenceTarget(node,SLinkOperations.getRole(ref),ListSequence.fromList(resolved).first());
        ListSequence.fromList(toResolve).removeElement(ref);
        ++cnt;
        found=true;
      }
    }
  }
 while (found);
  return cnt;
}
