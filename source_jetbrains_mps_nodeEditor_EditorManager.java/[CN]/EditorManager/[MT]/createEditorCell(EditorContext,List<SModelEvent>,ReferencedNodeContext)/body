{
  SNode node=refContext.getNode();
  AttributeConcept attribute=node.getAttribute();
  if (attribute != null) {
    if (myAttributesStack.isEmpty() || (myAttributesStack.peek() != attribute)) {
      myAttributesStack.push(attribute);
      EditorCell result=createEditorCell(context,events,ReferencedNodeContext.createNodeContext(attribute));
      AttributeConcept poppedAttribute=myAttributesStack.pop();
      LOG.assertLog(poppedAttribute == attribute);
      return result;
    }
  }
  AbstractEditorComponent nodeEditorComponent=context.getNodeEditorComponent();
  EditorCell oldCell=nodeEditorComponent.getBigCellForRefContext(refContext);
  if (events != null) {
    boolean nodeChanged=false;
    for (    SModelEvent event : events) {
      SNode eventNode;
      if (event instanceof SModelChildEvent) {
        eventNode=((SModelChildEvent)event).getParent();
      }
 else       if (event instanceof SModelReferenceEvent) {
        eventNode=((SModelReferenceEvent)event).getReference().getSourceNode();
      }
 else       if (event instanceof SModelPropertyEvent) {
        eventNode=((SModelPropertyEvent)event).getNode();
      }
 else       if (event instanceof SModelAttributeEvent) {
        eventNode=((SModelAttributeEvent)event).getAttributedNode();
      }
 else       continue;
      if (nodeEditorComponent.doesCellDependOnNode(oldCell,eventNode)) {
        nodeChanged=true;
        break;
      }
    }
    if (!nodeChanged) {
      if (myMap.containsKey(refContext)) {
        EditorCell editorCell=myMap.get(refContext);
        final Set<SNode> nodesOldCellDependsOn=nodeEditorComponent.getCopyOfNodesCellDependsOn(editorCell);
        final Set<SNodeProxy> refTargetsOldCellDependsOn=nodeEditorComponent.getCopyOfRefTargetsCellDependsOn(editorCell);
        if (nodesOldCellDependsOn != null || refTargetsOldCellDependsOn != null) {
          CellBuildNodeAccessListener listensNothingListener=new CellBuildNodeAccessListener(nodeEditorComponent);
          NodeReadAccessCaster.setNodeReadAccessListener(listensNothingListener);
          if (nodesOldCellDependsOn != null)           listensNothingListener.addNodesToDependOn(nodesOldCellDependsOn);
          if (refTargetsOldCellDependsOn != null)           listensNothingListener.addRefTargetsToDependOn(refTargetsOldCellDependsOn);
          NodeReadAccessCaster.removeNodeAccessListener();
        }
        return editorCell;
      }
    }
 else {
      myMap.putAll(findBigDescendantCellsAndTheirNodes(oldCell));
    }
  }
  nodeEditorComponent.clearNodesCellDependsOn(oldCell);
  return createEditorCell_internal(context,myCreatingInspectedCell,refContext);
}
