{
  FileStatus status=ModelAccess.instance().runReadAction(new Computable<FileStatus>(){
    public FileStatus compute(){
      SModelDescriptor modelDescriptor=SModelRepository.getInstance().getModelDescriptor(root.getModelReference());
      if (modelDescriptor instanceof DefaultSModelDescriptor) {
        DefaultSModelDescriptor md=(DefaultSModelDescriptor)modelDescriptor;
        if (ConflictsUtil.isModelOrModuleConflicting(md,myProject)) {
          return FileStatus.MERGED_WITH_CONFLICTS;
        }
        CurrentDifference diff=myRegistry.getCurrentDifference(md);
        List<ModelChange> modelChanges=check_onkh7z_a0d0b0a0a0a0f(diff.getChangeSet());
        final SNodeId rootId=root.getNodeId();
        List<ModelChange> rootChanges=ListSequence.fromList(modelChanges).where(new IWhereFilter<ModelChange>(){
          public boolean accept(          ModelChange ch){
            return rootId.equals(ch.getRootId());
          }
        }
).toListSequence();
        if (ListSequence.fromList(rootChanges).count() != 0) {
          if (ListSequence.fromList(rootChanges).first() instanceof AddRootChange) {
            VirtualFile vf=VirtualFileUtils.getVirtualFile(md.getModelFile());
            if (vf != null) {
              FileStatus modelStatus=FileStatusManager.getInstance(myProject).getStatus(vf);
              if (BaseVersionUtil.isAddedFileStatus(modelStatus)) {
                return modelStatus;
              }
            }
            return FileStatus.ADDED;
          }
          return FileStatus.MODIFIED;
        }
      }
      return FileStatus.NOT_CHANGED;
    }
  }
);
synchronized (myFileStatusMap) {
    if (MapSequence.fromMap(myFileStatusMap).get(root) != status) {
      MapSequence.fromMap(myFileStatusMap).put(root,status);
      return true;
    }
 else {
      return false;
    }
  }
}
