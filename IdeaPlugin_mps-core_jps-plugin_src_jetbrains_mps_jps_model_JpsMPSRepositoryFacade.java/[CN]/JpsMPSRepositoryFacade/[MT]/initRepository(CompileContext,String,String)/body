{
  if (repoFile != null) {
    File f=new File(repoFile);
    ModelInputStream mos=null;
    try {
      long start=System.nanoTime();
      mos=new ModelInputStream(new FileInputStream(f));
      myRepo=CachedRepositoryData.load(mos);
      if (MPSCompilerUtil.isTracingMode()) {
        context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID,Kind.INFO,"loaded " + myRepo.getModules().size() + " modules in "+ (System.nanoTime() - start) / 1000000 + " ms"));
      }
      PersistenceRegistry.getInstance().setModelRootFactory(PersistenceRegistry.DEFAULT_MODEL_ROOT,new ModelRootFactory(){
        @NotNull @Override public ModelRoot create(){
          return new CachedDefaultModelRoot(myRepo);
        }
      }
);
      PersistenceRegistry.getInstance().setModelRootFactory(PersistenceRegistry.JAVA_CLASSES_ROOT,new ModelRootFactory(){
        @NotNull @Override public ModelRoot create(        @NotNull ModelRootContext context){
          return new CachedJavaClassStubsModelRoot(FileSystem.getInstance(),myRepo);
        }
      }
);
      start=System.nanoTime();
      for (      CachedModuleData data : myRepo.getModules()) {
        ModuleRepositoryFacade.createModule(data.getHandle(),this);
      }
      if (MPSCompilerUtil.isTracingMode()) {
        context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID,Kind.INFO,"instantiated " + myRepo.getModules().size() + " modules in "+ (System.nanoTime() - start) / 1000000 + " ms"));
      }
      return;
    }
 catch (    IOException e) {
      context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID,e));
      context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID,Kind.WARNING,"cannot load cache, generation may be slow"));
    }
 finally {
      jetbrains.mps.util.FileUtil.closeFileSafe(mos);
    }
  }
 else   if (languages != null) {
    long start=System.nanoTime();
    List<ModuleHandle> loadedModules=new ArrayList<ModuleHandle>();
    for (    String path : languages.split(";")) {
      IFile ipath=FileSystem.getInstance().getFileByPath(path);
      loadedModules.addAll(ModulesMiner.getInstance().collectModules(ipath,true));
    }
    if (MPSCompilerUtil.isTracingMode()) {
      context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID,Kind.INFO,"loaded " + loadedModules.size() + " modules in "+ (System.nanoTime() - start) / 1000000 + " ms"));
    }
    start=System.nanoTime();
    for (    ModuleHandle moduleHandle : loadedModules) {
      ModuleRepositoryFacade.createModule(moduleHandle,OWNER);
    }
    if (MPSCompilerUtil.isTracingMode()) {
      context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID,Kind.INFO,"instantiated " + loadedModules.size() + " modules in "+ (System.nanoTime() - start) / 1000000 + " ms"));
    }
    return;
  }
  context.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID,Kind.WARNING,"cannot start MPS, no repository provided"));
}
