{
  if (node == null)   return;
  Set<SNode> frontier=new LinkedHashSet<SNode>();
  Set<SNode> newFrontier=new LinkedHashSet<SNode>();
  frontier.add(node);
  frontier.addAll(additionalNodes);
  while (!(frontier.isEmpty())) {
    for (    SNode sNode : frontier) {
      if (myFullyCheckedNodes.contains(sNode)) {
        continue;
      }
      if (myIsGeneration) {
        newFrontier.addAll(myTypeChecker.getRulesManager().getDependencies(sNode));
      }
      if (forceChildrenCheck) {
        newFrontier.addAll(sNode.getChildren());
      }
      if (!myPartlyCheckedNodes.contains(sNode)) {
        myNotSkippedNodes.add(new SNodePointer(sNode));
        myCurrentFrontier=newFrontier;
        if (isIncrementalMode()) {
          myNodesReadListener.clear();
          NodeReadEventsCaster.setNodesReadListener(myNodesReadListener);
        }
        try {
          applyRulesToNode(sNode,useNonTypesystemRules);
        }
  finally {
          if (isIncrementalMode()) {
            NodeReadEventsCaster.removeNodesReadListener();
          }
          myCurrentFrontier=null;
        }
        if (isIncrementalMode()) {
synchronized (ACCESS_LOCK) {
            myNodesReadListener.setAccessReport(true);
            addDepedentNodes(sNode,new HashSet<SNode>(myNodesReadListener.myAcessedNodes));
            myNodesReadListener.setAccessReport(false);
          }
          myNodesReadListener.clear();
        }
        myPartlyCheckedNodes.add(sNode);
      }
      myFullyCheckedNodes.add(sNode);
    }
    frontier=newFrontier;
    newFrontier=new LinkedHashSet<SNode>();
  }
}
