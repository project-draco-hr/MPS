{
  try {
    if (!isIncrementalMode() || refreshTypes) {
      clear();
    }
 else {
      myNotSkippedNodes.clear();
      AbstractEditorComponent component=getEditorComponent();
      if (component != null) {
        component.getHighlightManager().clearForOwner(this);
      }
      doInvalidate();
      myPartlyCheckedNodes.addAll(myFullyCheckedNodes);
      myFullyCheckedNodes.clear();
      myNodesBeingChecked.clear();
    }
    myTypeChecker.setCurrentTypesComponent(this);
    if (!loadTypesystemRules(myRootNode)) {
      return;
    }
    clearEquationManager();
    computeTypesForNode(myRootNode);
    myEquationManagersStack.peek().solveInequations();
    for (    Map.Entry<SNode,SNode> contextEntry : new HashSet<Entry<SNode,SNode>>(myNodesToTypesMap.entrySet())) {
      SNode term=contextEntry.getKey();
      if (term == null)       continue;
      SNode type=expandType(contextEntry.getValue(),myTypeChecker.getRuntimeTypesModel());
      if (BaseAdapter.isInstance(type,RuntimeErrorType.class)) {
        reportTypeError(term,((RuntimeErrorType)BaseAdapter.fromNode(type)).getErrorText(),null,null);
      }
      myNodesToTypesMap.put(term,type);
    }
    for (    SNode node : new HashSet<SNode>(myNodesToErrorsMap.keySet())) {
      IErrorReporter iErrorReporter=myNodesToErrorsMap.get(node);
      String errorString=iErrorReporter.reportError();
      myNodesToErrorsMap.put(node,new SimpleErrorReporter(errorString,iErrorReporter.getRuleModel(),iErrorReporter.getRuleId()));
    }
    removeOurListener();
    for (    SNode nodeToDependOn : myNodesToDependentNodes.keySet()) {
      addOurListener(nodeToDependOn.getModel().getModelDescriptor());
    }
    final Set<SNodeProxy> skippedNodes=new HashSet<SNodeProxy>(myNotSkippedNodes);
    if (HelginsPreferencesComponent.getInstance().isUsesDebugHighlighting()) {
      CommandProcessor.instance().invokeLater(new Runnable(){
        public void run(){
          AbstractEditorComponent component=getEditorComponent();
          if (component == null)           return;
          for (          SNodeProxy skippedNode : skippedNodes) {
            component.getHighlightManager().mark(skippedNode.getNode(),new Color(255,127,0,50),"",NodeTypesComponent_new.this);
          }
        }
      }
);
    }
  }
  finally {
    myTypeChecker.clearCurrentTypesComponent();
    myNotSkippedNodes.clear();
    clearEquationManager();
  }
}
