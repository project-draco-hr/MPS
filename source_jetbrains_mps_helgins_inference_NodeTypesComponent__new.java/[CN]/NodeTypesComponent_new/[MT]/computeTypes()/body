{
  try {
{
      myPartlyCheckedNodes.addAll(myFullyCheckedNodes);
      myFullyCheckedNodes.clear();
    }
    myTypeChecker.setCurrentTypesComponent(this);
    if (!loadTypesystemRules(myRootNode)) {
      return;
    }
    myEquationManagersStack.clear();
    myEquationManagersStack.push(new EquationManager(myTypeChecker,this));
    computeTypesForNode(myRootNode);
    myEquationManagersStack.peek().solveInequations();
    for (    Map.Entry<SNode,SNode> contextEntry : new HashSet<Entry<SNode,SNode>>(myNodesToTypesMap.entrySet())) {
      SNode term=contextEntry.getKey();
      if (term == null)       continue;
      SNode type=expandType(contextEntry.getValue(),myTypeChecker.getRuntimeTypesModel());
      if (BaseAdapter.isInstance(type,RuntimeErrorType.class)) {
        reportTypeError(term,((RuntimeErrorType)BaseAdapter.fromNode(type)).getErrorText());
      }
      myNodesToTypesMap.put(term,type);
    }
    for (    SNode node : new HashSet<SNode>(myNodesToErrorsMap.keySet())) {
      String errorString="HELGINS ERROR: " + myNodesToErrorsMap.get(node).reportError();
      myNodesToErrorsMap.put(node,new SimpleErrorReporter(errorString));
    }
    removeOurListener();
    for (    SNode nodeToDependOn : myNodesToDependentNodes.keySet()) {
      addOurListener(nodeToDependOn.getModel().getModelDescriptor());
    }
  }
  finally {
    myTypeChecker.clearCurrentTypesComponent();
  }
}
