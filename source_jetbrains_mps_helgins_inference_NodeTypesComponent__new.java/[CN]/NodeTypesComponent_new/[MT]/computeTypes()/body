{
  try {
{
      myNotSkippedNodes.clear();
      AbstractEditorComponent component=getEditorComponent();
      if (component != null) {
        component.getHighlightManager().clearForOwner(this);
      }
      myPartlyCheckedNodes.addAll(myFullyCheckedNodes);
      myFullyCheckedNodes.clear();
    }
    myTypeChecker.setCurrentTypesComponent(this);
    if (!loadTypesystemRules(myRootNode)) {
      return;
    }
    myEquationManagersStack.clear();
    myEquationManagersStack.push(new EquationManager(myTypeChecker,this));
    computeTypesForNode(myRootNode);
    myEquationManagersStack.peek().solveInequations();
    for (    Map.Entry<SNode,SNode> contextEntry : new HashSet<Entry<SNode,SNode>>(myNodesToTypesMap.entrySet())) {
      SNode term=contextEntry.getKey();
      if (term == null)       continue;
      SNode type=expandType(contextEntry.getValue(),myTypeChecker.getRuntimeTypesModel());
      if (BaseAdapter.isInstance(type,RuntimeErrorType.class)) {
        reportTypeError(term,((RuntimeErrorType)BaseAdapter.fromNode(type)).getErrorText());
      }
      myNodesToTypesMap.put(term,type);
    }
    for (    SNode node : new HashSet<SNode>(myNodesToErrorsMap.keySet())) {
      String errorString="HELGINS ERROR: " + myNodesToErrorsMap.get(node).reportError();
      myNodesToErrorsMap.put(node,new SimpleErrorReporter(errorString));
    }
    removeOurListener();
    for (    SNode nodeToDependOn : myNodesToDependentNodes.keySet()) {
      addOurListener(nodeToDependOn.getModel().getModelDescriptor());
    }
    final Set<SNodeProxy> skippedNodes=new HashSet<SNodeProxy>(myNotSkippedNodes);
    CommandProcessor.instance().invokeLater(new Runnable(){
      public void run(){
        AbstractEditorComponent component=getEditorComponent();
        if (component == null)         return;
        for (        SNodeProxy skippedNode : skippedNodes) {
          component.getHighlightManager().mark(skippedNode.getNode(),new Color(255,127,0,50),"",NodeTypesComponent_new.this);
        }
      }
    }
);
  }
  finally {
    myTypeChecker.clearCurrentTypesComponent();
    myNotSkippedNodes.clear();
  }
}
