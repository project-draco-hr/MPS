{
  final Map<SNodeId,DeleteRootChange> deleteRootChanges=MapSequence.fromMap(new HashMap<SNodeId,DeleteRootChange>());
  Sequence.fromIterable(thisChangeSet.getModelChanges(DeleteRootChange.class)).visitAll(new IVisitor<DeleteRootChange>(){
    public void visit(    DeleteRootChange d){
      MapSequence.fromMap(deleteRootChanges).put(d.getNodeId(),d);
    }
  }
);
  for (  NodeChange change : Sequence.fromIterable(otherChangeSet.getModelChanges(NodeChange.class))) {
    if (!(MapSequence.fromMap(myConflictingChanges).containsKey(change))) {
      SNode node=myBaseModel.getNodeById(change.getAffectedNodeId());
      while (node != null) {
        SNodeId nodeId=node.getSNodeId();
        if (SNodeOperations.getParent(node) == null) {
          DeleteRootChange conflicting=MapSequence.fromMap(deleteRootChanges).get(nodeId);
          if (conflicting != null) {
            addConflict(change,conflicting);
          }
        }
 else {
          Tuples._2<SNodeId,String> nodeRole=MultiTuple.<SNodeId,String>from(SNodeOperations.getParent(node).getSNodeId(),SNodeOperations.getContainingLinkRole(node));
          final int index=SNodeOperations.getIndexInParent(node);
          NodeGroupChange conflicting=ListSequence.fromList(MapSequence.fromMap(arrangedChanges).get(nodeRole)).findFirst(new IWhereFilter<NodeGroupChange>(){
            public boolean accept(            NodeGroupChange ch){
              return ch.getBegin() <= index && index < ch.getEnd();
            }
          }
);
          if (conflicting != null) {
            addConflict(change,conflicting);
            break;
          }
        }
        node=SNodeOperations.getParent(node);
      }
    }
  }
}
