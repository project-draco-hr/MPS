{
  SNode trg=new AdaptableClassifierTarget(_context).getTarget(_context.getNode());
  SNode ntype=FunctionType_Behavior.call_getDeclarationRuntimeType_1230319610063(SNodeOperations.as(TypeChecker.getInstance().getTypeOf(_context.getNode()),MetaAdapterFactory.getConcept(new UUID(-200093298712821347l,-8038623698278341771l),1199542442495l,"jetbrains.mps.baseLanguage.closures.structure.FunctionType")));
  ntype=(ntype == null ? TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(_context.getNode()),HUtil.createMatchingPatternByConceptFQName("jetbrains.mps.baseLanguage.structure.ClassifierType"),true) : ntype);
  final Map<SNode,SNode> theMap=FunctionTypeUtil.mapAdaptableTargetTVDs(SLinkOperations.getTarget(SNodeOperations.cast(ntype,MetaAdapterFactory.getConcept(new UUID(-935030926396207931l,-6610165693999523818l),1107535904670l,"jetbrains.mps.baseLanguage.structure.ClassifierType")),MetaAdapterFactory.getReferenceLink(new UUID(-935030926396207931l,-6610165693999523818l),1107535904670l,1107535924139l,"classifier")),trg);
  final List<SNode> params=SLinkOperations.getChildren(SNodeOperations.cast(ntype,MetaAdapterFactory.getConcept(new UUID(-935030926396207931l,-6610165693999523818l),1107535904670l,"jetbrains.mps.baseLanguage.structure.ClassifierType")),MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l,-6610165693999523818l),1107535904670l,1109201940907l,"parameter"));
  return ListSequence.fromList(SLinkOperations.getChildren(trg,MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l,-6610165693999523818l),1109279851642l,1109279881614l,"typeVariableDeclaration"))).select(new ISelector<SNode,IMapping<SNode,SNode>>(){
    public IMapping<SNode,SNode> select(    final SNode tvd){
      return MapSequence.fromMap(theMap).findFirst(new IWhereFilter<IMapping<SNode,SNode>>(){
        public boolean accept(        IMapping<SNode,SNode> m){
          return m.value() == tvd;
        }
      }
);
    }
  }
).where(new IWhereFilter<IMapping<SNode,SNode>>(){
    public boolean accept(    IMapping<SNode,SNode> m){
      return m != null;
    }
  }
).select(new ISelector<IMapping<SNode,SNode>,SNode>(){
    public SNode select(    IMapping<SNode,SNode> m){
      return ListSequence.fromList(params).getElement(SNodeOperations.getIndexInParent(m.key()));
    }
  }
);
}
