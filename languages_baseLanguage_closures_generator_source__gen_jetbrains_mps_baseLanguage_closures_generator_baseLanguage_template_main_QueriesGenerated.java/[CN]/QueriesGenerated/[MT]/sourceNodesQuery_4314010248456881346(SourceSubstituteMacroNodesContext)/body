{
  SNode trg=new AdaptableClassifierTarget(_context).getTarget(_context.getNode());
  SNode ntype=FunctionType_BehaviorDescriptor.getDeclarationRuntimeType_idhTOKQzf.invoke(SNodeOperations.as(TypeChecker.getInstance().getTypeOf(_context.getNode()),MetaAdapterFactory.getConcept(0xfd3920347849419dL,0x907112563d152375L,0x1174a4d19ffL,"jetbrains.mps.baseLanguage.closures.structure.FunctionType")));
  ntype=(ntype == null ? TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(_context.getNode()),HUtil.createMatchingPatternByConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0x101de48bf9eL,"jetbrains.mps.baseLanguage.structure.ClassifierType")),true) : ntype);
  final Map<SNode,SNode> theMap=FunctionTypeUtil.mapAdaptableTargetTVDs(SLinkOperations.getTarget(SNodeOperations.cast(ntype,MetaAdapterFactory.getConcept(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0x101de48bf9eL,"jetbrains.mps.baseLanguage.structure.ClassifierType")),MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0x101de48bf9eL,0x101de490babL,"classifier")),trg);
  final List<SNode> params=SLinkOperations.getChildren(SNodeOperations.cast(ntype,MetaAdapterFactory.getConcept(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0x101de48bf9eL,"jetbrains.mps.baseLanguage.structure.ClassifierType")),MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0x101de48bf9eL,0x102419671abL,"parameter"));
  return ListSequence.fromList(SLinkOperations.getChildren(trg,MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0x102463b447aL,0x102463bb98eL,"typeVariableDeclaration"))).select(new ISelector<SNode,IMapping<SNode,SNode>>(){
    public IMapping<SNode,SNode> select(    final SNode tvd){
      return MapSequence.fromMap(theMap).findFirst(new IWhereFilter<IMapping<SNode,SNode>>(){
        public boolean accept(        IMapping<SNode,SNode> m){
          return m.value() == tvd;
        }
      }
);
    }
  }
).where(new IWhereFilter<IMapping<SNode,SNode>>(){
    public boolean accept(    IMapping<SNode,SNode> m){
      return m != null;
    }
  }
).select(new ISelector<IMapping<SNode,SNode>,SNode>(){
    public SNode select(    IMapping<SNode,SNode> m){
      return ListSequence.fromList(params).getElement(SNodeOperations.getIndexInParent(m.key()));
    }
  }
);
}
