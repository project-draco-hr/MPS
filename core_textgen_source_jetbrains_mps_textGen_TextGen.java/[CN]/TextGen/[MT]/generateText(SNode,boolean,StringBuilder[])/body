{
  TextGenBuffer buffer=new TextGenBuffer(withDebugInfo,buffers);
  buffer.putUserObject(PACKAGE_NAME,jetbrains.mps.util.SNodeOperations.getModelLongName(node.getModel()));
  buffer.putUserObject(ROOT_NODE,node);
  final TraceInfoCollector tic;
  if (withDebugInfo) {
    tic=TraceInfoGenerationUtil.init(buffer);
  }
 else {
    tic=null;
  }
  appendNodeText(buffer,node);
  Map<SNode,TraceablePositionInfo> positionInfo=null;
  Map<SNode,ScopePositionInfo> scopeInfo=null;
  Map<SNode,UnitPositionInfo> unitInfo=null;
  if (tic != null) {
    positionInfo=tic.getTracePositions();
    scopeInfo=tic.getScopePositions();
    unitInfo=tic.getUnitPositions();
    int topLength=buffer.getTopBufferLineCount();
    topLength++;
    adjustPositions(topLength,positionInfo.values());
    adjustPositions(topLength,scopeInfo.values());
    adjustPositions(topLength,unitInfo.values());
  }
  List<String> dependencies=getUserObjectCollection(DEPENDENCY,node,buffer,(Set<String>)buffer.getUserObject(EXTENDS));
  List<String> extend=getUserObjectCollection(EXTENDS,node,buffer,null);
  Map<String,List<String>> deps=new HashMap<String,List<String>>(2);
  deps.put(DEPENDENCY,dependencies);
  deps.put(EXTENDS,extend);
  Object result=buffer.getText();
  String outputEncoding=(String)buffer.getUserObject(OUTPUT_ENCODING);
  if (outputEncoding != null) {
    if (outputEncoding.equals("binary")) {
      result=EncodingUtil.decodeBase64((String)result);
    }
 else {
      try {
        result=EncodingUtil.encode((String)result,outputEncoding);
      }
 catch (      IOException ex) {
        buffer.foundError("cannot encode the output stream",null,ex);
      }
    }
  }
  return new TextGenerationResult(node,result,buffer.hasErrors(),buffer.problems(),positionInfo,scopeInfo,unitInfo,deps);
}
