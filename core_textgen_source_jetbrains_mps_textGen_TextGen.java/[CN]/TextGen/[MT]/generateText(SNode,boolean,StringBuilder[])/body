{
  TextGenBuffer buffer=new TextGenBuffer(buffers);
  buffer.putUserObject(PACKAGE_NAME,jetbrains.mps.util.SNodeOperations.getModelLongName(node.getModel()));
  buffer.putUserObject(ROOT_NODE,node);
  final TraceInfoCollector tic;
  if (withDebugInfo) {
    tic=new TraceInfoCollector();
    TraceInfoGenerationUtil.setTraceInfoCollector(buffer,tic);
  }
 else {
    tic=null;
  }
  appendNodeText(buffer,node);
  Map<SNode,TraceablePositionInfo> positionInfo=null;
  Map<SNode,ScopePositionInfo> scopeInfo=null;
  Map<SNode,UnitPositionInfo> unitInfo=null;
  final BufferSnapshot textSnapshot=buffer.getTextSnapshot();
  if (tic != null) {
    tic.populatePositions(textSnapshot);
    positionInfo=tic.getTracePositions();
    scopeInfo=tic.getScopePositions();
    unitInfo=tic.getUnitPositions();
  }
  List<String> dependencies=getUserObjectCollection(DEPENDENCY,node,buffer,(Set<String>)buffer.getUserObject(EXTENDS));
  List<String> extend=getUserObjectCollection(EXTENDS,node,buffer,null);
  Map<String,List<String>> deps=new HashMap<String,List<String>>(2);
  deps.put(DEPENDENCY,dependencies);
  deps.put(EXTENDS,extend);
  final String bufferOutcome=textSnapshot.getText().toString();
  Object result=bufferOutcome;
  String outputEncoding=(String)buffer.getUserObject(OUTPUT_ENCODING);
  if (outputEncoding != null) {
    if (outputEncoding.equals("binary")) {
      result=EncodingUtil.decodeBase64(bufferOutcome);
    }
 else {
      try {
        result=EncodingUtil.encode(bufferOutcome,outputEncoding);
      }
 catch (      IOException ex) {
        buffer.foundError("cannot encode the output stream",null,ex);
      }
    }
  }
  return new TextGenerationResult(node,result,buffer.hasErrors(),buffer.problems(),positionInfo,scopeInfo,unitInfo,deps);
}
