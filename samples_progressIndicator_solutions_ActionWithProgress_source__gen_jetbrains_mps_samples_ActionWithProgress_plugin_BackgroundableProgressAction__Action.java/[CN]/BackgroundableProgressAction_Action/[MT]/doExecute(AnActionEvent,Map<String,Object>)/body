{
  boolean canBeCanceled=true;
  PerformInBackgroundOption showProgress=PerformInBackgroundOption.DEAF;
  final Task.Backgroundable backgroundable=new Task.Backgroundable(event.getData(CommonDataKeys.PROJECT),"Backgroundable cancelable task",canBeCanceled,showProgress){
    @Override public void run(    @NotNull final ProgressIndicator indicator){
      final ProgressMonitorAdapter adapter=new ProgressMonitorAdapter(indicator);
      SRepository repository=event.getData(MPSCommonDataKeys.MPS_PROJECT).getRepository();
      adapter.start("Progress in progress...",4);
      int stepValue=1;
      adapter.step("Do simple work...");
      BackgroundableProgressAction_Action.this.doWork(event);
      adapter.advance(stepValue);
      if (adapter.isCanceled()) {
        return;
      }
      repository.getModelAccess().runReadAction(new Runnable(){
        public void run(){
          adapter.step("Do some work with Read Lock...");
          BackgroundableProgressAction_Action.this.doWork(event);
        }
      }
);
      adapter.advance(stepValue);
      if (adapter.isCanceled()) {
        return;
      }
      repository.getModelAccess().runWriteAction(new Runnable(){
        public void run(){
          adapter.step("Do some work with Write Lock...");
          BackgroundableProgressAction_Action.this.doWork(event);
        }
      }
);
      adapter.advance(stepValue);
      if (adapter.isCanceled()) {
        return;
      }
      adapter.step("Finishing...");
      BackgroundableProgressAction_Action.this.doWork(event);
      adapter.advance(stepValue);
      if (adapter.isCanceled()) {
        return;
      }
      adapter.done();
    }
    @Override public void onCancel(){
      super.onCancel();
    }
  }
;
  ApplicationManager.getApplication().invokeLater(new Runnable(){
    public void run(){
      ProgressManager.getInstance().run(backgroundable);
    }
  }
);
}
