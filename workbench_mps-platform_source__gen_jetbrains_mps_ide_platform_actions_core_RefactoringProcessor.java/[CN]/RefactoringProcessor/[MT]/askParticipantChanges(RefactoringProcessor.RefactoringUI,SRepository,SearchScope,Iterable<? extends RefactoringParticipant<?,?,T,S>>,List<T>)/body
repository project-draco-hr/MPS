{
  final Map<RefactoringParticipant,RefactoringParticipant.ParticipantState<?,?,T,S>> changes=MapSequence.fromMap(new HashMap<RefactoringParticipant,RefactoringParticipant.ParticipantState<?,?,T,S>>());
  final Wrappers._T<List<RefactoringParticipant.Option>> options=new Wrappers._T<List<RefactoringParticipant.Option>>();
  refactoringUI.prepare(new Runnable(){
    public void run(){
      for (      RefactoringParticipant<?,?,T,S> participant : Sequence.fromIterable(participants)) {
        MapSequence.fromMap(changes).put(participant,RefactoringParticipant.ParticipantState.create(participant,nodes));
      }
      options.value=MapSequence.fromMap(changes).translate(new ITranslator2<IMapping<RefactoringParticipant,RefactoringParticipant.ParticipantState<?,?,T,S>>,RefactoringParticipant.Option>(){
        public Iterable<RefactoringParticipant.Option> translate(        IMapping<RefactoringParticipant,RefactoringParticipant.ParticipantState<?,?,T,S>> it){
          return it.value().getAvaliableOptions(repository);
        }
      }
).distinct().sort(new ISelector<RefactoringParticipant.Option,String>(){
        public String select(        RefactoringParticipant.Option it){
          return it.getDescription();
        }
      }
,true).toListSequence();
    }
  }
);
  final List<RefactoringParticipant.Option> selectedOptions=refactoringUI.selectParticipants(options.value);
  if (selectedOptions == null) {
    return null;
  }
  final Wrappers._boolean cancelled=new Wrappers._boolean(false);
  refactoringUI.runSearch(new _FunctionTypes._void_P1_E0<ProgressMonitor>(){
    public void invoke(    ProgressMonitor progressMonitor){
      int steps=MapSequence.fromMap(changes).count();
      progressMonitor.start("Searching for usages",steps);
      for (      IMapping<RefactoringParticipant,RefactoringParticipant.ParticipantState<?,?,T,S>> participantStates : MapSequence.fromMap(changes)) {
        try {
          participantStates.value().findChanges(repository,selectedOptions,searchScope,progressMonitor.subTask(1,SubProgressKind.AS_COMMENT));
        }
 catch (        RuntimeException e) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Exception during usages search",e);
          }
          cancelled.value=true;
          break;
        }
        if (progressMonitor.isCanceled()) {
          cancelled.value=true;
          break;
        }
      }
      progressMonitor.done();
    }
  }
);
  if (cancelled.value) {
    return null;
  }
  return changes;
}
