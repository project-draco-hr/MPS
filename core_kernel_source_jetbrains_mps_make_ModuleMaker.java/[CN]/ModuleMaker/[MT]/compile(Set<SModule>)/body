{
  boolean hasAnythingToCompile=false;
  List<IMessage> messages=new ArrayList<IMessage>();
  Project project=null;
  for (  SModule m : modules) {
    if (project == null) {
      SRepository repository=m.getRepository();
      if (repository instanceof ProjectRepository) {
        project=((ProjectRepository)repository).getProject();
      }
 else       if (repository instanceof MPSModuleRepository) {
        Set<MPSModuleOwner> owners=((MPSModuleRepository)repository).getOwners(m);
        for (        MPSModuleOwner owner : owners) {
          if (owner instanceof Project) {
            project=((Project)owner);
          }
        }
      }
    }
    if (isExcluded(m))     continue;
    hasAnythingToCompile=true;
  }
  if (!hasAnythingToCompile) {
    return new MPSCompilationResult(0,0,false,Collections.<SModule>emptySet());
  }
  JavaCompiler compiler=new JavaCompiler();
  boolean hasJavaToCompile=false;
  boolean hasFilesToCopyOrDelete=false;
  myTracer.push("preparing to compile",false);
  Set<SModule> modulesWithRemovals=new HashSet<SModule>();
  for (  SModule m : modules) {
    if (areClassesUpToDate(m))     continue;
    if (!getJavaFacet(m).isCompileInMps()) {
      String text="Module which compiled in IDEA depends on module which has to be compiled in MPS:" + m.getModuleName();
      messages.add(createMessage(MessageKind.WARNING,text,m));
      myHandler.handle(createMessage(MessageKind.INFORMATION,text,m));
      continue;
    }
    ModuleSources sources=getModuleSources(m);
    hasFilesToCopyOrDelete|=!sources.isResourcesUpToDate();
    hasJavaToCompile|=!sources.isJavaUpToDate();
    for (    File f : sources.getFilesToDelete()) {
      f.delete();
      modulesWithRemovals.add(m);
    }
    for (    JavaFile f : sources.getFilesToCompile()) {
      compiler.addSource(f.getClassName(),f.getContents());
      myContainingModules.put(f.getClassName(),m);
    }
  }
  myTracer.pop();
  if (!hasJavaToCompile && !hasFilesToCopyOrDelete) {
    return new MPSCompilationResult(0,0,false,Collections.<SModule>emptySet(),messages);
  }
  myTracer.push("invalidating classpath",false);
  for (  SModule module : modulesWithRemovals) {
    invalidateCompiledClasses(module);
  }
  myTracer.pop();
  Set<SModule> changedModules=new HashSet<SModule>();
  MyCompilationResultAdapter listener=null;
  if (hasJavaToCompile) {
    myTracer.push("compiling java",false);
    IClassPathItem classPathItems=computeDependenciesClassPath(modules);
    listener=new MyCompilationResultAdapter(modules,classPathItems,messages);
    compiler.addCompilationResultListener(listener);
    myTracer.push("eclipse compiler",true);
    if (project == null) {
      compiler.compile(classPathItems);
    }
 else {
      JavaCompilerOptions javaCompilerOptions=JavaCompilerOptionsComponent.getInstance().getJavaCompilerOptions(project);
      compiler.compile(classPathItems,javaCompilerOptions);
    }
    myTracer.pop();
    changedModules.addAll(listener.myChangedModules);
    compiler.removeCompilationResultListener(listener);
    myTracer.pop();
  }
  myTracer.push("copying resources",false);
  for (  SModule module : modules) {
    ModuleSources sources=getModuleSources(module);
    for (    ResourceFile toCopy : sources.getResourcesToCopy()) {
      String fqName=toCopy.getPath();
      fqName=fqName.substring(0,fqName.length() - toCopy.getFile().getName().length());
      String path=fqName.replace('/',File.separatorChar) + toCopy.getFile().getName();
      if (new File(toCopy.getFile().getAbsolutePath()).exists()) {
        IFile classesGen=getJavaFacet(module).getClassesGen();
        if (classesGen != null) {
          FileUtil.copyFile(new File(toCopy.getFile().getAbsolutePath()),new File(classesGen.getDescendant(path).getPath()));
        }
 else {
        }
      }
    }
  }
  myTracer.pop();
  myTracer.push("updating classpath",false);
  for (  SModule module : changedModules) {
    invalidateCompiledClasses(module);
  }
  myTracer.pop();
  for (  SModule module : modulesWithRemovals) {
    if (!changedModules.contains(module)) {
      myHandler.handle(createMessage(MessageKind.WARNING,"Module with removals not in changed modules: " + module,module));
    }
  }
  if (hasJavaToCompile && changedModules.isEmpty()) {
    myHandler.handle(createMessage(MessageKind.ERROR,"has java to compile but changed modules is empty",null));
  }
  if (!hasJavaToCompile && !changedModules.isEmpty()) {
    myHandler.handle(createMessage(MessageKind.ERROR,"has not java to compile but changed modules is not empty",null));
  }
  return new MPSCompilationResult(listener == null ? 0 : listener.getErrorCount(),0,false,changedModules,messages);
}
