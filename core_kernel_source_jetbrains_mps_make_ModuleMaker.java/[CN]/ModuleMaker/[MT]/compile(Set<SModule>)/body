{
  boolean hasAnythingToCompile=false;
  List<MyMessage> messages=new ArrayList<MyMessage>();
  for (  SModule m : modules) {
    if (isExcluded(m))     continue;
    hasAnythingToCompile=true;
  }
  if (!hasAnythingToCompile) {
    return new MPSCompilationResult(0,0,false,Collections.<SModule>emptySet());
  }
  JavaCompiler compiler=new JavaCompiler();
  boolean hasJavaToCompile=false;
  boolean hasFilesToCopyOrDelete=false;
  ttrace.push("preparing to compile",false);
  Set<SModule> modulesWithRemovals=new HashSet<SModule>();
  for (  SModule m : modules) {
    if (areClassesUpToDate(m))     continue;
    if (!getJavaFacet(m).isCompileInMps()) {
      String text="Module which compiled in IDEA depend on module which has to be compiled in MPS:" + m.getModuleName();
      messages.add(new MyMessage(MessageKind.WARNING,text,m));
      LOG.debug(text,m);
      continue;
    }
    ModuleSources sources=getModuleSources(m);
    hasFilesToCopyOrDelete|=!sources.isResourcesUpToDate();
    hasJavaToCompile|=!sources.isJavaUpToDate();
    for (    File f : sources.getFilesToDelete()) {
      f.delete();
      modulesWithRemovals.add(m);
    }
    for (    JavaFile f : sources.getFilesToCompile()) {
      compiler.addSource(f.getClassName(),f.getContents());
      myContainingModules.put(f.getClassName(),m);
    }
  }
  ttrace.pop();
  if (!hasJavaToCompile && !hasFilesToCopyOrDelete) {
    return new MPSCompilationResult(0,0,false,Collections.<SModule>emptySet(),messages);
  }
  ttrace.push("invalidating classpath",false);
  for (  SModule module : modulesWithRemovals) {
    invalidateCompiledClasses(module);
  }
  ttrace.pop();
  Set<SModule> changedModules=new HashSet<SModule>();
  MyCompilationResultAdapter listener=null;
  if (hasJavaToCompile) {
    ttrace.push("compiling java",false);
    IClassPathItem classPathItems=computeDependenciesClassPath(modules);
    listener=new MyCompilationResultAdapter(modules,classPathItems,messages);
    compiler.addCompilationResultListener(listener);
    ttrace.push("eclipse compiler",true);
    compiler.compile(classPathItems);
    ttrace.pop();
    changedModules.addAll(listener.myChangedModules);
    compiler.removeCompilationResultListener(listener);
    ttrace.pop();
  }
  ttrace.push("copying resources",false);
  for (  SModule module : modules) {
    ModuleSources sources=getModuleSources(module);
    for (    ResourceFile toCopy : sources.getResourcesToCopy()) {
      String fqName=toCopy.getPath();
      fqName=fqName.substring(0,fqName.length() - toCopy.getFile().getName().length());
      String path=fqName.replace('/',File.separatorChar) + toCopy.getFile().getName();
      if (new File(toCopy.getFile().getAbsolutePath()).exists()) {
        IFile classesGen=getJavaFacet(module).getClassesGen();
        if (classesGen != null) {
          FileUtil.copyFile(new File(toCopy.getFile().getAbsolutePath()),new File(classesGen.getDescendant(path).getPath()));
        }
 else {
        }
      }
    }
  }
  ttrace.pop();
  ttrace.push("updating classpath",false);
  for (  SModule module : modules) {
    invalidateCompiledClasses(module);
  }
  ttrace.pop();
  if (hasJavaToCompile && changedModules.isEmpty()) {
    LOG.error("has java to compile but changed modules is empty");
  }
  if (!hasJavaToCompile && !changedModules.isEmpty()) {
    LOG.error("has not java to compile but changed modules is not empty");
  }
  return new MPSCompilationResult(listener == null ? 0 : listener.getErrorCount(),0,false,changedModules,messages);
}
