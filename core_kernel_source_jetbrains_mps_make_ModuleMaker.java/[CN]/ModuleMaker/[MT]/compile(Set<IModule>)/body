{
  boolean hasAnythingToCompile=false;
  for (  IModule m : modules) {
    if (m.isCompileInMPS()) {
      hasAnythingToCompile=true;
    }
  }
  if (!hasAnythingToCompile) {
    return new jetbrains.mps.plugin.CompilationResult(0,0,false);
  }
  IClassPathItem classPathItems=computeDependenciesClassPath(modules);
  CompositeClassPathItem classPath=(CompositeClassPathItem)classPathItems;
  System.out.println("compiling " + modules + " with classpath:");
  for (  IClassPathItem item : classPath.getChildren()) {
    System.out.println(item);
  }
  System.out.println("----\n\n");
  JavaCompiler compiler=new JavaCompiler(classPathItems);
  for (  IModule m : modules) {
    if (areClassesUpToDate(m)) {
      continue;
    }
    if (!m.isCompileInMPS()) {
      LOG.warning("Module which compiled in IDEA depend on module which has to be compiled in MPS:" + m.getModuleUID(),m);
      continue;
    }
    ModuleSources sources=getModuleSources(m);
    for (    IFile f : sources.getFilesToDelete()) {
      f.delete();
    }
    for (    JavaFile f : sources.getFilesToCompile()) {
      compiler.addSource(f.getContents(),f.getClassName());
      myContainingModules.put(f.getClassName(),m);
    }
  }
  compiler.compile();
  int errorCount=0;
  for (  CompilationResult cr : compiler.getCompilationResults()) {
    if (cr.getErrors() != null) {
      for (      CategorizedProblem cp : cr.getErrors()) {
        String messageStirng=new String(cp.getOriginatingFileName()) + " : " + cp.getMessage();
        if (cp.isWarning()) {
          LOG.warning(messageStirng);
        }
 else {
          LOG.error(messageStirng);
        }
      }
      errorCount+=cr.getErrors().length;
    }
    for (    ClassFile cf : cr.getClassFiles()) {
      String name=getName(cf.getCompoundName());
      String containerClassName=name;
      if (containerClassName.contains("$")) {
        int index=containerClassName.indexOf('$');
        containerClassName=containerClassName.substring(0,index);
      }
      if (myContainingModules.containsKey(containerClassName)) {
        IModule m=myContainingModules.get(containerClassName);
        File classesGen=m.getClassesGen().toFile();
        String packageName=NameUtil.namespaceFromLongName(name);
        File outputDir=new File(classesGen + File.separator + packageName.replace('.',File.separatorChar));
        outputDir.mkdirs();
        String className=NameUtil.shortNameFromLongName(name);
        File output=new File(outputDir,className + ".class");
        try {
          FileOutputStream os=new FileOutputStream(output);
          os.write(cf.getBytes());
          os.close();
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
 else {
        LOG.error("I don't know in which module's output path I should place class file for " + name);
      }
    }
  }
  for (  IModule module : modules) {
    ModuleSources sources=getModuleSources(module);
    for (    ResourceFile toCopy : sources.getResourcesToCopy()) {
      String fqName=toCopy.getFqName();
      fqName=fqName.substring(0,fqName.length() - toCopy.getFile().getName().length());
      String path=fqName.replace('.',File.separatorChar) + toCopy.getFile().getName();
      System.out.println("copy to " + path);
      FileUtil.copyFile(toCopy.getFile().toFile(),module.getClassesGen().child(path).toFile());
    }
  }
  for (  IModule module : modules) {
    module.reloadStubs();
    ((AbstractModule)module).updateRuntimeClassPath();
  }
  return new jetbrains.mps.plugin.CompilationResult(errorCount,0,false);
}
