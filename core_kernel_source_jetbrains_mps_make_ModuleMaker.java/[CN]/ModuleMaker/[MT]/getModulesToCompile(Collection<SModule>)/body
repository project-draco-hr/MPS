{
  ttrace.push("checking if " + candidates.size() + " modules are dirty",false);
  Set<SModule> allModules=candidates instanceof Set ? (Set<SModule>)candidates : new HashSet<SModule>(candidates);
  List<SModule> dirtyModules=new ArrayList<SModule>(candidates.size());
  for (  SModule m : candidates) {
    if (isDirty(m)) {
      dirtyModules.add(m);
    }
  }
  ttrace.pop();
  Map<SModule,Set<SModule>> backDependencies=new HashMap<SModule,Set<SModule>>();
  ttrace.push("building back deps",false);
  for (  SModule m : candidates) {
    for (    SModule dep : new GlobalModuleDependenciesManager(m).getModules(Deptype.COMPILE)) {
      Set<SModule> incoming=backDependencies.get(dep);
      if (incoming == null) {
        incoming=new HashSet<SModule>();
        backDependencies.put(dep,incoming);
      }
      incoming.add(m);
    }
  }
  ttrace.pop();
  ttrace.push("adding modules dependent on dirty ones - " + dirtyModules.size(),false);
  Set<SModule> toCompile=new LinkedHashSet<SModule>();
  LinkedList<SModule> queue=new LinkedList<SModule>(dirtyModules);
  while (!queue.isEmpty()) {
    SModule m=queue.removeFirst();
    if (allModules.contains(m)) {
      toCompile.add(m);
    }
    Set<SModule> backDeps=backDependencies.remove(m);
    if (backDeps != null) {
      queue.addAll(backDeps);
    }
  }
  ttrace.pop();
  return toCompile;
}
