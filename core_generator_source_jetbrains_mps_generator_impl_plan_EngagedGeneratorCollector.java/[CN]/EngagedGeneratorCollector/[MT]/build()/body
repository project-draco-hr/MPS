{
  myBadLanguages.clear();
  final Collection<String> initialLanguages=getAllLanguages();
  Queue<EngagedLanguage> queue=new ArrayDeque<EngagedLanguage>(resolveLanguages(initialLanguages,null,null));
  Set<String> processedLanguages=new HashSet<String>(initialLanguages);
  Map<EngagedLanguage,List<TemplateModule>> result=new HashMap<EngagedLanguage,List<TemplateModule>>();
  Set<EngagedLanguage> participatingLanguages=new HashSet<EngagedLanguage>(queue);
  while (!queue.isEmpty()) {
    EngagedLanguage next=queue.remove();
    for (    LanguageRuntime extendedLang : next.getLanguage().getExtendedLanguages()) {
      if (processedLanguages.add(extendedLang.getNamespace())) {
        final EngagedLanguage engaged=new EngagedLanguage(extendedLang,next,"EXTENDS");
        participatingLanguages.add(engaged);
        queue.add(engaged);
      }
    }
    HashSet<EngagedLanguage> targetLanguages=new HashSet<EngagedLanguage>();
    HashSet<EngagedLanguage> extraLanguages=new HashSet<EngagedLanguage>();
    result.put(next,collectLanguagesFromGenerators(next,targetLanguages,extraLanguages));
    for (    EngagedLanguage t : targetLanguages) {
      if (processedLanguages.add(t.getName())) {
        participatingLanguages.add(t);
        queue.add(t);
      }
    }
    for (    EngagedLanguage o : extraLanguages) {
      if (processedLanguages.add(o.getName())) {
        queue.add(o);
      }
    }
  }
  ArrayList<TemplateModule> all=new ArrayList<TemplateModule>();
  for (  Collection<TemplateModule> m : result.values()) {
    all.addAll(m);
  }
  myAccessibleGenerators=Collections.unmodifiableList(all);
  if (myOnlyLanguageRealUses) {
    ArrayList<TemplateModule> engaged=new ArrayList<TemplateModule>();
    participatingLanguages.retainAll(result.keySet());
    for (    EngagedLanguage pl : participatingLanguages) {
      engaged.addAll(result.get(pl));
    }
    myEngagedGenerators=Collections.unmodifiableList(engaged);
  }
 else {
    myEngagedGenerators=myAccessibleGenerators;
  }
}
