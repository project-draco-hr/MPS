{
  ProjectOperationContext ctx=new ProjectOperationContext(project);
  ModelAccess.instance().flushEventQueue();
  Future<IResult> res;
  IOperationContext context=new ProjectOperationContext(project);
  BuildMakeService bms=new BuildMakeService();
  MakeSession ms=new MakeSession(context,getMyMessageHandler(),true){
    @Override public IScript toScript(    ScriptBuilder scriptBuilder){
      scriptBuilder.withFacetNames(new IFacet.Name("jetbrains.mps.build.reduced.ReportFiles"),new IFacet.Name("jetbrains.mps.build.reduced.CollectHashes"));
      return scriptBuilder.toScript();
    }
  }
;
  final List<String> writtenFiles=ListSequence.fromList(new ArrayList<String>());
  final Map<String,String> fileHashes=MapSequence.fromMap(new HashMap<String,String>());
  final Iterable<IMResource> resources=Sequence.fromIterable(collectResources(ctx,go)).toListSequence();
  this.myOutputPaths=new ReducedGenerationWorker.ModuleOutputPaths(Sequence.fromIterable(resources).select(new ISelector<IMResource,IModule>(){
    public IModule select(    IMResource r){
      return r.module();
    }
  }
));
  IScriptController scriptCtl=configureFacets(resources,fileHashes,writtenFiles);
  try {
    res=bms.make(ms,resources,null,scriptCtl);
    if (!(res.get().isSucessful())) {
      myErrors.add("Make was not successful");
    }
    if (writtenFiles != null) {
      for (      String f : writtenFiles) {
        System.out.println("##WRITTEN##" + f);
      }
    }
  }
 catch (  InterruptedException e) {
    myErrors.add(e.toString());
  }
catch (  ExecutionException e) {
    myErrors.add(e.toString());
  }
}
