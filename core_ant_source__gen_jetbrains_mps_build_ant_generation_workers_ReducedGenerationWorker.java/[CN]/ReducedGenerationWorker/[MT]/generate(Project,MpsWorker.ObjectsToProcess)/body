{
  ProjectOperationContext ctx=new ProjectOperationContext(project);
  ModelAccess.instance().flushEventQueue();
  Future<IResult> res;
  IOperationContext context=new ProjectOperationContext(project);
  BuildMakeService bms=new BuildMakeService();
  MakeSession ms=new MakeSession(context,getMyMessageHandler(),true){
    @Override public IScript toScript(    ScriptBuilder scriptBuilder){
      scriptBuilder.withFacetNames(new IFacet.Name("jetbrains.mps.build.reduced.ReportFiles"),new IFacet.Name("jetbrains.mps.build.reduced.CollectHashes"));
      return scriptBuilder.toScript();
    }
  }
;
  final List<String> writtenFiles=ListSequence.fromList(new ArrayList<String>());
  final Map<String,String> fileHashes=MapSequence.fromMap(new HashMap<String,String>());
  final Iterable<IMResource> resources=Sequence.fromIterable(collectResources(ctx,go)).toListSequence();
  this.myOutputPaths=new ReducedGenerationWorker.ModuleOutputPaths(Sequence.fromIterable(resources).select(new ISelector<IMResource,IModule>(){
    public IModule select(    IMResource r){
      return r.module();
    }
  }
));
  final String outputRoot=myWhatToDo.getProperty("OUTPUT_ROOT_DIR");
  final String cachesOutputRoot=myWhatToDo.getProperty("CACHES_OUTPUT_ROOT_DIR");
  final boolean useTransientOutput=Sequence.fromIterable(resources).any(new IWhereFilter<IMResource>(){
    public boolean accept(    IMResource r){
      return r.module().getModuleDescriptor().isUseTransientOutput();
    }
  }
);
  this.myOutputRedirects=new ReducedGenerationWorker.MyOutputRedirects(outputRoot,cachesOutputRoot,useTransientOutput);
  this.myForeignRootPaths=new ReducedGenerationWorker.MyForeignRootPaths(myOutputPaths.getOutputPaths());
  IScriptController scriptCtl=configureFacets(fileHashes,writtenFiles);
  try {
    res=bms.make(ms,resources,null,scriptCtl);
    if (!(res.get().isSucessful())) {
      myErrors.add("Make was not successful");
    }
    if (writtenFiles != null) {
      for (      String f : writtenFiles) {
        System.out.println("##WRITTEN##" + f);
      }
    }
  }
 catch (  InterruptedException e) {
    myErrors.add(e.toString());
  }
catch (  ExecutionException e) {
    myErrors.add(e.toString());
  }
}
