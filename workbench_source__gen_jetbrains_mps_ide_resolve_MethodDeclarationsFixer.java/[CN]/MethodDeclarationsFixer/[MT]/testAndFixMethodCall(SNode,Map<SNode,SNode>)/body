{
  IMethodCall methodCall=(IMethodCall)BaseAdapter.fromNode(methodCallNode);
  BaseMethodDeclaration baseMethodDeclaration=methodCall.getBaseMethodDeclaration();
  String methodName;
  if (baseMethodDeclaration == null) {
    if (methodCall instanceof AnonymousClass) {
      Classifier classifier=((AnonymousClass)methodCall).getClassifier();
      if (classifier != null) {
        methodName=classifier.getName();
      }
 else {
        return;
      }
    }
 else {
      return;
    }
  }
 else {
    methodName=baseMethodDeclaration.getName();
  }
  List<Expression> actualArgs=methodCall.getActualArguments();
  List<? extends BaseMethodDeclaration> candidates=getCandidates(methodCall,methodName);
  if (candidates.isEmpty()) {
    return;
  }
  BaseMethodDeclaration newTarget=null;
  boolean good;
  Map<TypeVariableDeclaration,Type> typeByTypeVar=getTypeByTypeVar(methodCall);
  jetbrains.mps.util.Pair<List<? extends BaseMethodDeclaration>,Boolean> parmCountPair=MethodResolveUtil.selectByVisibilityReportNoGoodMethod(candidates,methodCall);
  List<? extends BaseMethodDeclaration> methodDeclarationsGoodParams=parmCountPair.o1;
  if (methodDeclarationsGoodParams.size() == 1) {
    newTarget=methodDeclarationsGoodParams.get(0);
    good=parmCountPair.o2;
  }
 else {
    parmCountPair=MethodResolveUtil.selectByParmCountReportNoGoodMethod(methodDeclarationsGoodParams,actualArgs);
    methodDeclarationsGoodParams=parmCountPair.o1;
    if (methodDeclarationsGoodParams.size() == 1) {
      newTarget=methodDeclarationsGoodParams.get(0);
      good=parmCountPair.o2;
    }
 else {
      jetbrains.mps.util.Pair<BaseMethodDeclaration,Boolean> parmTypesPair=MethodResolveUtil.chooseByParameterTypeReportNoGoodMethod(methodDeclarationsGoodParams,actualArgs,typeByTypeVar);
      newTarget=parmTypesPair.o1;
      good=parmTypesPair.o2;
    }
  }
  if (newTarget != null) {
    if (baseMethodDeclaration == null || (good && newTarget.getNode() != baseMethodDeclaration.getNode())) {
      reResolvedTargets.put(methodCall.getNode(),newTarget.getNode());
    }
    myMethodCallsToSetDecls.put(methodCall.getNode(),newTarget.getNode());
    myCheckedMethodCalls.add(methodCallNode);
    for (    Expression actualArgument : methodCall.getActualArguments()) {
      myParametersToCheckedMethodCalls.put(actualArgument.getNode(),methodCallNode);
    }
    SNode newTargetNode=newTarget.getNode();
    Set<SNode> nodeSet=myMethodDeclsToCheckedMethodCalls.get(newTargetNode);
    if (nodeSet == null) {
      nodeSet=new HashSet<SNode>();
      myMethodDeclsToCheckedMethodCalls.put(newTargetNode,nodeSet);
    }
    nodeSet.add(methodCallNode);
    Pair<String,String> key=new Pair<String,String>(newTarget.getConceptFQName(),methodName);
    Set<SNode> nodesByNameAndConcept=myMethodConceptsAndNamesToCheckedMethodCalls.get(key);
    if (nodesByNameAndConcept == null) {
      nodesByNameAndConcept=new HashSet<SNode>();
      myMethodConceptsAndNamesToCheckedMethodCalls.put(key,nodesByNameAndConcept);
    }
    nodesByNameAndConcept.add(methodCallNode);
  }
}
