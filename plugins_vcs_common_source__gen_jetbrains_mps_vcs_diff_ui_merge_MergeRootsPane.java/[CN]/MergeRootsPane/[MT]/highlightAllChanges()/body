{
  ListSequence.fromList(myChangeGroupLayouts).visitAll(new IVisitor<ChangeGroupLayout>(){
    public void visit(    ChangeGroupLayout b){
      b.invalidate();
    }
  }
);
  List<ModelChange> changesForRoot=ListSequence.fromList(myMergeSession.getChangesForRoot(myRootId)).where(new IWhereFilter<ModelChange>(){
    public boolean accept(    ModelChange ch){
      return !(myMergeSession.isChangeResolved(ch));
    }
  }
).toListSequence();
  for (  ModelChange change : ListSequence.fromList(changesForRoot)) {
    higlightChange(myResultEditor,myMergeSession.getResultModel(),true,change);
    if (myMergeSession.isMyChange(change)) {
      higlightChange(myMineEditor,myMergeSession.getMyModel(),false,change);
    }
 else {
      higlightChange(myRepositoryEditor,myMergeSession.getRepositoryModel(),false,change);
    }
  }
  ListSequence.fromList(myChangeGroupLayouts).visitAll(new IVisitor<ChangeGroupLayout>(){
    public void visit(    ChangeGroupLayout b){
      b.invalidate();
    }
  }
);
  myMineEditor.repaintAndRebuildEditorMessages();
  myResultEditor.repaintAndRebuildEditorMessages();
  myRepositoryEditor.repaintAndRebuildEditorMessages();
  int conflictingChanges=ListSequence.fromList(changesForRoot).where(new IWhereFilter<ModelChange>(){
    public boolean accept(    ModelChange ch){
      return Sequence.fromIterable(myMergeSession.getConflictedWith(ch)).isNotEmpty();
    }
  }
).count();
  myStatusBar.setText(MergeModelsDialog.generateUnresolvedChangesText(ListSequence.fromList(changesForRoot).count(),conflictingChanges));
}
