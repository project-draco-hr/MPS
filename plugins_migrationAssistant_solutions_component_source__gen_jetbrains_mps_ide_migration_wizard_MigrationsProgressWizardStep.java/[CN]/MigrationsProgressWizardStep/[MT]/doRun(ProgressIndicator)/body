{
  Map<ProjectMigrationWithOptions.Option,Object> options=myInitialStep.getOptions();
  setFraction(progress,ProgressEstimation.initial());
  boolean cleanNotification=false;
  List<MigrationManager.MigrationStep> cleanupMigrations=ListSequence.fromList(new ArrayList<MigrationManager.MigrationStep>());
  int cleanupStepsCount=myManager.projectStepsCount(true);
  int stepNum=0;
  while (true) {
    MigrationManager.MigrationStep step=myManager.nextProjectStep(options,true);
    if (step == null) {
      break;
    }
    ListSequence.fromList(cleanupMigrations).addElement(step);
    if (!(executeSingleStep(step))) {
      break;
    }
    if (!(cleanNotification)) {
      cleanNotification=true;
      addElementToMigrationList("Cleaning project...");
    }
    stepNum++;
    setFraction(progress,ProgressEstimation.cleanupMigrations(1.0 * stepNum / cleanupStepsCount));
  }
  addElementToMigrationList("Checking migrations consistency...");
  List<ScriptApplied.ScriptAppliedReference> missingMigrations=myManager.getMissingMigrations();
  setFraction(progress,ProgressEstimation.migrationsCheck(1.0));
  if (ListSequence.fromList(missingMigrations).isNotEmpty()) {
    myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.MigrationsMissingError(missingMigrations));
    addElementToMigrationList("Some migrations are missing. Press 'Next' to continue.");
    return;
  }
  addElementToMigrationList("Checking models...");
  final jetbrains.mps.project.Project mpsProject=getMPSProject();
  mpsProject.getRepository().getModelAccess().runReadAction(new Runnable(){
    public void run(){
      Iterable<SModule> modules=MigrationsUtil.getMigrateableModulesFromProject(mpsProject);
      if (MigrationCheckUtil.haveProblems(modules,mySearchBrokenReferences,new _FunctionTypes._void_P1_E0<Double>(){
        public void invoke(        Double fraction){
          setFraction(progress,ProgressEstimation.preCheck(fraction));
        }
      }
)) {
        boolean canIgnore=mySearchBrokenReferences && !(MigrationCheckUtil.haveProblems(modules,false,new _FunctionTypes._void_P1_E0<Double>(){
          public void invoke(          Double fraction){
            setFraction(progress,ProgressEstimation.fallbackPreCheck(fraction));
          }
        }
));
        myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.PreCheckError(canIgnore));
      }
    }
  }
);
  if (myErrorContainer.getErrorDescriptor() != null) {
    for (    MigrationManager.MigrationStep cleanupMigration : ListSequence.fromList(cleanupMigrations)) {
      cleanupMigration.forceExecutionNextTime();
    }
    addElementToMigrationList("Can't start migration: errors detected. Press 'Next' to continue.");
    return;
  }
  int projectStepsCount=myManager.projectStepsCount(false);
  stepNum=0;
  while (executeSingleStep(myManager.nextProjectStep(options,false))) {
    stepNum++;
    setFraction(progress,ProgressEstimation.projectMigrations(1.0 * stepNum / projectStepsCount));
  }
  if (myErrorContainer.getErrorDescriptor() != null) {
    addElementToMigrationList("Exception while running migration. Press 'Next' to continue.");
    return;
  }
  int languageStepsCount=myManager.moduleStepsCount();
  stepNum=0;
  while (executeSingleStep(myManager.nextModuleStep())) {
    stepNum++;
    setFraction(progress,ProgressEstimation.languageMigrations(1.0 * stepNum / languageStepsCount));
  }
  if (myErrorContainer.getErrorDescriptor() != null) {
    addElementToMigrationList("Exception while running migration. Press 'Next' to continue.");
    return;
  }
  addElementToMigrationList("Saving changed models...");
  mpsProject.getModelAccess().runWriteInEDT(new Runnable(){
    public void run(){
      mpsProject.getRepository().saveAll();
    }
  }
);
  setFraction(progress,ProgressEstimation.saving(1.0));
  final Wrappers._boolean haveBadCode=new Wrappers._boolean(false);
  addElementToMigrationList("Checking models...");
  mpsProject.getRepository().getModelAccess().runReadAction(new Runnable(){
    public void run(){
      Iterable<SModule> modules=MigrationsUtil.getMigrateableModulesFromProject(mpsProject);
      final Wrappers._int moduleNum=new Wrappers._int(0);
      haveBadCode.value=MigrationCheckUtil.haveProblems(modules,mySearchBrokenReferences,new _FunctionTypes._void_P1_E0<Double>(){
        public void invoke(        Double fraction){
          moduleNum.value++;
          setFraction(progress,ProgressEstimation.postCheck(fraction));
        }
      }
);
    }
  }
);
  addElementToMigrationList("Finding not migrated code...");
  mpsProject.getRepository().getModelAccess().runReadAction(new Runnable(){
    public void run(){
      Iterable<SModule> modules=MigrationsUtil.getMigrateableModulesFromProject(mpsProject);
      final Wrappers._int moduleNum=new Wrappers._int(0);
      boolean haveNotMigrated=MigrationCheckUtil.haveNotMigrated(modules,getMPSProject().getComponent(MigrationComponent.class),new _FunctionTypes._void_P1_E0<Double>(){
        public void invoke(        Double fraction){
          moduleNum.value++;
          setFraction(progress,ProgressEstimation.nonMigratedCheck(fraction));
        }
      }
);
      if (haveBadCode.value || haveNotMigrated) {
        myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.PostCheckError(haveBadCode.value,haveNotMigrated));
      }
    }
  }
);
  if (myErrorContainer.getErrorDescriptor() != null) {
    addElementToMigrationList("Problems are detected after executing migrations. Press 'Next' to continue.");
    return;
  }
  addElementToMigrationList("Done!");
}
