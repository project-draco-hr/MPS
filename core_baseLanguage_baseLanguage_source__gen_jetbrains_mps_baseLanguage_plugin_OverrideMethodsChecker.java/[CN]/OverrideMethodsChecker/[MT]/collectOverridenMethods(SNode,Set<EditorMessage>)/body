{
  List<SNode> rawDerivedClassifiers=ClassifierSuccessorsFinder.getDerivedClassifiers(container,GlobalScope.getInstance());
  Iterable<SNode> derivedClassifiers=ListSequence.fromList(rawDerivedClassifiers).select(new ISelector<SNode,SNode>(){
    public SNode select(    SNode it){
      return SNodeOperations.as(it,"jetbrains.mps.baseLanguage.structure.Classifier");
    }
  }
).where(new IWhereFilter<SNode>(){
    public boolean accept(    SNode it){
      return (it != null);
    }
  }
);
  if (Sequence.fromIterable(derivedClassifiers).isEmpty()) {
    return;
  }
  boolean isInterface=SNodeOperations.isInstanceOf(container,"jetbrains.mps.baseLanguage.structure.Interface");
  StringBuffer superClassifierTooltip=new StringBuffer();
  if (Sequence.fromIterable(derivedClassifiers).count() > MAX_MESSAGE_NUMBER) {
    superClassifierTooltip.append((isInterface ? "Has implementations" : "Has subclasses"));
  }
 else {
    superClassifierTooltip.append((isInterface ? "Is implemented by" : "Is subclassed by"));
    for (    SNode subClassifier : Sequence.fromIterable(derivedClassifiers)) {
      superClassifierTooltip.append(TOOLTIP_INDENT);
      superClassifierTooltip.append(getPresentation(subClassifier));
    }
  }
  SetSequence.fromSet(messages).addElement(new SubclassedClassifierEditorMessage(container,this,superClassifierTooltip.toString(),isInterface));
  Map<String,Set<SNode>> nameToMethodsMap=MapSequence.fromMap(new HashMap<String,Set<SNode>>());
  for (  SNode method : ListSequence.fromList(SLinkOperations.getTargets(container,"method",true)).where(new IWhereFilter<SNode>(){
    public boolean accept(    SNode it){
      return OverridingMethodsFinder.canBeOverriden(it);
    }
  }
)) {
    SetSequence.fromSet(OverridingMethodsFinder.safeGet(nameToMethodsMap,SPropertyOperations.getString(method,"name"))).addElement(method);
  }
  if (MapSequence.fromMap(nameToMethodsMap).isEmpty()) {
    return;
  }
  Map<SNode,Set<Tuples._2<SNode,SNode>>> overridenToOverridingMethodsMap=createOverridenToOverridingMethodsMap(nameToMethodsMap,derivedClassifiers);
  for (  SNode overridenMethod : SetSequence.fromSet(MapSequence.fromMap(overridenToOverridingMethodsMap).keySet())) {
    boolean overriden=!(SPropertyOperations.getBoolean(overridenMethod,"isAbstract"));
    StringBuffer tooltip=new StringBuffer("Is ");
    tooltip.append((overriden ? "overriden" : "implemented"));
    tooltip.append(" in");
    int messageCounter=0;
    for (Iterator<Tuples._2<SNode,SNode>> it=SetSequence.fromSet(MapSequence.fromMap(overridenToOverridingMethodsMap).get(overridenMethod)).iterator(); it.hasNext(); ) {
      SNode overridingClassifier=it.next()._1();
      tooltip.append(TOOLTIP_INDENT);
      tooltip.append(getPresentation(overridingClassifier));
      if (++messageCounter == MAX_MESSAGE_NUMBER && it.hasNext()) {
        tooltip.append(TOOLTIP_INDENT);
        tooltip.append("...");
        break;
      }
    }
    SetSequence.fromSet(messages).addElement(new OverridenMethodEditorMessage(overridenMethod,this,tooltip.toString(),overriden));
  }
}
