{
  List<SNode> derivedClassifiers=ClassifierSuccessorsFinder.getDerivedClassifiers(container,GlobalScope.getInstance());
  if (ListSequence.fromList(derivedClassifiers).isEmpty()) {
    return;
  }
  boolean isInterface=SNodeOperations.isInstanceOf(container,"jetbrains.mps.baseLanguage.structure.Interface");
  StringBuffer superClassifierTooltip=new StringBuffer();
  if (ListSequence.fromList(derivedClassifiers).count() > MAX_MESSAGE_NUMBER) {
    superClassifierTooltip.append((isInterface ? "Has implementations" : "Has subclasses"));
  }
 else {
    superClassifierTooltip.append((isInterface ? "Is implemented by" : "Is subclassed by"));
    for (    SNode subClassifier : ListSequence.fromList(derivedClassifiers)) {
      superClassifierTooltip.append(TOOLTIP_INDENT);
      superClassifierTooltip.append(getClassifierPresentation(subClassifier));
      if (SNodeOperations.isInstanceOf(subClassifier,"jetbrains.mps.baseLanguage.structure.EnumClass")) {
        for (        SNode enumConstant : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(subClassifier,"jetbrains.mps.baseLanguage.structure.EnumClass"),"enumConstant",true))) {
          superClassifierTooltip.append(TOOLTIP_INDENT);
          superClassifierTooltip.append(getEnumConstantPresentation(enumConstant));
        }
      }
    }
  }
  SetSequence.fromSet(messages).addElement(new SubclassedClassifierEditorMessage(container,this,superClassifierTooltip.toString(),isInterface));
  Map<String,Set<SNode>> nameToMethodsMap=MapSequence.fromMap(new HashMap<String,Set<SNode>>());
  for (  SNode method : ListSequence.fromList(SLinkOperations.getTargets(container,"method",true)).where(new IWhereFilter<SNode>(){
    public boolean accept(    SNode it){
      return OverridingMethodsFinder.canBeOverriden(it);
    }
  }
)) {
    SetSequence.fromSet(OverridingMethodsFinder.safeGet(nameToMethodsMap,SPropertyOperations.getString(method,"name"))).addElement(method);
  }
  if (MapSequence.fromMap(nameToMethodsMap).isEmpty()) {
    return;
  }
  Map<SNode,Set<SNode>> overridenToOverridingMethodsMap=createOverridenToOverridingMethodsMap(nameToMethodsMap,derivedClassifiers);
  for (  SNode overridenMethod : SetSequence.fromSet(MapSequence.fromMap(overridenToOverridingMethodsMap).keySet())) {
    if (SPropertyOperations.getBoolean(overridenMethod,"isFinal")) {
      continue;
    }
    boolean overriden=!(SPropertyOperations.getBoolean(overridenMethod,"isAbstract"));
    StringBuffer tooltip=new StringBuffer("Is ");
    tooltip.append((overriden ? "overriden" : "implemented"));
    tooltip.append(" in");
    int messageCounter=0;
    for (Iterator<SNode> it=SetSequence.fromSet(MapSequence.fromMap(overridenToOverridingMethodsMap).get(overridenMethod)).iterator(); it.hasNext(); ) {
      SNode overridingMethod=it.next();
      tooltip.append(TOOLTIP_INDENT);
      tooltip.append(getPresentation(SNodeOperations.getParent(overridingMethod)));
      if (++messageCounter == MAX_MESSAGE_NUMBER && it.hasNext()) {
        tooltip.append(TOOLTIP_INDENT);
        tooltip.append("...");
        break;
      }
    }
    SetSequence.fromSet(messages).addElement(new OverridenMethodEditorMessage(overridenMethod,this,tooltip.toString(),overriden));
  }
}
