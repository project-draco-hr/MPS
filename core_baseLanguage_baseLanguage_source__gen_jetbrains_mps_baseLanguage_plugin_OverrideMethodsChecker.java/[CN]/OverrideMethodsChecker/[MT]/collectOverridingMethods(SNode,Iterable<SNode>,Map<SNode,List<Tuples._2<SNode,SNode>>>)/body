{
  List<SNode> methodsCopy=ListSequence.fromListWithValues(new ArrayList<SNode>(),methods);
  for (  SNode classifierMethod : ListSequence.fromList(SLinkOperations.getTargets(classifier,"method",true)).where(new IWhereFilter<SNode>(){
    public boolean accept(    SNode it){
      return canBeOverriden(it);
    }
  }
)) {
    for (Iterator<SNode> it=ListSequence.fromList(methodsCopy).iterator(); it.hasNext(); ) {
      SNode nextMethod=it.next();
      if (BaseMethodDeclaration_Behavior.call_hasSameSignature_1213877350435(classifierMethod,nextMethod)) {
        List<Tuples._2<SNode,SNode>> overridenMethods=MapSequence.fromMap(overridingToOverridenMethodsMap).get(nextMethod);
        if (overridenMethods == null) {
          overridenMethods=ListSequence.fromList(new ArrayList<Tuples._2<SNode,SNode>>());
          MapSequence.fromMap(overridingToOverridenMethodsMap).put(nextMethod,overridenMethods);
        }
        ListSequence.fromList(overridenMethods).addElement(MultiTuple.<SNode,SNode>from(classifierMethod,classifier));
        it.remove();
        break;
      }
    }
  }
  if (!(ListSequence.fromList(methodsCopy).isEmpty())) {
    this.collectOverridingMethodsInClassifierHierarchy(classifier,methodsCopy,overridingToOverridenMethodsMap);
  }
}
