{
  final List<SearchResult<ModelCheckerIssue>> results=ListSequence.fromList(new ArrayList<SearchResult<ModelCheckerIssue>>());
  if (model == null || model == null || model.getModule() == null) {
    return results;
  }
  if (monitor.isCanceled()) {
    return results;
  }
  monitor.start("illegal references",1);
  if (LanguageAspect.STRUCTURE.is(model)) {
    for (    SNode concept : ListSequence.fromList(SModelOperations.roots(model,MetaAdapterFactory.getConcept(0xc72da2b97cce4447L,0x8389f407dc1158b7L,0x1103553c5ffL,"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration")))) {
      for (      SNode ref : ListSequence.fromList(SLinkOperations.getChildren(concept,MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L,0x8389f407dc1158b7L,0x1103553c5ffL,0xf979c3ba6bL,"linkDeclaration"))).where(new IWhereFilter<SNode>(){
        public boolean accept(        SNode it){
          return SPropertyOperations.hasValue(it,MetaAdapterFactory.getProperty(0xc72da2b97cce4447L,0x8389f407dc1158b7L,0xf979bd086aL,0xf980556927L,"metaClass"),"reference","reference");
        }
      }
)) {
        SNode target=SLinkOperations.getTarget(ref,MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L,0x8389f407dc1158b7L,0xf979bd086aL,0xf98055fef0L,"target"));
        if (SNodeOperations.isInstanceOf(target,MetaAdapterFactory.getConcept(0xc72da2b97cce4447L,0x8389f407dc1158b7L,0xf979ba0450L,"jetbrains.mps.lang.structure.structure.ConceptDeclaration"))) {
          SNode decl=SNodeOperations.cast(target,MetaAdapterFactory.getConcept(0xc72da2b97cce4447L,0x8389f407dc1158b7L,0xf979ba0450L,"jetbrains.mps.lang.structure.structure.ConceptDeclaration"));
          if (SPropertyOperations.hasValue(decl,MetaAdapterFactory.getProperty(0xc72da2b97cce4447L,0x8389f407dc1158b7L,0xf979ba0450L,0x4b014033eedc8a48L,"staticScope"),"none",null)) {
            SpecificChecker.addIssue(results,ref,"Reference to a non-referenceable concept found: " + SPropertyOperations.getString(target,MetaAdapterFactory.getProperty(0xceab519525ea4f22L,0x9b92103b95ca8c0cL,0x110396eaaa4L,0x110396ec041L,"name")),ModelChecker.SEVERITY_ERROR,"reference to a non-referenceable concept",null);
          }
        }
      }
      if (SNodeOperations.isInstanceOf(concept,MetaAdapterFactory.getConcept(0xc72da2b97cce4447L,0x8389f407dc1158b7L,0xf979ba0450L,"jetbrains.mps.lang.structure.structure.ConceptDeclaration")) && SPropertyOperations.hasValue(SNodeOperations.cast(concept,MetaAdapterFactory.getConcept(0xc72da2b97cce4447L,0x8389f407dc1158b7L,0xf979ba0450L,"jetbrains.mps.lang.structure.structure.ConceptDeclaration")),MetaAdapterFactory.getProperty(0xc72da2b97cce4447L,0x8389f407dc1158b7L,0xf979ba0450L,0x4b014033eedc8a48L,"staticScope"),"none",null)) {
        if (BehaviorReflection.invokeNonVirtual(Boolean.TYPE,concept,"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration","call_isSubconceptOf_8134325418312549386",new Object[]{SNodeOperations.getNode("r:00000000-0000-4000-0000-011c89590288(jetbrains.mps.lang.core.structure)","1169194658468")})) {
          SpecificChecker.addIssue(results,concept,"INamedConcept inheritors are usually referenceable",ModelChecker.SEVERITY_WARNING,"non-referenceable named concept",null);
        }
      }
    }
  }
  for (  SNode node : ListSequence.fromList(SModelOperations.nodes(model,null))) {
    if (monitor.isCanceled()) {
      break;
    }
    for (    SReference ref : Sequence.fromIterable(SNodeOperations.getReferences(node))) {
      if ((AttributeOperations.getAttribute(node,new IAttributeDescriptor.LinkAttribute(MetaAdapterFactory.getConcept(0xb401a68083254110L,0x8fd384331ff25befL,0xfd7f44d616L,"jetbrains.mps.lang.generator.structure.ReferenceMacro"),ref.getLink())) != null)) {
        continue;
      }
      SNode target=jetbrains.mps.util.SNodeOperations.getTargetNodeSilently(ref);
      if (target == null) {
        SpecificChecker.addIssue(results,node,"Unresolved reference: " + SLinkOperations.getResolveInfo(ref),ModelChecker.SEVERITY_ERROR,"unresolved reference",null);
        continue;
      }
      checkNode(results,target,node,false,target);
      SNode curr=target;
      while (!(SNodeOperations.isAttribute(curr))) {
        curr=SNodeOperations.getParent(curr);
        if (curr == null) {
          break;
        }
        checkNode(results,curr,node,true,target);
      }
    }
  }
  return results;
}
