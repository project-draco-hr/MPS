{
  super("Check static field reference scopes (classifier)");
  this.addRefactoring(new AbstractMigrationRefactoring(operationContext){
    public String getName(){
      return "Testing";
    }
    public String getAdditionalInfo(){
      return "Testing";
    }
    public String getFqNameOfConceptToSearchInstances(){
      return "jetbrains.mps.baseLanguage.structure.StaticFieldReference";
    }
    public boolean isApplicableInstanceNode(    final SNode node){
      String excludingPrefix="123collection";
      String startsFrom="";
      SReference ref=SNodeOperations.getReference(node,SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.StaticFieldReference","classifier"));
      if (ref == null) {
        return false;
      }
      if (Utils.isInComment(node)) {
        return false;
      }
      String name=SPropertyOperations.getString(SLinkOperations.getTarget(node,"classifier",false),"name");
      if (StringUtils.isEmpty(name)) {
        return false;
      }
      if (name.startsWith(excludingPrefix)) {
        return false;
      }
      if (!(name.startsWith(startsFrom))) {
        return false;
      }
      _FunctionTypes._return_P0_E0<? extends Scope> oldScopeProvider=new _FunctionTypes._return_P0_E0<ISearchScope.Adapter>(){
        public ISearchScope.Adapter invoke(){
          return new ISearchScope.Adapter(new VisibleClassifiersScope(node,IClassifiersSearchScope.CLASSIFFIER,GlobalScope.getInstance()){
            @NotNull @Override public List<SNode> getClassifiers(){
              Set<SNode> enclosingClassifierAncestors=SetSequence.fromSet(new HashSet<SNode>());
              SetSequence.fromSet(enclosingClassifierAncestors).addSequence(ListSequence.fromList(SNodeOperations.getAncestors(node,"jetbrains.mps.baseLanguage.structure.Classifier",false)));
              List<SNode> result=new ArrayList<SNode>();
              for (              SNode classifier : ListSequence.fromList(super.getClassifiers())) {
                if (SPropertyOperations.getBoolean(classifier,"nonStatic")) {
                  continue;
                }
                if (SNodeOperations.isInstanceOf(classifier,"jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
                  continue;
                }
                List<SNode> ancestors=SNodeOperations.getAncestors(classifier,null,true);
                if (ListSequence.fromList(ancestors).where(new IWhereFilter<SNode>(){
                  public boolean accept(                  SNode it){
                    return !(SNodeOperations.isInstanceOf(it,"jetbrains.mps.baseLanguage.structure.Classifier"));
                  }
                }
).isNotEmpty() && ListSequence.fromList(ancestors).intersect(SetSequence.fromSet(enclosingClassifierAncestors)).isEmpty()) {
                  continue;
                }
                result.add(classifier);
              }
              return result;
            }
          }
);
        }
      }
;
      _FunctionTypes._return_P0_E0<? extends Scope> newScopeProvider=new _FunctionTypes._return_P0_E0<Scope>(){
        public Scope invoke(){
          return ClassifierScopes.getClassesForStaticFieldReference(node,GlobalScope.getInstance());
        }
      }
;
      return !(Utils.checkScopes(node,Utils.getNodes("old scope",oldScopeProvider),Utils.getNodes("new scope/from ioperation",newScopeProvider),true));
    }
    public void doUpdateInstanceNode(    final SNode node){
      _FunctionTypes._return_P0_E0<? extends Scope> oldScopeProvider=new _FunctionTypes._return_P0_E0<ISearchScope.Adapter>(){
        public ISearchScope.Adapter invoke(){
          return new ISearchScope.Adapter(new VisibleClassifiersScope(node,IClassifiersSearchScope.CLASSIFFIER,GlobalScope.getInstance()){
            @NotNull @Override public List<SNode> getClassifiers(){
              Set<SNode> enclosingClassifierAncestors=SetSequence.fromSet(new HashSet<SNode>());
              SetSequence.fromSet(enclosingClassifierAncestors).addSequence(ListSequence.fromList(SNodeOperations.getAncestors(node,"jetbrains.mps.baseLanguage.structure.Classifier",false)));
              List<SNode> result=new ArrayList<SNode>();
              for (              SNode classifier : ListSequence.fromList(super.getClassifiers())) {
                if (SPropertyOperations.getBoolean(classifier,"nonStatic")) {
                  continue;
                }
                if (SNodeOperations.isInstanceOf(classifier,"jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
                  continue;
                }
                List<SNode> ancestors=SNodeOperations.getAncestors(classifier,null,true);
                if (ListSequence.fromList(ancestors).where(new IWhereFilter<SNode>(){
                  public boolean accept(                  SNode it){
                    return !(SNodeOperations.isInstanceOf(it,"jetbrains.mps.baseLanguage.structure.Classifier"));
                  }
                }
).isNotEmpty() && ListSequence.fromList(ancestors).intersect(SetSequence.fromSet(enclosingClassifierAncestors)).isEmpty()) {
                  continue;
                }
                result.add(classifier);
              }
              return result;
            }
          }
);
        }
      }
;
      _FunctionTypes._return_P0_E0<? extends Scope> newScopeProvider=new _FunctionTypes._return_P0_E0<Scope>(){
        public Scope invoke(){
          return ClassifierScopes.getAnnotationClassifiersScope(node,GlobalScope.getInstance());
        }
      }
;
      Utils.checkScopes(node,Utils.getNodes("old scope",oldScopeProvider),Utils.getNodes("new scope/from ioperation",newScopeProvider),true);
    }
    public boolean isShowAsIntention(){
      return false;
    }
  }
);
}
