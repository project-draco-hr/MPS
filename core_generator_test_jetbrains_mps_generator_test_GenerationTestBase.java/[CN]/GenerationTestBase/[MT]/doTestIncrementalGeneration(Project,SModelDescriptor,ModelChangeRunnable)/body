{
  String randomName="testxw" + Math.abs(UUID.randomUUID().getLeastSignificantBits()) + "."+ originalModel.getModule().getModuleFqName();
  String randomId=UUID.randomUUID().toString();
  final TestModule tm=new TestModule(randomName,randomId,originalModel.getModule());
  ModelAccess.instance().runWriteAction(new Runnable(){
    public void run(){
      MPSModuleRepository.getInstance().registerModule(tm,myOwner);
    }
  }
);
  final SModelDescriptor[] descr1=new SModelDescriptor[]{null};
  try {
    ModelAccess.instance().runReadAction(new Runnable(){
      @Override public void run(){
        descr1[0]=tm.createModel(originalModel);
        tm.publish(descr1[0]);
      }
    }
);
    final SModelDescriptor descr=descr1[0];
    File generatorCaches=new File(PathManager.getSystemPath(),"mps-generator-test");
    if (generatorCaches.exists()) {
      Assert.assertTrue(FileUtil.delete(generatorCaches));
    }
    Assert.assertTrue("cannot create caches folder",generatorCaches.mkdir());
    final MyIncrementalGenerationStrategy incrementalStrategy=new MyIncrementalGenerationStrategy(descr,new FileBasedGenerationCacheContainer(generatorCaches));
    ModelAccess.instance().runReadAction(new Runnable(){
      @Override public void run(){
        incrementalStrategy.buildHash();
      }
    }
);
    List<String> hashes=new ArrayList<String>();
    hashes.add(incrementalStrategy.getHash().get(GeneratableSModel.FILE));
    GenerationOptions options=GenerationOptions.getDefaults().rebuildAll(true).strictMode(true).reporting(true,true,false,2).incremental(incrementalStrategy).create();
    IncrementalTestGenerationHandler generationHandler=new IncrementalTestGenerationHandler();
    GenerationFacade.generateModels(p,Collections.singletonList(descr),ModuleContext.create(descr,p),generationHandler,new EmptyProgressMonitor(),generationHandler.getMessageHandler(),options,p.getComponent(TransientModelsComponent.class));
    Map<String,String> generated=replaceInContent(generationHandler.getGeneratedContent(),new String[]{randomName,originalModel.getModule().getModuleFqName()},new String[]{randomId,originalModel.getModule().getModuleReference().getModuleId().toString()});
    assertNoDiff(generationHandler.getExistingContent(),generated);
    Map<String,String> incrementalGenerationResults=generationHandler.getGeneratedContent();
    List<Long> time=new ArrayList<Long>();
    Assert.assertTrue(changeModel.length > 0);
    for (    final ModelChangeRunnable r : changeModel) {
      ThreadUtils.runInUIThreadAndWait(new Runnable(){
        @Override public void run(){
          ModelAccess.instance().runWriteActionInCommand(new Runnable(){
            @Override public void run(){
              r.run(descr);
            }
          }
,p);
        }
      }
);
      ModelAccess.instance().runReadAction(new Runnable(){
        @Override public void run(){
          incrementalStrategy.buildHash();
        }
      }
);
      hashes.add(incrementalStrategy.getHash().get(GeneratableSModel.FILE));
      Assert.assertNotNull(generationHandler.getLastDependencies());
      incrementalStrategy.setDependencies(generationHandler.getLastDependencies());
      options=GenerationOptions.getDefaults().rebuildAll(false).strictMode(true).reporting(true,true,false,2).incremental(incrementalStrategy).create();
      generationHandler=new IncrementalTestGenerationHandler(incrementalGenerationResults);
      generationHandler.checkIncremental(options);
      long start=System.nanoTime();
      GenerationFacade.generateModels(p,Collections.singletonList(descr),ModuleContext.create(descr,p),generationHandler,new EmptyProgressMonitor(),generationHandler.getMessageHandler(),options,p.getComponent(TransientModelsComponent.class));
      time.add(System.nanoTime() - start);
      incrementalGenerationResults=generationHandler.getGeneratedContent();
      assertDiff(generationHandler.getExistingContent(),incrementalGenerationResults,1);
    }
    incrementalStrategy.setDependencies(null);
    options=GenerationOptions.getDefaults().rebuildAll(true).strictMode(true).reporting(true,true,false,2).incremental(incrementalStrategy).create();
    generationHandler=new IncrementalTestGenerationHandler(incrementalGenerationResults);
    long start=System.nanoTime();
    GenerationFacade.generateModels(p,Collections.singletonList(descr),ModuleContext.create(descr,p),generationHandler,new EmptyProgressMonitor(),generationHandler.getMessageHandler(),options,p.getComponent(TransientModelsComponent.class));
    time.add(System.nanoTime() - start);
    assertNoDiff(incrementalGenerationResults,generationHandler.getGeneratedContent());
    PerformanceMessenger.getInstance().reportPercent("incrementalGeneration",(time.get(time.size() - 2)) / 1000000,(time.get(time.size() - 1)) / 1000000);
    if (DEBUG) {
      long regen=time.remove(time.size() - 1);
      System.out.print("Full cycle: " + regen / 1000000 / 1000.);
      for (      long l : time) {
        System.out.print(", incremental: " + l / 1000000 / 1000.);
      }
      System.out.println();
    }
  }
  finally {
    ModelAccess.instance().runWriteAction(new Runnable(){
      public void run(){
        MPSModuleRepository.getInstance().unregisterModule(tm,myOwner);
      }
    }
);
  }
}
