{
  if (subType == null) {
    return false;
  }
  if (false && superType instanceof NodeMatcher) {
    Boolean answer=getCacheAnswer(subType,(NodeMatcher)superType,isWeak);
    if (answer != null) {
      return answer;
    }
  }
  Set<SNode> frontier=new HashSet<SNode>();
  Set<SNode> newFrontier=new HashSet<SNode>();
  Set<SNode> yetPassed=new HashSet<SNode>();
  frontier.add(subType);
  while (!frontier.isEmpty()) {
    Set<SNode> yetPassedRaw=new HashSet<SNode>();
    Set<SNode> ancestors=new HashSet<SNode>();
    for (    SNode node : frontier) {
      TypeCheckingContextNew typeCheckingContextNew=myState == null ? null : myState.getTypeCheckingContext();
      Set<SNode> result=collectImmediateSuperTypes(node,isWeak,typeCheckingContextNew,superType.getConceptFQName());
      for (      SNode test : result) {
        boolean found=false;
        for (        SNode anc : yetPassed) {
          if (TypesUtil.match(anc,test)) {
            found=true;
          }
        }
        if (!found) {
          ancestors.add(test);
        }
      }
      yetPassedRaw.add(node);
    }
    ArrayList<SNode> ancestorsSorted=new ArrayList<SNode>(ancestors);
    Collections.sort(ancestorsSorted,new Comparator<SNode>(){
      public int compare(      SNode o1,      SNode o2){
        return TypesUtil.depth(o2) - TypesUtil.depth(o1);
      }
    }
);
    for (    SNode ancestor : ancestorsSorted) {
      if (superType.matchesWith(ancestor)) {
        addToCache(subType,superType,true,isWeak);
        return true;
      }
    }
    for (    SNode passedNodeRaw : yetPassedRaw) {
      yetPassed.add(passedNodeRaw);
    }
    for (    SNode passedNode : yetPassed) {
      ancestors.remove(passedNode);
    }
    newFrontier.addAll(ancestors);
    yetPassed.addAll(ancestors);
    frontier=newFrontier;
    newFrontier=new HashSet<SNode>();
  }
  addToCache(subType,superType,false,isWeak);
  return false;
}
