{
  if (subType == null) {
    return false;
  }
  Set<SNode> frontier=new HashSet<SNode>();
  Set<SNode> newFrontier=new HashSet<SNode>();
  Set<SNode> yetPassed=new HashSet<SNode>();
  frontier.add(subType);
  while (!frontier.isEmpty()) {
    Set<SNode> yetPassedRaw=new HashSet<SNode>();
    Set<SNode> ancestors=new HashSet<SNode>();
    for (    SNode node : frontier) {
      Set<SNode> result=collectImmediateSuperTypes(node,isWeak,myState.getTypeCheckingContext(),superType.getConceptFqName());
      for (      SNode test : result) {
        boolean found=false;
        for (        SNode anc : yetPassed) {
          if (MatchingUtil.matchNodes(anc,test)) {
            found=true;
          }
        }
        if (!found) {
          ancestors.add(test);
        }
      }
      yetPassedRaw.add(node);
    }
    ArrayList<SNode> ancestorsSorted=new ArrayList<SNode>(ancestors);
    Collections.sort(ancestorsSorted,new Comparator<SNode>(){
      public int compare(      SNode o1,      SNode o2){
        return SNodeOperations.depth(o2) - SNodeOperations.depth(o1);
      }
    }
);
    for (    SNode ancestor : ancestorsSorted) {
      if (TypesUtil.match(ancestor,superType,null,info,false)) {
        return true;
      }
    }
    for (    SNode passedNodeRaw : yetPassedRaw) {
      yetPassed.add(passedNodeRaw);
    }
    for (    SNode passedNode : yetPassed) {
      ancestors.remove(passedNode);
    }
    newFrontier.addAll(ancestors);
    yetPassed.addAll(ancestors);
    frontier=newFrontier;
    newFrontier=new HashSet<SNode>();
  }
  return false;
}
