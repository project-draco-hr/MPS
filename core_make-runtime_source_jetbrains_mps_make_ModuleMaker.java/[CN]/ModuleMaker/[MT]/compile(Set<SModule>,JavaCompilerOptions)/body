{
  boolean hasAnythingToCompile=false;
  List<IMessage> messages=new ArrayList<IMessage>();
  for (  SModule m : modules) {
    if (isExcluded(m))     continue;
    hasAnythingToCompile=true;
  }
  if (!hasAnythingToCompile) {
    return new MPSCompilationResult(0,0,false,Collections.<SModule>emptySet());
  }
  boolean hasJavaToCompile=false;
  boolean hasFilesToCopyOrDelete=false;
  JavaCompiler compiler=new JavaCompiler();
  myTracer.push("preparing to compile",false);
  Set<SModule> modulesWithRemovals=new HashSet<SModule>();
  for (  SModule m : modules) {
    if (areClassesUpToDate(m))     continue;
    if (!getJavaFacet(m).isCompileInMps()) {
      String text="Module which compiled in IDEA depends on module which has to be compiled in MPS:" + m.getModuleName();
      messages.add(createMessage(MessageKind.WARNING,text,m));
      myHandler.handle(createMessage(MessageKind.INFORMATION,text,m));
      continue;
    }
    ModuleSources sources=getModuleSources(m);
    hasFilesToCopyOrDelete|=!sources.isResourcesUpToDate();
    hasJavaToCompile|=!sources.isJavaUpToDate();
    for (    File f : sources.getFilesToDelete()) {
      f.delete();
      modulesWithRemovals.add(m);
    }
    for (    JavaFile f : sources.getFilesToCompile()) {
      compiler.addSource(f.getClassName(),f.getContents());
      myContainingModules.put(f.getClassName(),m);
    }
  }
  myTracer.pop();
  if (!hasJavaToCompile && !hasFilesToCopyOrDelete) {
    return new MPSCompilationResult(0,0,false,Collections.<SModule>emptySet(),messages);
  }
  myTracer.push("invalidating classpath",false);
  for (  SModule module : modulesWithRemovals) {
    invalidateCompiledClasses(module);
  }
  myTracer.pop();
  Set<SModule> changedModules=new HashSet<SModule>();
  MyCompilationResultAdapter listener=null;
  if (hasJavaToCompile) {
    myTracer.push("compiling java",false);
    IClassPathItem classPathItems=computeDependenciesClassPath(modules);
    listener=new MyCompilationResultAdapter(modules,classPathItems,messages);
    compiler.addCompilationResultListener(listener);
    myTracer.push("eclipse compiler",true);
    if (compilerOptions == null) {
      compiler.compile(classPathItems);
    }
 else {
      compiler.compile(classPathItems,compilerOptions);
    }
    listener.writeClasses();
    myTracer.pop();
    changedModules.addAll(listener.myChangedModules);
    compiler.removeCompilationResultListener(listener);
    myTracer.pop();
  }
  myTracer.push("copying resources",false);
  for (  SModule module : modules) {
    ModuleSources sources=getModuleSources(module);
    IFile classesGen=getJavaFacet(module).getClassesGen();
    if (classesGen == null) {
      continue;
    }
    for (    ResourceFile toCopy : sources.getResourcesToCopy()) {
      String fqName=toCopy.getPath();
      fqName=fqName.substring(0,fqName.length() - toCopy.getFile().getName().length());
      String path=fqName.replace('/',File.separatorChar) + toCopy.getFile().getName();
      if (new File(toCopy.getFile().getAbsolutePath()).exists()) {
        FileUtil.copyFile(new File(toCopy.getFile().getAbsolutePath()),new File(classesGen.getDescendant(path).getPath()));
      }
    }
  }
  myTracer.pop();
  myTracer.push("updating classpath",false);
  for (  SModule module : changedModules) {
    invalidateCompiledClasses(module);
  }
  myTracer.pop();
  for (  SModule module : modulesWithRemovals) {
    if (!changedModules.contains(module)) {
      myHandler.handle(createMessage(MessageKind.WARNING,"Module with removals not in changed modules: " + module,module));
    }
  }
  if (hasJavaToCompile && changedModules.isEmpty()) {
    myHandler.handle(createMessage(MessageKind.ERROR,"has java to compile but changed modules is empty",null));
  }
  if (!hasJavaToCompile && !changedModules.isEmpty()) {
    myHandler.handle(createMessage(MessageKind.ERROR,"has not java to compile but changed modules is not empty",null));
  }
  return new MPSCompilationResult(listener == null ? 0 : listener.getErrorCount(),0,false,changedModules,messages);
}
