{
  SNode classifier_=super.resolve(referenceInfo,targetModelReference);
  if (classifier_ == null) {
    return null;
  }
  SNode classifier=SNodeOperations.cast(classifier_,"jetbrains.mps.baseLanguage.structure.Classifier");
  if (SNodeOperations.isInstanceOf(classifier,"jetbrains.mps.baseLanguage.structure.ClassConcept")) {
    List<SNode> constructors=ListSequence.fromList(SLinkOperations.getTargets((SNodeOperations.cast(classifier,"jetbrains.mps.baseLanguage.structure.ClassConcept")),"constructor",true)).toListSequence();
    if ((int)ListSequence.fromList(constructors).count() == 1) {
      return ListSequence.fromList(constructors).first();
    }
 else     if (ListSequence.fromList(constructors).count() > 1) {
      constructors=(List<SNode>)MethodResolveUtil.selectByParmCount(constructors,myActualArgs);
      if ((int)ListSequence.fromList(constructors).count() == 1) {
        return ListSequence.fromList(constructors).first();
      }
 else {
        Iterator<SNode> typeParms=(Iterator<SNode>)myTypeParms.iterator();
        Iterator<SNode> typeVars=(Iterator<SNode>)SLinkOperations.getTargets(classifier,"typeVariableDeclaration",true).iterator();
        Map<SNode,SNode> typeByTypeVar=new HashMap<SNode,SNode>();
        while (typeParms.hasNext() && typeVars.hasNext()) {
          typeByTypeVar.put(typeVars.next(),typeParms.next());
        }
        return MethodResolveUtil.chooseByParameterType(constructors,myActualArgs,typeByTypeVar);
      }
    }
  }
  return null;
}
