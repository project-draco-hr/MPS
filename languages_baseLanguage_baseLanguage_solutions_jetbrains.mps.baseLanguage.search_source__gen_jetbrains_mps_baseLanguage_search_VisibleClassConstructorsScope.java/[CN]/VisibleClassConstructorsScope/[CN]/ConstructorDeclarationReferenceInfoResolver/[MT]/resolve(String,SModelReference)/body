{
  SNode classifier_=super.resolve(referenceInfo,targetModelReference);
  if (classifier_ == null) {
    return null;
  }
  SNode classifier=SNodeOperations.cast(classifier_,MetaAdapterFactory.getConcept(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0x101d9d3ca30L,"jetbrains.mps.baseLanguage.structure.Classifier"));
  if (SNodeOperations.isInstanceOf(classifier,MetaAdapterFactory.getConcept(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0xf8c108ca66L,"jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
    List<SNode> constructors=Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>)((Class)Object.class),(SNodeOperations.cast(classifier,MetaAdapterFactory.getConcept(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0xf8c108ca66L,"jetbrains.mps.baseLanguage.structure.ClassConcept"))),"jetbrains.mps.baseLanguage.structure.ClassConcept","call_constructors_5292274854859503373",new Object[]{})).toListSequence();
    if (ListSequence.fromList(constructors).count() == 1) {
      return ListSequence.fromList(constructors).first();
    }
 else     if (ListSequence.fromList(constructors).count() > 1) {
      constructors=(List<SNode>)MethodResolveUtil.selectByParmCount(constructors,myActualArgs);
      if (ListSequence.fromList(constructors).count() == 1) {
        return ListSequence.fromList(constructors).first();
      }
 else {
        Iterator<SNode> typeParms=(Iterator<SNode>)myTypeParms.iterator();
        Iterator<SNode> typeVars=(Iterator<SNode>)SLinkOperations.getChildren(classifier,MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0x102463b447aL,0x102463bb98eL,"typeVariableDeclaration")).iterator();
        Map<SNode,SNode> typeByTypeVar=new HashMap<SNode,SNode>();
        while (typeParms.hasNext() && typeVars.hasNext()) {
          typeByTypeVar.put(typeVars.next(),typeParms.next());
        }
        return MethodResolveUtil.chooseByParameterType(constructors,myActualArgs,typeByTypeVar);
      }
    }
  }
  return null;
}
