{
  return new IJob.Stub(){
    public IResult execute(    final Iterable<IResource> input,    final IJobMonitor monitor,    final IPropertiesAccessor pa,    @NotNull final ProgressMonitor progressMonitor){
      Iterable<IResource> _output_21gswx_a0a=null;
switch (0) {
case 0:
        long textGenStartTime=System.currentTimeMillis();
      Iterable<GResource> resources=Sequence.fromIterable(input).select(new ISelector<IResource,GResource>(){
        public GResource select(        IResource it){
          return (GResource)(IResource)it;
        }
      }
);
    if (Sequence.fromIterable(resources).any(new IWhereFilter<GResource>(){
      public boolean accept(      GResource it){
        return !(it.status().isOk());
      }
    }
)) {
      monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("Generation was not OK")));
      return new IResult.FAILURE(_output_21gswx_a0a);
    }
  for (  GResource resource : Sequence.fromIterable(resources)) {
    if (resource.module().getOutputFor(resource.model()) == null) {
      monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("no output location for " + resource.model().getLongName())));
    }
  }
resources=Sequence.fromIterable(resources).where(new IWhereFilter<GResource>(){
  public boolean accept(  GResource it){
    return it.module().getOutputFor(it.model()) != null;
  }
}
);
final boolean _generateDebugInfo=pa.global().properties(Target_textGen.this.getName(),TextGen_Facet.Target_textGen.Parameters.class).generateDebugInfo() == null || pa.global().properties(Target_textGen.this.getName(),TextGen_Facet.Target_textGen.Parameters.class).generateDebugInfo();
final boolean _failIfNoTextgen=pa.global().properties(Target_textGen.this.getName(),TextGen_Facet.Target_textGen.Parameters.class).failIfNoTextgen() != null && pa.global().properties(Target_textGen.this.getName(),TextGen_Facet.Target_textGen.Parameters.class).failIfNoTextgen();
long prepareTime=0;
final Wrappers._long generateTime=new Wrappers._long(0);
final Wrappers._long flushTime=new Wrappers._long(0);
final Wrappers._long cleanUpTime=new Wrappers._long(0);
AtomicLong transactionOverheadTime=new AtomicLong(0);
int MAX_ROOTS_COUNT=1000;
final List<GResource> currentInput=ListSequence.fromList(new ArrayList<GResource>());
int currentRootsCount=0;
monitor.currentProgress().beginWork("Writing",Sequence.fromIterable(input).count() * 100,monitor.currentProgress().workLeft());
final TextGeneratorEngine engine=new TextGeneratorEngine(_generateDebugInfo,_failIfNoTextgen);
try {
IResource lastResource=Sequence.fromIterable(resources).last();
for (final GResource currentResource : Sequence.fromIterable(resources)) {
final Wrappers._int rootsCount=new Wrappers._int(0);
final Wrappers._boolean ignoreResource=new Wrappers._boolean(false);
prepareTime+=TextGenUtil.withTimeTracking(new Runnable(){
public void run(){
ModelAccess.instance().runReadAction(new Runnable(){
public void run(){
SModel outputModel=currentResource.status().getOutputModel();
if (outputModel == null) {
ignoreResource.value=true;
}
 else {
rootsCount.value=outputModel.rootsCount();
}
}
}
);
}
}
);
if (ignoreResource.value) {
continue;
}
currentRootsCount+=rootsCount.value;
ListSequence.fromList(currentInput).addElement(currentResource);
if (currentRootsCount < MAX_ROOTS_COUNT && currentResource != lastResource) {
continue;
}
if (ListSequence.fromList(currentInput).isEmpty()) {
continue;
}
final Map<IResource,Iterable<IDelta>> retainedFilesDelta=MapSequence.fromMap(new HashMap<IResource,Iterable<IDelta>>());
final Map<IResource,Iterable<IDelta>> retainedCachesDelta=MapSequence.fromMap(new HashMap<IResource,Iterable<IDelta>>());
final Map<IResource,JavaStreamHandler> streamHandlers=MapSequence.fromMap(new HashMap<IResource,JavaStreamHandler>());
prepareTime+=TextGenUtil.withTimeTracking(new Runnable(){
public void run(){
for (GResource resource : ListSequence.fromList(currentInput)) {
MapSequence.fromMap(retainedFilesDelta).put(resource,RetainedUtil.retainedFilesDelta(Sequence.fromIterable(resource.retainedModels()).where(new IWhereFilter<SModelDescriptor>(){
public boolean accept(SModelDescriptor smd){
return GenerationFacade.canGenerate(smd);
}
}
),resource.module(),pa.global().properties(new ITarget.Name("jetbrains.mps.lang.core.Make.make"),Make_Facet.Target_make.Parameters.class).pathToFile()));
MapSequence.fromMap(retainedCachesDelta).put(resource,RetainedUtil.retainedCachesDelta(Sequence.fromIterable(resource.retainedModels()).where(new IWhereFilter<SModelDescriptor>(){
public boolean accept(SModelDescriptor smd){
return GenerationFacade.canGenerate(smd);
}
}
),resource.module(),pa.global().properties(new ITarget.Name("jetbrains.mps.lang.core.Make.make"),Make_Facet.Target_make.Parameters.class).pathToFile()));
String output=resource.module().getOutputFor(resource.model());
MapSequence.fromMap(streamHandlers).put(resource,new JavaStreamHandler(resource.model(),pa.global().properties(new ITarget.Name("jetbrains.mps.lang.core.Make.make"),Make_Facet.Target_make.Parameters.class).pathToFile().invoke(output),pa.global().properties(new ITarget.Name("jetbrains.mps.lang.core.Make.make"),Make_Facet.Target_make.Parameters.class).pathToFile().invoke(FileGenerationUtil.getCachesPath(output))));
}
}
}
);
String nameOfStep=ListSequence.fromList(currentInput).first().status().getInputModel().getSModelReference().getSModelFqName().getLongName();
monitor.currentProgress().advanceWork("Writing",ListSequence.fromList(currentInput).count() * 100,nameOfStep);
final List<IMessage> errors=ListSequence.fromList((ListSequence.fromList(new ArrayList<IMessage>()))).asSynchronized();
ModelAccess.instance().runReadAction(new Runnable(){
public void run(){
generateTime.value+=TextGenUtil.withTimeTracking(new Runnable(){
public void run(){
final Map<SModel,GResource> modelToInput=Collections.synchronizedMap(new HashMap<SModel,GResource>());
for (GResource resource : ListSequence.fromList(currentInput)) {
modelToInput.put(resource.status().getOutputModel(),resource);
}
engine.generateModels(modelToInput.keySet(),new TextGeneratorEngine.GenerateCallback(){
public void modelGenerated(SModel model,List<TextGenerationResult> results){
GResource generatedResource=modelToInput.get(model);
try {
CacheGenerator[] cacheGenerators=new CacheGenerator[]{BLDependenciesCache.getInstance().getGenerator(),(_generateDebugInfo ? TraceInfoCache.getInstance().getGenerator() : null),GenerationDependenciesCache.getInstance().getGenerator()};
ListSequence.fromList(errors).addSequence(ListSequence.fromList(TextGenerator.handleTextGenResults(generatedResource.status(),results,_generateDebugInfo,MapSequence.fromMap(streamHandlers).get(generatedResource),cacheGenerators)));
}
  finally {
MapSequence.fromMap(streamHandlers).get(generatedResource).dispose();
}
}
}
);
}
}
);
}
}
);
if (ListSequence.fromList(errors).isNotEmpty()) {
{
Iterator<IMessage> error_it=ListSequence.fromList(errors).iterator();
IMessage error_var;
while (error_it.hasNext()) {
error_var=error_it.next();
monitor.reportFeedback(new IFeedback.MESSAGE(error_var));
}
}
return new IResult.FAILURE(_output_21gswx_a0a);
}
if (false) {
int handlersSize=Sequence.fromIterable(MapSequence.fromMap(streamHandlers).values()).foldLeft(0,new ILeftCombinator<JavaStreamHandler,Integer>(){
public Integer combine(Integer s,JavaStreamHandler it){
return s + it.calcApproximateSize_internal();
}
}
);
LOG.info("approximate handlers size: " + handlersSize / 1000 / 1000 + " mb");
int overallRootsCount=ListSequence.fromList(currentInput).select(new ISelector<GResource,SModelDescriptor>(){
public SModelDescriptor select(GResource it){
return it.model();
}
}
).foldLeft(0,new ILeftCombinator<SModelDescriptor,Integer>(){
public Integer combine(Integer s,SModelDescriptor it){
return s + it.getSModel().rootsCount();
}
}
);
LOG.info("roots count: " + overallRootsCount);
LOG.info("models count: " + ListSequence.fromList(currentInput).count());
}
if (!(TextGenUtil.runWriteTransaction(new Runnable(){
public void run(){
flushTime.value+=TextGenUtil.withTimeTracking(new Runnable(){
public void run(){
for (JavaStreamHandler javaStreamHandler : Sequence.fromIterable(MapSequence.fromMap(streamHandlers).values())) {
javaStreamHandler.flush();
}
}
}
);
}
}
,transactionOverheadTime))) {
monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("Failed to save files")));
return new IResult.FAILURE(_output_21gswx_a0a);
}
for (GResource resource : ListSequence.fromList(currentInput)) {
Iterable<IDelta> delta=Sequence.fromIterable(MapSequence.fromMap(streamHandlers).get(resource).delta()).concat(Sequence.fromIterable(MapSequence.fromMap(retainedFilesDelta).get(resource))).concat(Sequence.fromIterable(MapSequence.fromMap(retainedCachesDelta).get(resource)));
IResource result=new TResource(resource.module(),delta,resource.model());
_output_21gswx_a0a=Sequence.fromIterable(_output_21gswx_a0a).concat(Sequence.fromIterable(Sequence.<IResource>singleton(result)));
}
if (!(TextGenUtil.runWriteTransaction(new Runnable(){
public void run(){
ModelAccess.instance().requireWrite(new Runnable(){
public void run(){
cleanUpTime.value+=TextGenUtil.withTimeTracking(new Runnable(){
public void run(){
if (!(Boolean.TRUE.equals(pa.global().properties(new ITarget.Name("jetbrains.mps.lang.core.Generate.configure"),Generate_Facet.Target_configure.Variables.class).saveTransient()))) {
for (GResource resource : ListSequence.fromList(currentInput)) {
SModelDescriptor outputMD=resource.status().getOutputModelDescriptor();
if (outputMD instanceof TransientModelsModule.TransientSModelDescriptor) {
((TransientModelsModule)outputMD.getModule()).removeModel(outputMD);
}
}
}
CleanupManager.getInstance().cleanup();
}
}
);
}
}
);
}
}
,transactionOverheadTime))) {
monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("Failed to remove transient models")));
return new IResult.FAILURE(_output_21gswx_a0a);
}
currentRootsCount=0;
ListSequence.fromList(currentInput).clear();
}
}
 catch (Exception e) {
LOG.error("Exception while textGen",e);
throw new RuntimeException(e);
}
 finally {
engine.shutdown();
monitor.currentProgress().finishWork("Writing");
long overallTime=System.currentTimeMillis() - textGenStartTime;
if (true) {
LOG.info("text gen prepare time: " + prepareTime);
LOG.info("text gen generate time: " + generateTime.value);
LOG.info("text gen flush time: " + flushTime.value);
LOG.info("text gen clean up time: " + cleanUpTime.value);
LOG.info("text gen write transaction overhead time: " + transactionOverheadTime);
LOG.info("text gen overhead time: " + (overallTime - prepareTime - generateTime.value- cleanUpTime.value- flushTime.value));
}
}
default :
return new IResult.SUCCESS(_output_21gswx_a0a);
}
}
}
;
}
