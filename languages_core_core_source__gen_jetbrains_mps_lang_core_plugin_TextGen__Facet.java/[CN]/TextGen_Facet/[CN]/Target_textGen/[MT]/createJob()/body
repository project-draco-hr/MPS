{
  return new IJob.Stub(){
    public IResult execute(    final Iterable<IResource> input,    final IJobMonitor monitor,    final IPropertiesAccessor pa,    @NotNull final ProgressMonitor progressMonitor){
      Iterable<IResource> _output_21gswx_a0a=null;
switch (0) {
case 0:
        long textGenStartTime=System.currentTimeMillis();
      final Wrappers._T<Iterable<GResource>> resources=new Wrappers._T<Iterable<GResource>>(Sequence.fromIterable(input).select(new ISelector<IResource,GResource>(){
        public GResource select(        IResource it){
          return (GResource)(IResource)it;
        }
      }
));
    if (Sequence.fromIterable(resources.value).any(new IWhereFilter<GResource>(){
      public boolean accept(      GResource it){
        return !(it.status().isOk());
      }
    }
)) {
      monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("Generation was not OK")));
      return new IResult.FAILURE(_output_21gswx_a0a);
    }
  for (  GResource resource : Sequence.fromIterable(resources.value)) {
    if (resource.module().getOutputFor(resource.model()) == null) {
      monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("no output location for " + resource.model().getLongName())));
    }
  }
resources.value=Sequence.fromIterable(resources.value).where(new IWhereFilter<GResource>(){
  public boolean accept(  GResource it){
    return it.module().getOutputFor(it.model()) != null;
  }
}
);
boolean _generateDebugInfo=pa.global().properties(Target_textGen.this.getName(),TextGen_Facet.Target_textGen.Parameters.class).generateDebugInfo() == null || pa.global().properties(Target_textGen.this.getName(),TextGen_Facet.Target_textGen.Parameters.class).generateDebugInfo();
boolean _failIfNoTextgen=pa.global().properties(Target_textGen.this.getName(),TextGen_Facet.Target_textGen.Parameters.class).failIfNoTextgen() != null && pa.global().properties(Target_textGen.this.getName(),TextGen_Facet.Target_textGen.Parameters.class).failIfNoTextgen();
long prepareStartTime=System.currentTimeMillis();
Map<IResource,Iterable<IDelta>> retainedFilesDelta=MapSequence.fromMap(new HashMap<IResource,Iterable<IDelta>>());
Map<IResource,Iterable<IDelta>> retainedCachesDelta=MapSequence.fromMap(new HashMap<IResource,Iterable<IDelta>>());
final Map<IResource,JavaStreamHandler> streamHandlers=MapSequence.fromMap(new HashMap<IResource,JavaStreamHandler>());
for (GResource resource : Sequence.fromIterable(resources.value)) {
MapSequence.fromMap(retainedFilesDelta).put(resource,RetainedUtil.retainedFilesDelta(Sequence.fromIterable(resource.retainedModels()).where(new IWhereFilter<SModelDescriptor>(){
public boolean accept(SModelDescriptor smd){
return GenerationFacade.canGenerate(smd);
}
}
),resource.module(),pa.global().properties(new ITarget.Name("jetbrains.mps.lang.core.Make.make"),Make_Facet.Target_make.Parameters.class).pathToFile()));
MapSequence.fromMap(retainedCachesDelta).put(resource,RetainedUtil.retainedCachesDelta(Sequence.fromIterable(resource.retainedModels()).where(new IWhereFilter<SModelDescriptor>(){
public boolean accept(SModelDescriptor smd){
return GenerationFacade.canGenerate(smd);
}
}
),resource.module(),pa.global().properties(new ITarget.Name("jetbrains.mps.lang.core.Make.make"),Make_Facet.Target_make.Parameters.class).pathToFile()));
String output=resource.module().getOutputFor(resource.model());
MapSequence.fromMap(streamHandlers).put(resource,new JavaStreamHandler(resource.model(),pa.global().properties(new ITarget.Name("jetbrains.mps.lang.core.Make.make"),Make_Facet.Target_make.Parameters.class).pathToFile().invoke(output),pa.global().properties(new ITarget.Name("jetbrains.mps.lang.core.Make.make"),Make_Facet.Target_make.Parameters.class).pathToFile().invoke(FileGenerationUtil.getCachesPath(output))));
}
long prepareTime=System.currentTimeMillis() - prepareStartTime;
final Wrappers._long textGenTime=new Wrappers._long(0);
monitor.currentProgress().beginWork("Writing",Sequence.fromIterable(input).count() * 100,monitor.currentProgress().workLeft());
for (final GResource gres : Sequence.fromIterable(resources.value)) {
monitor.currentProgress().advanceWork("Writing",100,gres.status().getInputModel().getSModelReference().getSModelFqName().getLongName());
JavaStreamHandler javaStreamHandler=MapSequence.fromMap(streamHandlers).get(gres);
final Wrappers._boolean ok=new Wrappers._boolean();
final TextGenerator textgen=new TextGenerator(javaStreamHandler,BLDependenciesCache.getInstance().getGenerator(),(_generateDebugInfo ? TraceInfoCache.getInstance().getGenerator() : null),GenerationDependenciesCache.getInstance().getGenerator());
textgen.setFailIfNoTextgen(_failIfNoTextgen);
textgen.setGenerateDebugInfo(_generateDebugInfo);
try {
ModelAccess.instance().runReadAction(new Runnable(){
public void run(){
long innerTime=System.currentTimeMillis();
ok.value=textgen.handleOutput(pa.global().properties(new ITarget.Name("jetbrains.mps.lang.core.Generate.checkParameters"),Generate_Facet.Target_checkParameters.Variables.class).operationContext(),gres.status());
textGenTime.value+=System.currentTimeMillis() - innerTime;
}
}
);
}
  finally {
javaStreamHandler.dispose();
}
if (!(ok.value)) {
for (IMessage err : textgen.errors()) {
monitor.reportFeedback(new IFeedback.MESSAGE(err));
}
monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("Failed to generate text")));
return new IResult.FAILURE(_output_21gswx_a0a);
}
}
final Wrappers._long flushTime=new Wrappers._long();
if (!(FileSystem.getInstance().runWriteTransaction(new Runnable(){
public void run(){
long startTime=System.currentTimeMillis();
for (JavaStreamHandler javaStreamHandler : Sequence.fromIterable(MapSequence.fromMap(streamHandlers).values())) {
javaStreamHandler.flush();
}
flushTime.value=System.currentTimeMillis() - startTime;
}
}
))) {
monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("Failed to save files")));
return new IResult.FAILURE(_output_21gswx_a0a);
}
for (GResource resource : Sequence.fromIterable(resources.value)) {
Iterable<IDelta> delta=Sequence.fromIterable(MapSequence.fromMap(streamHandlers).get(resource).delta()).concat(Sequence.fromIterable(MapSequence.fromMap(retainedFilesDelta).get(resource))).concat(Sequence.fromIterable(MapSequence.fromMap(retainedCachesDelta).get(resource)));
IResource result=new TResource(resource.module(),delta,resource.model());
_output_21gswx_a0a=Sequence.fromIterable(_output_21gswx_a0a).concat(Sequence.fromIterable(Sequence.<IResource>singleton(result)));
}
final Wrappers._long cleanUpTime=new Wrappers._long();
if (!(FileSystem.getInstance().runWriteTransaction(new Runnable(){
public void run(){
ModelAccess.instance().requireWrite(new Runnable(){
public void run(){
long startTime=System.currentTimeMillis();
if (!(Boolean.TRUE.equals(pa.global().properties(new ITarget.Name("jetbrains.mps.lang.core.Generate.configure"),Generate_Facet.Target_configure.Variables.class).saveTransient()))) {
for (GResource resource : Sequence.fromIterable(resources.value)) {
SModelDescriptor outputMD=resource.status().getOutputModelDescriptor();
if (outputMD instanceof TransientModelsModule.TransientSModelDescriptor) {
((TransientModelsModule)outputMD.getModule()).removeModel(outputMD);
}
}
}
CleanupManager.getInstance().cleanup();
cleanUpTime.value=System.currentTimeMillis() - startTime;
}
}
);
}
}
))) {
monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("Failed to remove transient models")));
return new IResult.FAILURE(_output_21gswx_a0a);
}
monitor.currentProgress().finishWork("Writing");
long overallTime=System.currentTimeMillis() - textGenStartTime;
if (false) {
LOG.info("text gen prepare time: " + prepareTime);
LOG.info("text gen generate time: " + textGenTime.value);
LOG.info("text gen flush time: " + flushTime.value);
LOG.info("text gen clean up time: " + cleanUpTime.value);
LOG.info("text gen overhead time: " + (overallTime - prepareTime - textGenTime.value- cleanUpTime.value- flushTime.value));
}
default :
return new IResult.SUCCESS(_output_21gswx_a0a);
}
}
}
;
}
