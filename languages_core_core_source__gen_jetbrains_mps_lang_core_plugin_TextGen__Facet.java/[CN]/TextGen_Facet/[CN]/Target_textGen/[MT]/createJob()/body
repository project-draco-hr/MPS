{
  return new IJob.Stub(){
    @Override public IResult execute(    final Iterable<IResource> rawInput,    final IJobMonitor monitor,    final IPropertiesAccessor pa,    @NotNull final ProgressMonitor progressMonitor){
      Iterable<IResource> _output_21gswx_a0b=null;
      final Iterable<GResource> input=(Iterable<GResource>)(Iterable)rawInput;
switch (0) {
case 0:
        if (Sequence.fromIterable(input).any(new IWhereFilter<GResource>(){
          public boolean accept(          GResource it){
            return !(it.status().isOk());
          }
        }
)) {
          monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("Generation was not OK")));
          return new IResult.FAILURE(_output_21gswx_a0b);
        }
      for (      GResource resource : Sequence.fromIterable(input)) {
        if (SModuleOperations.getOutputPathFor(resource.model()) == null) {
          monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("no output location for " + SNodeOperations.getModelLongName(resource.model()))));
        }
      }
    final IMessageHandler messageHandler=TextGen_Facet.Target_configure.vars(pa.global()).makeSession().getMessageHandler();
  Project mpsProject=TextGen_Facet.Target_configure.vars(pa.global()).makeSession().getProject();
final TextGeneratorEngine tgEngine=new TextGeneratorEngine(messageHandler);
final Iterable<GResource> resourcesWithOutput=Sequence.fromIterable(input).where(new IWhereFilter<GResource>(){
public boolean accept(GResource it){
  return SModuleOperations.getOutputPathFor(it.model()) != null;
}
}
);
final boolean _generateDebugInfo=vars(pa.global()).generateDebugInfo() == null || vars(pa.global()).generateDebugInfo();
int modelsCount=Sequence.fromIterable(resourcesWithOutput).count();
monitor.currentProgress().beginWork("Writing",modelsCount + 3,monitor.currentProgress().workLeft());
try {
final ArrayBlockingQueue<TextGenResult> resultQueue=new ArrayBlockingQueue<TextGenResult>(modelsCount);
final Map<SModel,GResource> textGenInput2Resource=new HashMap<SModel,GResource>(modelsCount * 2);
mpsProject.getModelAccess().runReadAction(new Runnable(){
public void run(){
for (GResource res : Sequence.fromIterable(resourcesWithOutput)) {
SModel model2generate=res.status().getOutputModel();
textGenInput2Resource.put(model2generate,res);
tgEngine.schedule(model2generate,resultQueue);
}
}
}
);
monitor.currentProgress().advanceWork("Writing",3);
final Map<GResource,List<IDelta>> deltas2=new HashMap<GResource,List<IDelta>>();
final List<FileProcessor> fileProcessors2=ListSequence.fromList(new ArrayList<FileProcessor>());
while (modelsCount-- > 0) {
final TextGenResult tgr=resultQueue.poll(3,TimeUnit.MINUTES);
monitor.currentProgress().advanceWork("Writing",1,tgr.getModel().getReference().getModelName());
mpsProject.getModelAccess().runReadAction(new Runnable(){
public void run(){
GResource inputResource=textGenInput2Resource.get(tgr.getModel());
Iterable<IDelta> retainedFilesDelta=RetainedUtil.retainedDeltas(Sequence.fromIterable(inputResource.retainedModels()).where(new IWhereFilter<SModel>(){
public boolean accept(SModel smd){
  return GenerationFacade.canGenerate(smd);
}
}
),Target_make.vars(pa.global()).pathToFile());
MapSequence.fromMap(deltas2).put(inputResource,ListSequence.fromListWithValues(new ArrayList<IDelta>(),retainedFilesDelta));
TextFacility2 tf2=new TextFacility2(inputResource.status(),tgr);
tf2.generateDebug(_generateDebugInfo).generateBaseLangDeps(true);
tf2.prepare();
final IFile javaOutputDir=Target_make.vars(pa.global()).pathToFile().invoke(DefaultStreamManager.Provider.getOutputDir(inputResource.model()).getPath());
final IFile cacheOutputDir=Target_make.vars(pa.global()).pathToFile().invoke(DefaultStreamManager.Provider.getCachesDir(inputResource.model()).getPath());
StaleFilesCollector staleFileCollector=new StaleFilesCollector(javaOutputDir);
staleFileCollector.recordGeneratedChildren(inputResource.model());
FileProcessor fp=new FileProcessor();
ListSequence.fromList(fileProcessors2).addElement(fp);
FileDeltaCollector javaSourcesLoc=new FileDeltaCollector(javaOutputDir,fp);
FileDeltaCollector cachesLocation=new FileDeltaCollector(cacheOutputDir,fp);
tf2.serializeOutcome(javaSourcesLoc);
CacheGenLayout cgl=new CacheGenLayout(messageHandler);
cgl.register(cachesLocation,BLDependenciesCache.getInstance().getGenerator());
cgl.register(cachesLocation,GenerationDependenciesCache.getInstance().getGenerator());
if (_generateDebugInfo) {
cgl.register(javaSourcesLoc,TraceInfoCache.getInstance().getGenerator());
}
cgl.register(javaSourcesLoc,new ModelExports.CacheGen());
tf2.serializeCaches(cgl);
staleFileCollector.updateDelta(javaSourcesLoc.getDelta());
new StaleFilesCollector(cacheOutputDir).updateDelta(cachesLocation.getDelta());
ListSequence.fromList(MapSequence.fromMap(deltas2).get(inputResource)).addElement(javaSourcesLoc.getDelta());
ListSequence.fromList(MapSequence.fromMap(deltas2).get(inputResource)).addElement(cachesLocation.getDelta());
fp.invalidateModel(inputResource.model());
}
}
);
}
if (!(FileSystem.getInstance().runWriteTransaction(new Runnable(){
public void run(){
for (FileProcessor fp : ListSequence.fromList(fileProcessors2)) {
fp.flushChanges();
}
}
}
))) {
monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("Failed to save files")));
return new IResult.FAILURE(_output_21gswx_a0b);
}
for (GResource resource : SetSequence.fromSet(MapSequence.fromMap(deltas2).keySet())) {
Iterable<IDelta> delta=MapSequence.fromMap(deltas2).get(resource);
IResource result=new TResource(delta,resource.module(),resource.model());
_output_21gswx_a0b=Sequence.fromIterable(_output_21gswx_a0b).concat(Sequence.fromIterable(Sequence.<IResource>singleton(result)));
}
if (!(FileSystem.getInstance().runWriteTransaction(new Runnable(){
public void run(){
ModelAccess.instance().requireWrite(new Runnable(){
public void run(){
if (!(Boolean.TRUE.equals(Generate_Facet.Target_configure.vars(pa.global()).saveTransient()))) {
  for (  GResource resource : CollectionSequence.fromCollection(textGenInput2Resource.values())) {
    SModel outputMD=resource.status().getOutputModel();
    if (outputMD instanceof TransientModelsModule.TransientSModelDescriptor) {
      ((TransientModelsModule)outputMD.getModule()).removeModel(outputMD);
    }
  }
}
CleanupManager.getInstance().cleanup();
}
}
);
}
}
))) {
monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("Failed to remove transient models")));
return new IResult.FAILURE(_output_21gswx_a0b);
}
}
 catch (InterruptedException ex) {
monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("TextGen interrupted")));
}
catch (Exception ex) {
monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("Exception during TextGen:" + ex.toString())));
}
 finally {
tgEngine.shutdown();
monitor.currentProgress().finishWork("Writing");
}
default :
return new IResult.SUCCESS(_output_21gswx_a0b);
}
}
}
;
}
