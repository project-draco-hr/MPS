{
  return new IJob.Stub(){
    @Override public IResult execute(    final Iterable<IResource> rawInput,    final IJobMonitor monitor,    final IPropertiesAccessor pa,    @NotNull final ProgressMonitor progressMonitor){
      Iterable<IResource> _output_21gswx_a0b=null;
      final Iterable<GResource> input=(Iterable<GResource>)(Iterable)rawInput;
switch (0) {
case 0:
        for (        final GResource resource : Sequence.fromIterable(input)) {
          final Map<String,Object> texts=MapSequence.fromMap(new HashMap<String,Object>());
          final Map<SNodeReference,String> rootNodeToFileName=MapSequence.fromMap(new HashMap<SNodeReference,String>());
          final Wrappers._T<SModel> model=new Wrappers._T<SModel>();
          final Wrappers._boolean errors=new Wrappers._boolean(false);
          ModelAccess.instance().runReadAction(new Runnable(){
            public void run(){
              model.value=resource.status().getOutputModel();
              if (model.value == null) {
                monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("Generated model in null")));
                errors.value=true;
              }
 else {
                for (                SNode root : model.value.getRootNodes()) {
                  TextGenerationResult tgr=TextGen.generateText(root);
                  errors.value|=tgr.hasErrors();
                  if (errors.value) {
                    for (                    IMessage err : tgr.problems()) {
                      monitor.reportFeedback(new IFeedback.MESSAGE(err));
                    }
                    monitor.reportFeedback(new IFeedback.ERROR(String.valueOf("Failed to generate text")));
                    break;
                  }
                  String ext=TextGen.getExtension(root);
                  String fname=((ext != null ? root.getName() + "." + ext : root.getName()));
                  if (fname == null) {
                    fname="<null> [" + root.getNodeId() + "]";
                    monitor.reportFeedback(new IFeedback.WARNING(String.valueOf("No file name for the root node [" + root.getNodeId() + "]")));
                  }
                  MapSequence.fromMap(texts).put(fname,tgr.getResult());
                  SNodeReference sourceNode=TracingUtil.getInput(root);
                  if (sourceNode != null) {
                    if ((MapSequence.fromMap(rootNodeToFileName).get(sourceNode) == null) || (fname.compareTo(MapSequence.fromMap(rootNodeToFileName).get(sourceNode)) < 0)) {
                      MapSequence.fromMap(rootNodeToFileName).put(sourceNode,fname);
                    }
                  }
                }
              }
            }
          }
);
          if (errors.value) {
            return new IResult.FAILURE(_output_21gswx_a0b);
          }
          _output_21gswx_a0b=Sequence.fromIterable(_output_21gswx_a0b).concat(Sequence.fromIterable(Sequence.<IResource>singleton(new FResource(JavaNameUtil.packageName(model.value),texts,rootNodeToFileName,resource.module(),resource.model()))));
        }
default :
      return new IResult.SUCCESS(_output_21gswx_a0b);
  }
}
}
;
}
