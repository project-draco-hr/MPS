{
  IdeMain.setTestMode(IdeMain.TestMode.CORE_TEST);
  TestMain.configureMPS();
  try {
    SModel baseModel=ModelUtils.readModel(baseFile);
    SModel localModel=ModelUtils.readModel(localFile);
    SModel latestModel=ModelUtils.readModel(latestFile);
    final MergeContext mergeContext=new MergeContext(baseModel,localModel,latestModel);
    if (Sequence.fromIterable(mergeContext.getAllChanges()).all(new IWhereFilter<ModelChange>(){
      public boolean accept(      ModelChange c){
        return Sequence.fromIterable(mergeContext.getConflictedWith(c)).isEmpty();
      }
    }
)) {
      mergeContext.getResultModel().setLoading(true);
      Runnable applyAction=new Runnable(){
        public void run(){
          mergeContext.applyChanges(mergeContext.getAllChanges());
        }
      }
;
      ModelAccess.instance().runReadAction(applyAction);
      if (!(mergeContext.hasIdsToRestore())) {
        byte[] bytes=ModelUtils.modelToBytes(mergeContext.getResultModel());
        OutputStream out=null;
        try {
          out=getResultStream(baseFile);
          out.write(bytes);
          return MERGED;
        }
 catch (        IOException e) {
          return FATAL_ERROR;
        }
 finally {
          FileUtil.closeFileSafe(out);
        }
      }
    }
    return super.mergeFiles(baseFile,localFile,latestFile);
  }
 catch (  IOException e) {
    return FATAL_ERROR;
  }
}
