{
  final Map<ModelChange,Bounds> left=MapSequence.<ModelChange,Bounds>fromMap(new HashMap<ModelChange,Bounds>());
  final Map<ModelChange,Bounds> right=MapSequence.<ModelChange,Bounds>fromMap(new HashMap<ModelChange,Bounds>());
  for (  ModelChange change : ListSequence.<ModelChange>fromList(myChangeSet.getModelChanges())) {
    Bounds leftBounds=findBounds(myLeftEditor.getMessagesForChange(change),getLeftComponent());
    Bounds rightBounds=findBounds(myRightEditor.getMessagesForChange(change),getRightComponent());
    if (leftBounds.length() <= 0 && rightBounds.length() <= 0) {
      continue;
    }
    MapSequence.<ModelChange,Bounds>fromMap(left).put(change,leftBounds);
    MapSequence.<ModelChange,Bounds>fromMap(right).put(change,rightBounds);
  }
  Set<ModelChange> changes=MapSequence.fromMap(left).keySet();
  DisjointSets<ModelChange> ds=new DisjointSets<ModelChange>(changes);
  for (  ModelChange a : SetSequence.<ModelChange>fromSet(changes)) {
    for (    ModelChange b : SetSequence.<ModelChange>fromSet(changes)) {
      if (!((int)MapSequence.<ModelChange,Bounds>fromMap(left).get(a).end() - 1 < (int)MapSequence.<ModelChange,Bounds>fromMap(left).get(b).start() || (int)MapSequence.<ModelChange,Bounds>fromMap(left).get(b).end() - 1 < (int)MapSequence.<ModelChange,Bounds>fromMap(left).get(a).start())) {
        ds.unite(a,b);
      }
      if (!((int)MapSequence.<ModelChange,Bounds>fromMap(right).get(a).end() - 1 < (int)MapSequence.<ModelChange,Bounds>fromMap(right).get(b).start() || (int)MapSequence.<ModelChange,Bounds>fromMap(right).get(b).end() - 1 < (int)MapSequence.<ModelChange,Bounds>fromMap(right).get(a).start())) {
        ds.unite(a,b);
      }
    }
  }
  myChangeGroups=ListSequence.<ChangeGroup>fromList(new ArrayList<ChangeGroup>());
  for (  Set<ModelChange> s : Sequence.<Set<ModelChange>>fromIterable(ds.getSets())) {
    Bounds lb=SetSequence.<ModelChange>fromSet(s).<Bounds>select(new ISelector<ModelChange,Bounds>(){
      public Bounds select(      ModelChange ch){
        return MapSequence.<ModelChange,Bounds>fromMap(left).get(ch);
      }
    }
).reduceLeft(new ILeftCombinator<Bounds,Bounds>(){
      public Bounds combine(      Bounds a,      Bounds b){
        return a.merge(b);
      }
    }
);
    Bounds rb=SetSequence.<ModelChange>fromSet(s).<Bounds>select(new ISelector<ModelChange,Bounds>(){
      public Bounds select(      ModelChange ch){
        return MapSequence.<ModelChange,Bounds>fromMap(right).get(ch);
      }
    }
).reduceLeft(new ILeftCombinator<Bounds,Bounds>(){
      public Bounds combine(      Bounds a,      Bounds b){
        return a.merge(b);
      }
    }
);
    ListSequence.<ChangeGroup>fromList(myChangeGroups).addElement(new ChangeGroup(lb,rb,SetSequence.<ModelChange>fromSet(s).toListSequence(),myMergeContext));
  }
  myChangeGroups=ListSequence.<ChangeGroup>fromList(myChangeGroups).sort(new ISelector<ChangeGroup,Comparable<?>>(){
    public Comparable<?> select(    ChangeGroup g){
      return (int)g.getLeftBounds().start();
    }
  }
,true).toListSequence();
}
