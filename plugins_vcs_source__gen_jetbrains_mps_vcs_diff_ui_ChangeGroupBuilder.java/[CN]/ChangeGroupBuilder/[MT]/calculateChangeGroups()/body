{
  final Map<ModelChange,Bounds> left=MapSequence.fromMap(new HashMap<ModelChange,Bounds>());
  final Map<ModelChange,Bounds> right=MapSequence.fromMap(new HashMap<ModelChange,Bounds>());
  for (  ModelChange change : ListSequence.fromList(myChangeSet.getModelChanges())) {
    Bounds leftBounds=findBounds(myLeftEditor.getMessagesForChange(change),getLeftComponent());
    Bounds rightBounds=findBounds(myRightEditor.getMessagesForChange(change),getRightComponent());
    if (leftBounds.length() == 0 && rightBounds.length() == 0) {
      continue;
    }
    MapSequence.fromMap(left).put(change,leftBounds);
    MapSequence.fromMap(right).put(change,rightBounds);
  }
  Set<ModelChange> changes=MapSequence.fromMap(left).keySet();
  DisjointSets<ModelChange> ds=new DisjointSets<ModelChange>(changes);
  for (  ModelChange a : SetSequence.fromSet(changes)) {
    for (    ModelChange b : SetSequence.fromSet(changes)) {
      if (!((int)MapSequence.fromMap(left).get(a).end() - 1 < (int)MapSequence.fromMap(left).get(b).start() || (int)MapSequence.fromMap(left).get(b).end() - 1 < (int)MapSequence.fromMap(left).get(a).start())) {
        ds.unite(a,b);
      }
      if (!((int)MapSequence.fromMap(right).get(a).end() - 1 < (int)MapSequence.fromMap(right).get(b).start() || (int)MapSequence.fromMap(right).get(b).end() - 1 < (int)MapSequence.fromMap(right).get(a).start())) {
        ds.unite(a,b);
      }
    }
  }
  myChangeGroups=ListSequence.fromList(new ArrayList<ChangeGroup>());
  for (  Set<ModelChange> s : Sequence.fromIterable(ds.getSets())) {
    Bounds lb=SetSequence.fromSet(s).<Bounds>select(new ISelector<ModelChange,Bounds>(){
      public Bounds select(      ModelChange ch){
        return MapSequence.fromMap(left).get(ch);
      }
    }
).reduceLeft(new ILeftCombinator<Bounds,Bounds>(){
      public Bounds combine(      Bounds a,      Bounds b){
        return a.merge(b);
      }
    }
);
    Bounds rb=SetSequence.fromSet(s).<Bounds>select(new ISelector<ModelChange,Bounds>(){
      public Bounds select(      ModelChange ch){
        return MapSequence.fromMap(right).get(ch);
      }
    }
).reduceLeft(new ILeftCombinator<Bounds,Bounds>(){
      public Bounds combine(      Bounds a,      Bounds b){
        return a.merge(b);
      }
    }
);
    ListSequence.fromList(myChangeGroups).addElement(new ChangeGroup(lb,rb,SetSequence.fromSet(s).toListSequence(),myMergeContext));
  }
  myChangeGroups=ListSequence.fromList(myChangeGroups).sort(new ISelector<ChangeGroup,Comparable<?>>(){
    public Comparable<?> select(    ChangeGroup g){
      return (int)g.getLeftBounds().start();
    }
  }
,true).toListSequence();
}
