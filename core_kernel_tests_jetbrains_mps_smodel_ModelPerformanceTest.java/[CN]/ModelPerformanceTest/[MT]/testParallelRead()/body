{
  final TestModelFactory m1f=new TestModelFactory();
  m1f.createModel(20,100,10,5);
  final int initialNodeCount=m1f.countModelNodes();
  myTestModelAccess.enableRead();
  m1f.attachTo(myTestRepo);
  final long baselineMillis=500 * 2;
  ourStats.report("multiThreadBaselineMillis",baselineMillis);
  final int parallelThreads=4;
  final CountDownLatch stopLatch=new CountDownLatch(3);
  CyclicBarrier b=new CyclicBarrier(parallelThreads,new Runnable(){
    @Override public void run(){
      stopLatch.countDown();
    }
  }
);
  ModelReadThread[] threads=new ModelReadThread[parallelThreads];
  for (int i=0; i < parallelThreads; i++) {
    threads[i]=new ModelReadThread(b,m1f);
    threads[i].start();
  }
  boolean finishOk=stopLatch.await(10,TimeUnit.SECONDS);
  if (finishOk) {
    final int expectedNodeCount=3 * initialNodeCount;
    long averageElapsedMillis=0;
    long minElapsedMillis=Long.MAX_VALUE, maxElapsedMillis=0;
    for (int i=0; i < parallelThreads; i++) {
      myErrors.checkThat(threads[i].getName(),threads[i].getAllThreadListenerCount(),equalTo(expectedNodeCount * parallelThreads));
      myErrors.checkThat(threads[i].getName(),threads[i].getThisThreadCount1(),equalTo(expectedNodeCount));
      myErrors.checkThat(threads[i].getName(),threads[i].getThisThreadCount2(),equalTo(expectedNodeCount));
      myErrors.checkThat(threads[i].getName(),threads[i].getElapsedMillis(),new BaseMatcher<Long>(){
        @Override public boolean matches(        Object item){
          if (item instanceof Long) {
            return ((Long)item) < baselineMillis;
          }
          return false;
        }
        @Override public void describeTo(        Description description){
          description.appendText(String.format("less than %d",baselineMillis));
        }
      }
);
      myErrors.checkThat(threads[i].getName(),threads[i].getElapsedMillis(),new BaseMatcher<Long>(){
        @Override public boolean matches(        Object item){
          if (item instanceof Long) {
            return ((Long)item) > baselineMillis / 4;
          }
          return false;
        }
        @Override public void describeTo(        Description description){
          description.appendText(String.format("greater than %d",baselineMillis / 4));
        }
      }
);
      averageElapsedMillis+=threads[i].getElapsedMillis();
      if (threads[i].getElapsedMillis() < minElapsedMillis) {
        minElapsedMillis=threads[i].getElapsedMillis();
      }
      if (threads[i].getElapsedMillis() > maxElapsedMillis) {
        maxElapsedMillis=threads[i].getElapsedMillis();
      }
    }
    averageElapsedMillis/=parallelThreads;
    ourStats.report("multiThreadAverageMillis",averageElapsedMillis);
    ourStats.report("multiThreadMaxMillis",maxElapsedMillis);
    ourStats.report("multiThreadMinMillis",minElapsedMillis);
    return;
  }
  for (int i=0; i < parallelThreads; i++) {
    if (threads[i].isAlive()) {
      Throwable th=new Throwable("Hanging thread " + threads[i].getName());
      th.setStackTrace(threads[i].getStackTrace());
      myErrors.addError(th);
      threads[i].interrupt();
    }
  }
}
