{
  SNode referenceNode=reference.getSourceNode();
  ConceptDeclaration referenceNodeConcept=(ConceptDeclaration)referenceNode.getConceptDeclarationAdapter();
  LinkDeclaration linkDeclaration=SModelUtil_new.findLinkDeclaration(referenceNodeConcept,reference.getRole());
  final AbstractConceptDeclaration referentConcept=linkDeclaration.getTarget();
  SNode sNode=referenceNode.getParent();
  INodeTypesComponent nodeTypesComponent=NodeTypesComponentsRepository.getInstance().createNodeTypesComponent(sNode.getContainingRoot());
  TypeChecker.getInstance().setCurrentTypesComponent(nodeTypesComponent);
  nodeTypesComponent.computeTypesForNode(sNode);
  TypeChecker.getInstance().clearCurrentTypesComponent();
  IStatus status=ModelConstraintsUtil.getReferentSearchScope(referenceNode.getParent(),referenceNode,referenceNodeConcept,linkDeclaration,operationContext.getScope());
  if (status.isError()) {
    LOG.error("Couldn't create referent search scope : " + status.getMessage());
    return false;
  }
  ISearchScope searchScope=(ISearchScope)status.getUserObject();
  List<SNode> nodes=searchScope.getNodes(new Condition<SNode>(){
    public boolean met(    SNode node){
      return node.isInstanceOfConcept(referentConcept);
    }
  }
);
  Condition<SNode> nameMatchesCondition=new Condition<SNode>(){
    public boolean met(    SNode object){
      return reference.getResolveInfo().equals(object.getName());
    }
  }
;
  List<SNode> filtered=CollectionUtil.filter(nodes,nameMatchesCondition);
  if (!filtered.isEmpty()) {
    reference.getSourceNode().setReferent(reference.getRole(),filtered.get(0));
    return true;
  }
  if (referenceNode.getParent() == null) {
    return false;
  }
  SNode parent=referenceNode.getParent();
  LinkDeclaration parentLinkDeclaration=SModelUtil_new.findLinkDeclaration(parent.getConceptDeclarationAdapter(),referenceNode.getRole_());
  final AbstractConceptDeclaration possibleChildConceptDeclaration=parentLinkDeclaration.getTarget();
  ISearchScope conceptsSearchScope=SModelSearchUtil_new.createConceptsFromModelLanguagesScope(parent.getModel(),true,operationContext.getScope());
  List<SNode> applicableConcepts=conceptsSearchScope.getNodes(new Condition<SNode>(){
    public boolean met(    SNode object){
      return SModelUtil_new.isAssignableConcept((ConceptDeclaration)BaseAdapter.fromNode(object),possibleChildConceptDeclaration);
    }
  }
);
  for (  SNode node : applicableConcepts) {
    ConceptDeclaration applicableConcept=(ConceptDeclaration)BaseAdapter.fromNode(node);
    LinkDeclaration smartReference=ChildSubstituteActionsHelper.getSmartReference(applicableConcept,operationContext.getScope());
    if (smartReference == null)     continue;
    List<SNode> smartReferenceTargets=getSmartReferenceTargets(applicableConcept,smartReference,parent,operationContext.getScope());
    List<SNode> filteredRefTargets=CollectionUtil.filter(smartReferenceTargets,nameMatchesCondition);
    if (!filteredRefTargets.isEmpty()) {
      SNode target=filteredRefTargets.get(0);
      SNode newNode=SModelUtil_new.instantiateConceptDeclaration(applicableConcept,referenceNode.getModel()).getNode();
      newNode.setReferent(SModelUtil_new.getGenuineLinkRole(smartReference),target);
      parent.replace(referenceNode,newNode);
      return true;
    }
  }
  return false;
}
