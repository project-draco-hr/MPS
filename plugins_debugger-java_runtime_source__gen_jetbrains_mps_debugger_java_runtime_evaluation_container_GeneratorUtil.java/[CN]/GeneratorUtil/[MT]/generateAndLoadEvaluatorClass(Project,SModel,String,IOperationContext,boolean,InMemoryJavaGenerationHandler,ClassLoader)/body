{
  try {
    final String fullClassName=SNodeOperations.getModelLongName(modelDescriptor) + "." + className;
    GeneratorUtil.MyCompilationResultAdapter compilationResult=new GeneratorUtil.MyCompilationResultAdapter();
    handler.setCompilationListener(compilationResult);
    IMessageHandler messageHandler=new GeneratorUtil.MyMessageHandler(project,developerMode);
    ProgressWindow progressWindow=new ProgressWindow(false,ProjectHelper.toIdeaProject(project));
    boolean successful=GenerationFacade.generateModels(context.getProject(),Collections.singletonList(modelDescriptor),context,handler,new ProgressMonitorAdapter(progressWindow),messageHandler,GenerationOptions.getDefaults().incremental(new DefaultNonIncrementalStrategy()).saveTransientModels(developerMode).rebuildAll(false).reporting(false,false,false,0).create(),context.getProject().getComponent(TransientModelsProvider.class));
    Disposer.dispose(progressWindow);
    String source=handler.getSources().get(fullClassName);
    if (successful && (source != null && source.length() > 0)) {
      if (developerMode) {
        System.err.println("[Generated text]\n" + source + "\n[Generated text]");
      }
      return Class.forName(fullClassName,true,handler.getCompiler().getClassLoader(parentloader));
    }
 else     if ((source != null && source.length() > 0) && !(successful)) {
      String text="Errors during compilation";
      if (compilationResult.hasErrors()) {
        text+=":\n" + compilationResult.getMessage();
      }
 else {
        text+=".";
      }
      throw new EvaluationException(text);
    }
 else {
      throw new EvaluationException("Errors during generation.");
    }
  }
 catch (  EvaluationException e) {
    throw e;
  }
catch (  ClassNotFoundException e) {
    throw new EvaluationException(e);
  }
}
