{
  List<SearchResult<ModelCheckerIssue>> results=ListSequence.fromList(new ArrayList<SearchResult<ModelCheckerIssue>>());
  for (  final SNode node : ListSequence.fromList(SModelOperations.getNodes(model,null))) {
    if (!(progressContext.checkAndUpdateIndicator("Checking " + SModelOperations.getModelName(model) + " for cardinalities and properties constraints..."))) {
      break;
    }
    SNode concept=SNodeOperations.getConceptDeclaration(node);
    for (    SNode link : ListSequence.fromList(AbstractConceptDeclaration_Behavior.call_getLinkDeclarations_1213877394480(concept))) {
      if (LinkDeclaration_Behavior.call_isAtLeastOneCardinality_3386205146660812199(link)) {
        if (SPropertyOperations.hasValue(link,"metaClass","aggregation","reference")) {
          if (ListSequence.fromList(SNodeOperations.getChildren(node,link)).isEmpty()) {
            addIssue(results,node,"Cardinality constraint violation in role \"" + SPropertyOperations.getString(link,"role") + "\"",ModelChecker.CATEGORY_ERROR,null);
          }
        }
 else {
          if ((SLinkOperations.getTargetNode(SNodeOperations.getReference(node,link)) == null)) {
            addIssue(results,node,"Cardinality constraint violation in role \"" + SPropertyOperations.getString(link,"role") + "\"",ModelChecker.CATEGORY_ERROR,null);
          }
        }
      }
    }
    for (    final SNode child : ListSequence.fromList(SNodeOperations.getChildren(node)).where(new IWhereFilter<SNode>(){
      public boolean accept(      SNode it){
        return !(SNodeOperations.isAttribute(it));
      }
    }
)) {
      if (!(ModelCheckerUtils.isDeclaredLink(SNodeOperations.getContainingLinkDeclaration(child),true))) {
        addIssue(results,node,"Usage of undeclared child role \"" + SNodeOperations.getContainingLinkRole(child) + "\"",ModelChecker.CATEGORY_WARNING,new IModelCheckerFix(){
          public boolean doFix(){
            ListSequence.fromList(SNodeOperations.getChildren(node,SNodeOperations.getContainingLinkDeclaration(child))).visitAll(new IVisitor<SNode>(){
              public void visit(              SNode child){
                SNodeOperations.deleteNode(child);
              }
            }
);
            return true;
          }
        }
);
      }
    }
    for (    final SReference reference : ListSequence.fromList(SNodeOperations.getReferences(node))) {
      if (!(ModelCheckerUtils.isDeclaredLink(SLinkOperations.findLinkDeclaration(reference),false))) {
        addIssue(results,node,"Usage of undeclared reference role \"" + reference + "\"",ModelChecker.CATEGORY_WARNING,new IModelCheckerFix(){
          public boolean doFix(){
            node.removeReferent(SLinkOperations.getRole(reference));
            return true;
          }
        }
);
      }
    }
    ConceptAndSuperConceptsScope chs=new ConceptAndSuperConceptsScope(((AbstractConceptDeclaration)SNodeOperations.getAdapter(concept)));
    List<PropertyDeclaration> props=chs.getAdapters(PropertyDeclaration.class);
    for (    PropertyDeclaration p : ListSequence.fromList(props)) {
      PropertySupport ps=PropertySupport.getPropertySupport(p);
      String value=ps.fromInternalValue(node.getProperty(p.getName()));
      if (!(ps.canSetValue(node,p.getName(),value,operationContext.getScope()))) {
        addIssue(results,node,"Property constraint violation for property \"" + p.getName() + "\"",ModelChecker.CATEGORY_WARNING,null);
      }
    }
    for (    final String name : SetSequence.fromSet(node.getPropertyNames())) {
      if (node.isRoot() && SModelTreeNode.PACK.equals(name)) {
        continue;
      }
      if (!(isDeclaredProperty(concept,name))) {
        addIssue(results,node,"Usage of undeclared property \"" + name + "\"",ModelChecker.CATEGORY_WARNING,new IModelCheckerFix(){
          public boolean doFix(){
            node.setProperty(name,null,false);
            return true;
          }
        }
);
      }
    }
  }
  return results;
}
