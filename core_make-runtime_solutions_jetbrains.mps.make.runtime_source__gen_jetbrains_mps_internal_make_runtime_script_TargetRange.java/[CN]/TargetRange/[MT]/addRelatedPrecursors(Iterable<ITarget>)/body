{
  Set<ITarget.Name> valences=SetSequence.<ITarget.Name>fromSetWithValues(new HashSet<ITarget.Name>(),Sequence.<ITarget>fromIterable(MapSequence.fromMap(targetsView).values()).<ITarget.Name>translate(new ITranslator2<ITarget,ITarget.Name>(){
    public Iterable<ITarget.Name> translate(    ITarget trg){
      return Sequence.<ITarget.Name>fromIterable(trg.after()).concat(Sequence.<ITarget.Name>fromIterable(trg.notAfter()));
    }
  }
));
  List<ITarget> available=Sequence.<ITarget>fromIterable(availableTargets).toListSequence();
  int atsize;
  do {
    atsize=SetSequence.<ITarget>fromSet(allTargets).count();
    for (Iterator<ITarget> it=ListSequence.<ITarget>fromList(available).iterator(); it.hasNext(); ) {
      ITarget trg=it.next();
      Iterable<ITarget.Name> trgvals=Sequence.<ITarget.Name>fromIterable(trg.before()).concat(Sequence.<ITarget.Name>fromIterable(trg.notBefore()));
      if (SetSequence.<ITarget.Name>fromSet(valences).contains(trg.getName()) || Sequence.<ITarget.Name>fromIterable(trgvals).any(new IWhereFilter<ITarget.Name>(){
        public boolean accept(        ITarget.Name tn){
          return MapSequence.fromMap(targetsView).containsKey(tn);
        }
      }
)) {
        addTarget(trg);
        SetSequence.fromSet(valences).addSequence(Sequence.<ITarget.Name>fromIterable(trg.after()).concat(Sequence.<ITarget.Name>fromIterable(trg.notAfter())));
        it.remove();
      }
    }
  }
 while (atsize < SetSequence.<ITarget>fromSet(allTargets).count());
}
