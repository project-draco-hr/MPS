{
  project.getRepository().getModelAccess().runReadAction(new Runnable(){
    public void run(){
      for (      IMapping<MoveNodesUtil.NodeProcessor,List<SNode>> mapping : MapSequence.fromMap(processorToMoveRoots)) {
        if (!(mapping.key().isValid(mapping.value()))) {
          throw new IllegalArgumentException();
        }
      }
    }
  }
);
  final Map<SNodeReference,List<SNodeReference>> moveRootsToDescendants=MapSequence.fromMap(new HashMap<SNodeReference,List<SNodeReference>>());
  final List<SNode> allNodes=ListSequence.fromList(new ArrayList<SNode>());
  project.getRepository().getModelAccess().runReadAction(new Runnable(){
    public void run(){
      for (      IMapping<MoveNodesUtil.NodeProcessor,List<SNode>> mapping : MapSequence.fromMap(processorToMoveRoots)) {
        MoveNodesUtil.NodeProcessor processor=mapping.key();
        for (        SNode moveRoot : ListSequence.fromList(mapping.value())) {
          List<SNode> nodesToSearch=processor.getNodesToSearch(moveRoot);
          MapSequence.fromMap(moveRootsToDescendants).put(moveRoot.getReference(),ListSequence.fromList(nodesToSearch).select(new ISelector<SNode,SNodeReference>(){
            public SNodeReference select(            SNode it){
              return it.getReference();
            }
          }
).toListSequence());
          ListSequence.fromList(allNodes).addSequence(ListSequence.fromList(nodesToSearch));
        }
      }
    }
  }
);
  final MoveNodesUtil.ListIndex<SNodeReference> nodeChangesCorrespondence=new MoveNodesUtil.ListIndex<SNodeReference>(ListSequence.fromList(allNodes).select(new ISelector<SNode,SNodeReference>(){
    public SNodeReference select(    SNode it){
      return it.getReference();
    }
  }
).toListSequence());
  Iterable<? extends RefactoringParticipant<?,?,SNode,SNode>> participants=(Iterable<? extends RefactoringParticipant<?,?,SNode,SNode>>)new ExtensionPoint<MoveNodeRefactoringParticipant<?,?>>("jetbrains.mps.refactoring.participant.MoveNodeParticipantEP").getObjects();
  final Map<SNode,RefactoringParticipant.KeepOldNodes> removeOldRoots=MapSequence.fromMap(new HashMap<SNode,RefactoringParticipant.KeepOldNodes>());
  RefactoringProcessor.performRefactoringUserInteractive(project,refactoringName,participants,allNodes,new _FunctionTypes._return_P2_E0<Map<SNode,SNode>,Iterable<RefactoringParticipant.ParticipantApplied<?,?,SNode,SNode,SNode,SNode>>,RefactoringSession>(){
    public Map<SNode,SNode> invoke(    final Iterable<RefactoringParticipant.ParticipantApplied<?,?,SNode,SNode,SNode,SNode>> participantStates,    RefactoringSession refactoringSession){
      for (      IMapping<MoveNodesUtil.NodeProcessor,List<SNode>> mapping : MapSequence.fromMap(processorToMoveRoots)) {
        List<SNode> moveRoots=mapping.value();
        MoveNodesUtil.NodeProcessor processor=mapping.key();
        for (        SNode moveRoot : ListSequence.fromList(moveRoots)) {
          MapSequence.fromMap(removeOldRoots).put(moveRoot,RefactoringParticipant.KeepOldNodes.max(ListSequence.fromList(MapSequence.fromMap(moveRootsToDescendants).get(moveRoot.getReference())).translate(new ITranslator2<SNodeReference,RefactoringParticipant.KeepOldNodes>(){
            public Iterable<RefactoringParticipant.KeepOldNodes> translate(            final SNodeReference descendant){
              return Sequence.fromIterable(participantStates).select(new ISelector<RefactoringParticipant.ParticipantApplied<?,?,SNode,SNode,SNode,SNode>,RefactoringParticipant.KeepOldNodes>(){
                public RefactoringParticipant.KeepOldNodes select(                RefactoringParticipant.ParticipantApplied<?,?,SNode,SNode,SNode,SNode> participantState){
                  List<? extends RefactoringParticipant.Change<?,?>> changes=nodeChangesCorrespondence.getCorrespondent(participantState.getChanges(),descendant);
                  return RefactoringParticipant.KeepOldNodes.max(ListSequence.fromList(changes).select(new ISelector<RefactoringParticipant.Change<?,?>,RefactoringParticipant.KeepOldNodes>(){
                    public RefactoringParticipant.KeepOldNodes select(                    RefactoringParticipant.Change<?,?> change){
                      return ((MoveNodeRefactoringParticipant.MoveNodeChange<?,?>)((RefactoringParticipant.Change)change)).needsToPreserveOldNode();
                    }
                  }
));
                }
              }
);
            }
          }
)));
        }
        processor.process(moveRoots,removeOldRoots,refactoringSession);
      }
      return MoveNodesUtil.NodeCopyTracker.get(refactoringSession).getCopyMap();
    }
  }
,new _FunctionTypes._void_P1_E0<RefactoringSession>(){
    public void invoke(    RefactoringSession refactoringSession){
      for (      MoveNodesUtil.NodeProcessor processor : SetSequence.fromSet(MapSequence.fromMap(processorToMoveRoots).keySet())) {
        processor.removeAfterRefactoring(removeOldRoots,refactoringSession);
      }
    }
  }
);
}
