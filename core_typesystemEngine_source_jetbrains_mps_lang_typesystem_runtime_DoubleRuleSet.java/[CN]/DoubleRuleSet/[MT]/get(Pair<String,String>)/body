{
  Set<T> result=myRulesCache.get(key);
  if (result != null) {
    return result;
  }
  String c1=key.o1;
  String c2=key.o2;
  if (!isInterfaceConcept(c1) && !isInterfaceConcept(c2)) {
    for (String conceptDeclaration1=c1; conceptDeclaration1 != null; conceptDeclaration1=getSuperConcept(conceptDeclaration1)) {
      for (String conceptDeclaration2=c2; conceptDeclaration2 != null; conceptDeclaration2=getSuperConcept(conceptDeclaration2)) {
        Pair<String,String> newKey=new Pair<String,String>(conceptDeclaration1,conceptDeclaration2);
        result=myRules.get(newKey);
        if (result != null) {
          if (conceptDeclaration1 != key.o1 || conceptDeclaration2 != key.o2) {
            myRules.putIfAbsent(key,result);
          }
synchronized (result) {
            Set<T> clone=Collections.unmodifiableSet(new THashSet<T>(result));
            myRulesCache.putIfAbsent(key,clone);
          }
          return Collections.unmodifiableSet(result);
        }
      }
    }
  }
  myRules.putIfAbsent(key,Collections.synchronizedSet(new HashSet<T>(1)));
  myRulesCache.putIfAbsent(key,Collections.<T>emptySet());
  return Collections.emptySet();
}
