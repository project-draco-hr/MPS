{
  Set<T> result=myRulesCache.get(key);
  if (result != null) {
    return result;
  }
  return NodeReadAccessCasterInEditor.runReadTransparentAction(new Computable<Set<T>>(){
    @Override public Set<T> compute(){
      Set<T> result;
      String c1=key.o1;
      String c2=key.o2;
      if (!isInterfaceConcept(c1) && !isInterfaceConcept(c2)) {
        for (String conceptDeclaration1=c1; conceptDeclaration1 != null; conceptDeclaration1=getSuperConcept(conceptDeclaration1)) {
          for (String conceptDeclaration2=c2; conceptDeclaration2 != null; conceptDeclaration2=getSuperConcept(conceptDeclaration2)) {
            Pair<String,String> newKey=new Pair<String,String>(conceptDeclaration1,conceptDeclaration2);
            result=myRules.get(newKey);
            if (result != null && !result.isEmpty()) {
              if (!conceptDeclaration1.equals(key.o1) || !conceptDeclaration2.equals(key.o2)) {
                myRules.putIfAbsent(key,result);
              }
synchronized (result) {
                Set<T> clone=Collections.unmodifiableSet(new THashSet<T>(result));
                myRulesCache.putIfAbsent(key,clone);
                return clone;
              }
            }
          }
        }
      }
      myRules.putIfAbsent(key,Collections.synchronizedSet(new HashSet<T>(1)));
      myRulesCache.putIfAbsent(key,Collections.<T>emptySet());
      return Collections.emptySet();
    }
  }
);
}
