{
  Set<T> result=myRulesCache.get(key);
  if (result != null) {
    return Collections.unmodifiableSet(result);
  }
  String c1=key.o1;
  String c2=key.o2;
  if (!isInterfaceConcept(c1) && !isInterfaceConcept(c2)) {
    for (String conceptDeclaration1=c1; conceptDeclaration1 != null; conceptDeclaration1=getSuperConcept(conceptDeclaration1)) {
      for (String conceptDeclaration2=c2; conceptDeclaration2 != null; conceptDeclaration2=getSuperConcept(conceptDeclaration2)) {
        Pair<String,String> newKey=new Pair<String,String>(conceptDeclaration1,conceptDeclaration2);
        result=myRules.get(newKey);
        if (result != null) {
          if (conceptDeclaration1 != key.o1 || conceptDeclaration2 != key.o2) {
            myRules.putIfAbsent(key,result);
          }
          myRulesCache.putIfAbsent(key,new THashSet<T>(result));
          return Collections.unmodifiableSet(result);
        }
      }
    }
  }
  result=Collections.synchronizedSet(new HashSet<T>(1));
  myRules.putIfAbsent(key,result);
  myRulesCache.putIfAbsent(key,new HashSet<T>(1));
  return Collections.unmodifiableSet(result);
}
