{
  List<SAbstractConcept> others=ListSequence.fromListAndArray(new ArrayList<SAbstractConcept>(),MetaAdapterFactory.getConcept(0x8388864671ce4f1cL,0x9c53c54016f6ad4fL,0x10c260e9444L,"jetbrains.mps.baseLanguage.collections.structure.SequenceType"),MetaAdapterFactory.getConcept(0x8388864671ce4f1cL,0x9c53c54016f6ad4fL,0x10c25fb076aL,"jetbrains.mps.baseLanguage.collections.structure.ListType"),MetaAdapterFactory.getConcept(0x8388864671ce4f1cL,0x9c53c54016f6ad4fL,0x11d91cbbcd0L,"jetbrains.mps.baseLanguage.collections.structure.SetType"),MetaAdapterFactory.getConcept(0x8388864671ce4f1cL,0x9c53c54016f6ad4fL,0x120c482dd1aL,"jetbrains.mps.baseLanguage.collections.structure.SortedSetType"));
  SConcept act=MetaAdapterFactory.getConcept(0x8388864671ce4f1cL,0x9c53c54016f6ad4fL,0x4eec26fcbaf8c39bL,"jetbrains.mps.baseLanguage.collections.structure.AbstractContainerType");
  return ListSequence.fromList(others).concat(ListSequence.fromList(SConceptOperations.getAllSubConcepts2(act,SNodeOperations.getModel(node))).where(new IWhereFilter<SConcept>(){
    public boolean accept(    SConcept it){
      return !(it.isAbstract());
    }
  }
)).toListSequence();
}
