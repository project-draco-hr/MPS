{
  SNode meth=getFunctionMethod(literal,targetIfaceErase);
  SNode funType=SNodeOperations.cast(TypeChecker.getInstance().getTypeOf(literal),"jetbrains.mps.baseLanguage.closures.structure.FunctionType");
  TypeMatcher matcher=new TypeMatcher();
  if ((SLinkOperations.getTarget(meth,"returnType",true) != null) && !(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(meth,"returnType",true),"jetbrains.mps.baseLanguage.structure.VoidType"))) {
    matcher.matchReturnType(SLinkOperations.getTarget(meth,"returnType",true),FunctionType_Behavior.call_getNormalizedReturnType_1213877405252(funType));
    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(meth,"returnType",true),"jetbrains.mps.baseLanguage.structure.ClassifierType")) {
      SNode absRetCT=SNodeOperations.copyNode(SNodeOperations.cast(SLinkOperations.getTarget(meth,"returnType",true),"jetbrains.mps.baseLanguage.structure.ClassifierType"));
      SNode ftResCT=FunctionTypeUtil.unmeet(FunctionType_Behavior.call_getNormalizedReturnType_1213877405252(funType));
      String adapterName=JavaNameUtil.shortName(SPropertyOperations.getString(SLinkOperations.getTarget(absRetCT,"classifier",false),"name")) + JavaNameUtil.shortName(SPropertyOperations.getString(SLinkOperations.getTarget(SNodeOperations.as(FunctionTypeUtil.unmeet(FunctionTypeUtil.unbound(ftResCT)),"jetbrains.mps.baseLanguage.structure.ClassifierType"),"classifier",false),"name")) + "Adapter";
      for (      SNode cls : SModelOperations.getNodes(SNodeOperations.getModel(SLinkOperations.getTarget(absRetCT,"classifier",false)),"jetbrains.mps.baseLanguage.structure.Classifier")) {
        if (adapterName.equals(JavaNameUtil.shortName(SPropertyOperations.getString(cls,"name")))) {
          SNode newRetCT=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassifierType",null);
          SLinkOperations.setTarget(newRetCT,"classifier",cls,false);
          Values.RETURN_TYPE.set(genContext,targetIfaceErase,newRetCT);
          break;
        }
      }
    }
  }
{
    Iterator<SNode> funParamIt=ListSequence.fromList(FunctionType_Behavior.call_getNormalizedParameterTypes_1213877405276(funType)).iterator();
    Iterator<SNode> methParamIt=ListSequence.fromList(SLinkOperations.getTargets(meth,"parameter",true)).iterator();
    while (funParamIt.hasNext() && methParamIt.hasNext()) {
      matcher.matchType(SLinkOperations.getTarget(methParamIt.next(),"type",true),funParamIt.next());
    }
    if (funParamIt.hasNext() || methParamIt.hasNext()) {
      genContext.showErrorMessage(literal,"Closure parameters count doesn't match method '" + SPropertyOperations.getString(meth,"name") + "' in "+ JavaNameUtil.fqClassName(SLinkOperations.getTarget(targetIfaceErase,"classifier",false),SPropertyOperations.getString(SLinkOperations.getTarget(targetIfaceErase,"classifier",false),"name")));
    }
  }
{
    List<SNode> normFunThrowsTypes=FunctionType_Behavior.call_getNormalizedThrowsTypes_3448422702164385781(funType);
    Iterator<SNode> funThrIt=ListSequence.fromList(normFunThrowsTypes).sort(new ISelector<SNode,Comparable<?>>(){
      @Override public Comparable<?> select(      SNode t){
        String key=BehaviorReflection.invokeVirtual(String.class,SLinkOperations.getTarget(SNodeOperations.as(t,"jetbrains.mps.baseLanguage.structure.ClassifierType"),"classifier",false),"virtual_getNestedName_8540045600162184125",new Object[]{});
        return (key != null ? key : BehaviorReflection.invokeVirtual(String.class,t,"virtual_getPresentation_1213877396640",new Object[]{}));
      }
    }
,true).iterator();
    Iterator<SNode> methThrIt=ListSequence.fromList(FunctionTypeUtil.normalizeThrowsTypes(SLinkOperations.getTargets(meth,"throwsItem",true))).iterator();
    while (funThrIt.hasNext() && methThrIt.hasNext()) {
      matcher.matchType(methThrIt.next(),funThrIt.next());
    }
    if (funThrIt.hasNext() || methThrIt.hasNext()) {
      genContext.showWarningMessage(literal,"Closure generic throws types count doesn't match method '" + SPropertyOperations.getString(meth,"name") + "' in "+ JavaNameUtil.fqClassName(SLinkOperations.getTarget(targetIfaceErase,"classifier",false),SPropertyOperations.getString(SLinkOperations.getTarget(targetIfaceErase,"classifier",false),"name")));
    }
  }
  Values.TYPE_MAP.set(genContext,targetIfaceErase,matcher.getMap());
  Map<SNode,SNode> map=matcher.getMap();
  if (map != null) {
    Iterator<SNode> reifiedTypeIt=ListSequence.fromList(reifiedTargetIfaceTypeParams).iterator();
    Iterator<SNode> targetTypeVarIt=ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(targetIfaceErase,"classifier",false),"typeVariableDeclaration",true)).iterator();
    while (reifiedTypeIt.hasNext() && targetTypeVarIt.hasNext()) {
      SNode typeVar=targetTypeVarIt.next();
      SNode rtp=reifiedTypeIt.next();
      SNode substituteType=(MapSequence.fromMap(map).containsKey(typeVar) ? SNodeOperations.copyNode(MapSequence.fromMap(map).get(typeVar)) : SNodeOperations.copyNode(rtp));
      if (!(hasTypeVariable(rtp)) && !(TypeChecker.getInstance().getSubtypingManager().isSubtype(substituteType,rtp))) {
        substituteType=ClassifierTypeUtil.getTypeCoercedToClassifierType(SNodeOperations.copyNode(rtp));
      }
      SNode param=ListSequence.fromList(SLinkOperations.getTargets(targetIfaceErase,"parameter",true)).addElement(substituteType);
    }
    if (reifiedTypeIt.hasNext() || targetTypeVarIt.hasNext()) {
      genContext.showWarningMessage(literal,"Reified type parameters count doesn't match method declaration '" + SPropertyOperations.getString(meth,"name") + "' in "+ JavaNameUtil.fqClassName(SLinkOperations.getTarget(targetIfaceErase,"classifier",false),SPropertyOperations.getString(SLinkOperations.getTarget(targetIfaceErase,"classifier",false),"name")));
    }
  }
}
