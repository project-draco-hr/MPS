{
  this.myExpression=node;
  this.myContainer=findContainer(node);
  findDuplicates();
  SNode expressionType=this.getExpressionType(node);
  if (!(SNodeOperations.isInstanceOf(expressionType,"jetbrains.mps.baseLanguage.structure.Type"))) {
    return "Couldn't compute type of expression: " + expressionType;
  }
 else   if (this.isVoidType(expressionType)) {
    return "Expression has no type";
  }
 else {
    this.myExpressionType=SNodeOperations.cast(expressionType,"jetbrains.mps.baseLanguage.structure.Type");
    Set<String> expectedNames=SetSequence.fromSet(new HashSet<String>());
    String expectedVariableName=null;
    if (SNodeOperations.isInstanceOf(node,"jetbrains.mps.baseLanguage.structure.Expression")) {
      expectedVariableName=Expression_Behavior.call_getVariableExpectedName_1213877519781(SNodeOperations.cast(node,"jetbrains.mps.baseLanguage.structure.Expression"));
    }
    if (expectedVariableName != null) {
      SetSequence.fromSet(expectedNames).addElement(NameUtil.decapitalize(expectedVariableName));
    }
    List<String> variableSuffixes=Type_Behavior.call_getVariableSuffixes_1213877337304(myExpressionType);
    if (variableSuffixes != null) {
      SetSequence.fromSet(expectedNames).addSequence(ListSequence.fromList(variableSuffixes));
    }
    this.myExpectedNames=SetSequence.fromSet(expectedNames).where(new IWhereFilter<String>(){
      public boolean accept(      String it){
        return it.matches("[a-zA-Z0-9_]*");
      }
    }
).toListSequence();
    if (ListSequence.fromList(this.myExpectedNames).isEmpty()) {
      ListSequence.fromList(this.myExpectedNames).addElement("");
    }
    return null;
  }
}
