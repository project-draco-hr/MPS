{
  Thread t=Thread.currentThread();
  System.err.println("current thread is " + t);
  ModelAccess.instance().runReadAction(new Runnable(){
    public void run(){
      SModelRepository.getInstance().saveAll();
    }
  }
);
  final ILoggableRefactoring refactoring=refactoringContext.getRefactoring();
  Runnable runnable=new Runnable(){
    public void run(){
      ModelAccess.instance().runWriteActionInCommand(new Runnable(){
        public void run(){
          SModelDescriptor modelDescriptor=context.getModel();
          SModelUID initialModelUID=modelDescriptor.getModelUID();
          refactoring.doRefactor(context,refactoringContext);
          SModel model=modelDescriptor.getSModel();
          refactoringContext.computeCaches();
          SearchResults usages=refactoringContext.getUsages();
          final Map<IModule,List<SModel>> moduleToModelsMap=refactoring.getModelsToGenerate(context,refactoringContext);
          List<SModel> modelsToUpdate=refactoring.getModelsToUpdate(context,refactoringContext);
          if (!refactoringContext.isLocal()) {
            if (refactoring.doesUpdateModel()) {
              writeIntoLog(model,refactoringContext);
              for (              SModelDescriptor anotherDescriptor : SModelRepository.getInstance().getAllModelDescriptors()) {
                String stereotype=anotherDescriptor.getStereotype();
                if (!stereotype.equals(SModelStereotype.NONE) && !stereotype.equals(SModelStereotype.TEMPLATES)) {
                  continue;
                }
                if (!anotherDescriptor.isInitialized())                 continue;
                SModel anotherModel=anotherDescriptor.getSModel();
                Set<SModelUID> dependenciesModels=anotherModel.getDependenciesModelUIDs();
                if (model != anotherModel && !dependenciesModels.contains(initialModelUID))                 continue;
                processModel(anotherModel,model,refactoringContext);
              }
            }
          }
 else {
            if (refactoring.doesUpdateModel()) {
              Set<SModel> modelsToProcess=new LinkedHashSet<SModel>();
              if (usages != null) {
                modelsToProcess.addAll(usages.getModelsWithResults());
              }
              modelsToProcess.addAll(modelsToUpdate);
              for (              SModel anotherModel : modelsToProcess) {
                processModel(anotherModel,model,refactoringContext);
              }
            }
          }
          SwingUtilities.invokeLater(new Runnable(){
            public void run(){
              if (moduleToModelsMap != null && !moduleToModelsMap.isEmpty()) {
                ProgressManager.getInstance().run(new Modal(context.getOperationContext().getComponent(Project.class),"Generation",true){
                  public void run(                  @NotNull ProgressIndicator progress){
                    generateModels(context,moduleToModelsMap,refactoringContext,progress);
                  }
                }
);
                if (continuation != null) {
                  continuation.run();
                }
              }
            }
          }
);
        }
      }
);
    }
  }
;
  ThreadUtils.runInUIThreadNoWait(runnable);
}
