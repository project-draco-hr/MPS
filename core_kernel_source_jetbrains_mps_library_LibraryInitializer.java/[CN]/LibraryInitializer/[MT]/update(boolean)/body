{
  ModelAccess.assertLegalWrite();
  Set<SLibrary> toUnload=new HashSet<SLibrary>(myLibraries);
  Set<SLibrary> toLoad=new HashSet<SLibrary>();
  myParentLoaders.clear();
  for (  LibraryContributor lc : myContributors) {
    for (    LibDescriptor s : lc.getLibraries()) {
      IFile path=FileSystem.getInstance().getFileByPath(s.path);
      SLibrary lib=new SLibrary(path,s.parentLoader,lc.hiddenLanguages());
      toUnload.remove(lib);
      if (!myLibraries.contains(lib)) {
        myLibraries.add(lib);
        toLoad.add(lib);
      }
      IFile bundlePath=FileSystem.getInstance().isPackaged(path) ? FileSystem.getInstance().getBundleHome(path) : null;
      myParentLoaders.put(bundlePath != null ? bundlePath.getPath() : s.path,s.parentLoader != null ? s.parentLoader : LibraryInitializer.class.getClassLoader());
    }
  }
  for (  SLibrary unloadLib : toUnload) {
    unloadLib.dispose();
  }
  for (  SLibrary loadLib : toLoad) {
    loadLib.attach(refreshFiles);
  }
  if (toUnload.isEmpty() && toLoad.isEmpty())   return;
  CleanupManager.getInstance().cleanup();
  ClassLoaderManager.getInstance().updateClassPath();
  LanguageRegistry.getInstance().loadLanguages();
  ExtensionRegistry.getInstance().loadExtensionDescriptors();
  for (  IModule m : MPSModuleRepository.getInstance().getAllModules()) {
    m.invalidateDependencies();
  }
}
