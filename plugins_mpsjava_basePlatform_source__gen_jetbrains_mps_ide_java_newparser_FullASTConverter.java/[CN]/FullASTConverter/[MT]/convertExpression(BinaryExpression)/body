{
  if (x instanceof AND_AND_Expression) {
    return convertExpression((AND_AND_Expression)x);
  }
 else   if (x instanceof CombinedBinaryExpression) {
    return convertExpression((CombinedBinaryExpression)x);
  }
 else   if (x instanceof EqualExpression) {
    return convertExpression((EqualExpression)x);
  }
 else   if (x instanceof OR_OR_Expression) {
    return convertExpression((OR_OR_Expression)x);
  }
 else {
    SNode op;
    int binOp=(x.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT;
switch (binOp) {
case OperatorIds.LEFT_SHIFT:
      op=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ShiftLeftExpression",null);
    break;
case OperatorIds.RIGHT_SHIFT:
  op=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ShiftRightExpression",null);
break;
case OperatorIds.UNSIGNED_RIGHT_SHIFT:
op=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ShiftRightUnsignedExpression",null);
break;
case OperatorIds.PLUS:
op=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.PlusExpression",null);
break;
case OperatorIds.MINUS:
op=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.MinusExpression",null);
break;
case OperatorIds.REMAINDER:
op=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.RemExpression",null);
break;
case OperatorIds.XOR:
op=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BitwiseXorExpression",null);
break;
case OperatorIds.AND:
op=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BitwiseAndExpression",null);
break;
case OperatorIds.MULTIPLY:
op=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.MulExpression",null);
break;
case OperatorIds.OR:
op=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BitwiseOrExpression",null);
break;
case OperatorIds.DIVIDE:
op=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.DivExpression",null);
break;
case OperatorIds.LESS_EQUAL:
op=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LessThanOrEqualsExpression",null);
break;
case OperatorIds.GREATER_EQUAL:
op=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.GreaterThanOrEqualsExpression",null);
break;
case OperatorIds.GREATER:
op=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.GreaterThanExpression",null);
break;
case OperatorIds.LESS:
op=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.LessThanExpression",null);
break;
default :
throw new JavaParseException("Unsupported operator for BinaryExpression");
}
return convertBinaryOperation(x.left,x.right,op);
}
}
