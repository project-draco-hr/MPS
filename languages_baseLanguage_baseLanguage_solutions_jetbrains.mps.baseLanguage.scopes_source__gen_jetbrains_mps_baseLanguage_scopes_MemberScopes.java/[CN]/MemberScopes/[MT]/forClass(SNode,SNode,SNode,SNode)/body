{
  TransactionCache cache=ModelAccess.instance().getTransactionCache(MemberScopes.class);
  Scope cached=(Scope)cache.get(MultiTuple.<SNode,SNode>from(classNode,kind));
  if (cached != null) {
    return cached;
  }
  Scope result=null;
  if (SConceptOperations.isSubConceptOf(kind,"jetbrains.mps.baseLanguage.structure.FieldDeclaration")) {
    result=FieldDeclarationScope.forClass(classNode,extendsClass,implementedInterfaces);
  }
 else   if (SConceptOperations.isSubConceptOf(kind,"jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration")) {
    result=EnumConstantDeclarationScope.forClass(classNode,extendsClass,implementedInterfaces);
  }
 else   if (SConceptOperations.isSubConceptOf(kind,"jetbrains.mps.baseLanguage.structure.Property")) {
    result=PropertyScope.forClass(classNode,extendsClass,implementedInterfaces);
  }
 else   if (SConceptOperations.isSubConceptOf(kind,"jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration")) {
    result=StaticFieldDeclarationScope.forClass(classNode,extendsClass,implementedInterfaces);
  }
 else   if (SConceptOperations.isSubConceptOf(kind,"jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration")) {
    result=StaticMethodDeclarationScope.forClass(classNode,extendsClass,implementedInterfaces);
  }
 else   if (SConceptOperations.isSubConceptOf(kind,"jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration")) {
    result=InstanceMethodDeclarationScope.forClass(classNode,extendsClass,implementedInterfaces);
  }
  if (result != null) {
    cache.put(MultiTuple.<SNode,SNode>from(classNode,kind),result);
  }
  return result;
}
