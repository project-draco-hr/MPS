{
  Tuples._2<SNode,SNode> key=MultiTuple.<SNode,SNode>from(classifier,kind);
  boolean isTransient=SNodeOperations.getModel(classifier).isTransient();
  ConcurrentMap<Tuples._2<SNode,SNode>,Scope> cache=null;
  if (!(isTransient)) {
    cache=ModelAccess.instance().getRepositoryStateCache(MemberScopes.class);
    if (cache != null) {
      Scope cached=cache.get(((Object)key));
      if (cached != null) {
        return cached;
      }
    }
  }
  if (SetSequence.fromSet(inCalculatingScopes.get()).contains(key)) {
    if (log.isWarnEnabled()) {
      log.warn("Recursion preventing for " + key);
    }
    return new EmptyScope();
  }
  SetSequence.fromSet(inCalculatingScopes.get()).addElement(key);
  Scope result=null;
  try {
    result=scope.invoke();
  }
  finally {
    SetSequence.fromSet(inCalculatingScopes.get()).removeElement(key);
  }
  if (result != null && !(isTransient) && cache != null) {
    cache.put(key,result);
  }
  return result;
}
