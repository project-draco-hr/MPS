{
  GenerationRootDependencies commonDeps=oldDependencies.getDependenciesFor(ModelDigestHelper.HEADER);
  if (commonDeps == null) {
    if (myTracer != null)     myTracer.report("Dependencies are incomplete. No info about header.");
    return;
  }
{
    String oldHash=commonDeps.getHash();
    String newHash=myGenerationHashes.get(ModelDigestHelper.HEADER);
    if (oldHash == null || newHash == null || !newHash.equals(oldHash)) {
      if (myTracer != null)       myTracer.report("Changes in model header, regenerating.");
      return;
    }
  }
{
    String oldHash=oldDependencies.getParametersHash();
    String newHash=myParametersHash;
    if (oldHash == null ? (newHash != null) : !oldHash.equals(newHash)) {
      if (myTracer != null)       myTracer.report("Changes in generation parameters, regenerating.");
      return;
    }
  }
  Set<String> changedModels=new HashSet<String>();
  Map<String,String> externalHashes=oldDependencies.getExternalHashes();
  for (  Entry<String,String> entry : externalHashes.entrySet()) {
    String modelReference=entry.getKey();
    SModelDescriptor sm=SModelRepository.getInstance().getModelDescriptor(SModelReference.fromString(modelReference));
    if (sm == null) {
      changedModels.add(modelReference);
      continue;
    }
    String oldHash=entry.getValue();
    if (oldHash == null) {
      if ((sm instanceof DefaultSModelDescriptor) && !((DefaultSModelDescriptor)sm).isReadOnly()) {
        changedModels.add(modelReference);
      }
      continue;
    }
    Map<String,String> map=myGenerationOptions.getIncrementalStrategy().getModelHashes(sm,myOperationContext);
    String newHash=map != null ? map.get(ModelDigestHelper.FILE) : null;
    if (newHash == null || !oldHash.equals(newHash)) {
      changedModels.add(modelReference);
    }
  }
  SModel smodel=myModel.getSModel();
  myRootsCount=smodel.rootsCount();
  myUnchangedRoots=new HashSet<SNode>();
  for (  SNode root : smodel.roots()) {
    String id=root.getSNodeId().toString();
    GenerationRootDependencies rd=oldDependencies.getDependenciesFor(id);
    String oldHash;
    if (rd == null || (oldHash=rd.getHash()) == null)     continue;
    String newHash=myGenerationHashes.get(id);
    if (newHash == null || !newHash.equals(oldHash))     continue;
    boolean isDirty=false;
    for (    String m : rd.getExternal()) {
      if (changedModels.contains(m)) {
        isDirty=true;
        break;
      }
    }
    if (!isDirty) {
      myUnchangedRoots.add(root);
    }
  }
  if (myUnchangedRoots.size() < myRootsCount) {
    Iterator<SNode> it=myUnchangedRoots.iterator();
    while (it.hasNext()) {
      SNode root=it.next();
      String id=root.getSNodeId().toString();
      GenerationRootDependencies rd=oldDependencies.getDependenciesFor(id);
      if (rd.isDependsOnNodes()) {
        it.remove();
      }
    }
  }
  if (myUnchangedRoots.isEmpty()) {
    if (myTracer != null)     myTracer.report("All roots are dirty.");
    return;
  }
  myConditionalsUnchanged=(myUnchangedRoots.size() == myRootsCount || !commonDeps.isDependsOnNodes());
  Map<String,Set<String>> savedDep=getDependencies(oldDependencies,myUnchangedRoots,myConditionalsUnchanged);
  ConnectedComponentPartitioner partitioner=null;
  boolean changed;
  ArrayList<SNode> roots=new ArrayList<SNode>();
  for (  SNode root : smodel.roots()) {
    roots.add(root);
  }
  if (myCache != null) {
    closureUsingSavedDependencies(savedDep);
    if (myUnchangedRoots.isEmpty() && !myConditionalsUnchanged) {
      return;
    }
    partitioner=new ConnectedComponentPartitioner(roots);
    Component[] strongComponents=partitioner.partitionStrong();
    changed=closureUsingStrongComponents(strongComponents,savedDep);
    while (changed) {
      if (myUnchangedRoots.isEmpty() && !myConditionalsUnchanged) {
        return;
      }
      changed=closureUsingSavedDependencies(savedDep);
      if (changed) {
        changed=closureUsingStrongComponents(strongComponents,savedDep);
      }
    }
    myRequiredRoots=new HashSet<SNode>(myUnchangedRoots);
    myConditionalsRequired=myConditionalsUnchanged;
  }
  addIncomingDependencies(oldDependencies,savedDep);
  closureUsingSavedDependencies(savedDep);
  if (myUnchangedRoots.isEmpty() && !myConditionalsUnchanged) {
    return;
  }
  if (partitioner == null) {
    partitioner=new ConnectedComponentPartitioner(roots);
  }
  List<SNode[]> components=partitioner.partition();
  changed=closureUsingReferences(components,savedDep);
  while (changed) {
    if (myUnchangedRoots.isEmpty() && !myConditionalsUnchanged) {
      return;
    }
    changed=closureUsingSavedDependencies(savedDep);
    if (changed) {
      changed=closureUsingReferences(components,savedDep);
    }
  }
  if (!myRequiredRoots.isEmpty()) {
    myRequiredRoots.removeAll(myUnchangedRoots);
    if (myConditionalsUnchanged) {
      myConditionalsRequired=false;
    }
  }
}
