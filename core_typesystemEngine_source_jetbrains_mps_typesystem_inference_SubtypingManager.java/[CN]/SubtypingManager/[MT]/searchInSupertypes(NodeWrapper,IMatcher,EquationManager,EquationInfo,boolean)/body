{
  if (subRepresentator == null) {
    return false;
  }
  Boolean answer=getCacheAnswer(subRepresentator,superRepresentator,isWeak);
  if (answer != null) {
    return answer;
  }
  StructuralNodeSet<?> frontier=new StructuralNodeSet();
  StructuralNodeSet<?> newFrontier=new StructuralNodeSet();
  StructuralNodeSet<?> yetPassed=new StructuralNodeSet();
  frontier.add(subRepresentator.getNode());
  while (!frontier.isEmpty()) {
    Set<SNode> yetPassedRaw=new HashSet<SNode>();
    StructuralNodeSet<?> ancestors=new StructuralNodeSet();
    for (    SNode node : frontier) {
      collectImmediateSupertypes_internal(node,isWeak,ancestors,equationManager,superRepresentator.getConceptFQName());
      yetPassedRaw.add(node);
    }
    ArrayList<SNode> ancestorsSorted;
    ancestorsSorted=new ArrayList<SNode>(ancestors);
    Collections.sort(ancestorsSorted,new Comparator<SNode>(){
      public int compare(      SNode o1,      SNode o2){
        return SNodeOperations.depth(o2) - SNodeOperations.depth(o1);
      }
    }
);
    Pair<SubtypingManager,Map<SNode,Set<SNode>>> matchParameter=new Pair<SubtypingManager,Map<SNode,Set<SNode>>>(this,new HashMap<SNode,Set<SNode>>());
    boolean wasMatch=false;
    for (    SNode ancestor : ancestorsSorted) {
      if (superRepresentator.matchesWith(NodeWrapper.createWrapperFromNode(ancestor,equationManager),equationManager,errorInfo,matchParameter)) {
        if (matchParameter.o2.keySet().isEmpty()) {
          addToCache(subRepresentator,superRepresentator,true,isWeak);
          return true;
        }
 else {
          wasMatch=true;
        }
      }
    }
    if (wasMatch) {
      Map<SNode,Set<SNode>> mapWithVars=matchParameter.o2;
      Set<Pair<SNode,SNode>> childEqs=new HashSet<Pair<SNode,SNode>>();
      for (      SNode var : mapWithVars.keySet()) {
        childEqs.add(new Pair<SNode,SNode>(var,mostSpecificTypes(mapWithVars.get(var)).iterator().next()));
      }
      if (equationManager != null) {
        equationManager.addChildEquations(childEqs,errorInfo);
      }
      return true;
    }
    for (    SNode passedNodeRaw : yetPassedRaw) {
      yetPassed.add(passedNodeRaw);
    }
    for (    SNode passedNode : yetPassed) {
      ancestors.removeStructurally(passedNode);
    }
    newFrontier.addAllStructurally(ancestors);
    yetPassed.addAllStructurally(ancestors);
    frontier=newFrontier;
    newFrontier=new StructuralNodeSet();
  }
  addToCache(subRepresentator,superRepresentator,false,isWeak);
  return false;
}
