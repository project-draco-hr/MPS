{
  if (files.isEmpty())   return Collections.emptyList();
  MergeProvider providerDecorator=new MergeProvider(){
    private File myBackup=null;
    @NotNull public MergeData loadRevisions(    VirtualFile file) throws VcsException {
      MergeData mergeData=provider.loadRevisions(file);
      if (file.getFileType().equals(MPSFileTypeFactory.MODEL_FILE_TYPE)) {
        String leftText=decodeContent(file,mergeData.CURRENT);
        String rightText=decodeContent(file,mergeData.LAST);
        String originalText=decodeContent(file,mergeData.ORIGINAL);
        DiffRequestFactory diffRequestFactory=DiffRequestFactory.getInstance();
        MergeRequest request=diffRequestFactory.createMergeRequest(leftText,rightText,originalText,file,myProject,ActionButtonPresentation.createApplyButton());
        try {
          myBackup=zipModel(mergeData,request.getContents(),file);
        }
 catch (        IOException e) {
          LOG.error(e);
        }
      }
      return mergeData;
    }
    public void conflictResolvedForFile(    VirtualFile file){
      provider.conflictResolvedForFile(file);
      if (myBackup != null && myBackup.exists()) {
        try {
          File tmp=FileUtil.createTmpDir();
          ZipUtil.extract(myBackup,tmp,null);
          FileUtil.copyFile(new File(file.getPath()),new File(tmp + File.separator + file.getName()+ ".result"));
          File logsDir=new File(PathManager.getLogPath());
          File[] logfiles=logsDir.listFiles(new FilenameFilter(){
            public boolean accept(            File dir,            String name){
              return name.matches("mpsvcs\\.log(\\.1)*") || name.matches("idea\\.log(\\.1)*");
            }
          }
);
          File tmpLogDir=new File(tmp + File.separator + "logs");
          tmpLogDir.mkdir();
          for (          File logfile : logfiles) {
            FileUtil.copyFile(logfile,new File(tmpLogDir + File.separator + logfile.getName()));
          }
          FileUtil.zip(tmp,myBackup);
          FileUtil.delete(tmp);
        }
 catch (        IOException e) {
          LOG.error(e);
        }
      }
    }
    public boolean isBinary(    VirtualFile file){
      return provider.isBinary(file);
    }
  }
;
  List<VirtualFile> toMerge=new ArrayList<VirtualFile>();
  List<VirtualFile> alreadyResolved=new ArrayList<VirtualFile>();
  for (  VirtualFile f : files) {
    if (!doStatusRecheck || VcsMigrationUtil.getHandler().isInConflict(VirtualFileUtils.toIFile(f),true)) {
      toMerge.add(f);
    }
 else {
      alreadyResolved.add(f);
    }
  }
  if (toMerge.isEmpty()) {
    MPS_LOG.debug("It seems that all files were already resolved " + alreadyResolved);
    return alreadyResolved;
  }
  MPS_LOG.debug("Showing merge for files " + toMerge);
  final MultipleFileMergeDialog fileMergeDialog=new MultipleFileMergeDialog(myProject,toMerge,providerDecorator);
  fileMergeDialog.show();
  List<VirtualFile> resolved=CollectionUtil.union(fileMergeDialog.getProcessedFiles(),alreadyResolved);
  MPS_LOG.debug("Merge finished with resolved files " + resolved);
  return resolved;
}
