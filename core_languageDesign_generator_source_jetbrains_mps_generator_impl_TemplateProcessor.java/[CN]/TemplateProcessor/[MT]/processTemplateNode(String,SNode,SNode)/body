{
  IGeneratorLogger logger=myGenerator.getLogger();
  if (myGenerator.getProgressMonitor().isCanceled()) {
    if (myGenerator.getGenerationTracer().isTracing() && logger.needsInfo()) {
      logger.info("generation canceled when processing branch:");
      GeneratorUtil.logCurrentGenerationBranch(logger,myGenerator.getGenerationTracer(),false);
    }
    throw new GenerationCanceledException();
  }
  Map<String,SNode> old=myGenerator.setPreviousInputNodesByMappingName(myInputNodesByMappingName);
  try {
    List<SNode> outputNodes=createOutputNodesForTemplateNode(mappingName,templateNode,inputNode,0);
    if (outputNodes == null) {
      throw new TemplateProcessingFailureException();
    }
    return outputNodes;
  }
 catch (  StackOverflowError e) {
    logger.error("generation thread run out of stack space :(");
    if (myGenerator.getGenerationTracer().isTracing()) {
      logger.error("failed branch was:");
      GeneratorUtil.logCurrentGenerationBranch(logger,myGenerator.getGenerationTracer(),true);
    }
 else {
      logger.error("try to increase JVM stack size (-Xss option)");
      logger.error("to get more diagnostic generate model with the 'save transient models' option");
    }
    throw new GenerationFailureException("couldn't process template",inputNode,templateNode,null,e);
  }
 finally {
    myGenerator.setPreviousInputNodesByMappingName(old);
  }
}
