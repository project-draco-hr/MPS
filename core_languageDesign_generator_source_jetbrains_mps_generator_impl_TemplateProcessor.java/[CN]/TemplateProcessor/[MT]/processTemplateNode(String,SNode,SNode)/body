{
  if (myGenerator.getProgressMonitor().isCanceled()) {
    if (myGenerator.getGenerationTracer().isTracing()) {
      myGenerator.showInformationMessage(null,"generation canceled when processing branch:");
      GeneratorUtil.logCurrentGenerationBranch(myGenerator,false);
    }
    throw new GenerationCanceledException();
  }
  Map<String,SNode> old=myGenerator.setPreviousInputNodesByMappingName(myInputNodesByMappingName);
  try {
    List<SNode> outputNodes=createOutputNodesForTemplateNode(mappingName,templateNode,inputNode,0);
    if (outputNodes == null) {
      throw new TemplateProcessingFailureException();
    }
    return outputNodes;
  }
 catch (  StackOverflowError e) {
    GeneratorLogger logger=myGenerator.getLogger();
    logger.showErrorMessage(null,"generation thread run out of stack space :(");
    if (myGenerator.getGenerationTracer().isTracing()) {
      logger.showErrorMessage(null,"failed branch was:");
      GeneratorUtil.logCurrentGenerationBranch(myGenerator,true);
    }
 else {
      logger.showErrorMessage(null,"try to increase JVM stack size (-Xss option)");
      logger.showErrorMessage(null,"to get more diagnostic generate model with the 'save transient models' option");
    }
    throw new GenerationFailureException("couldn't process template",inputNode,templateNode,null,e);
  }
 finally {
    myGenerator.setPreviousInputNodesByMappingName(old);
  }
}
