{
  if (generator.getProgressMonitor().isCanceled()) {
    if (generator.getGenerationTracer().isTracing()) {
      LOG.info("generation canceled when processing branch:");
      logCurrentGenerationBranch(generator,false);
    }
    throw new GenerationCanceledException();
  }
  TemplateProcessor templateProcessor=new TemplateProcessor(generator);
  Map<String,SNode> old=generator.setPreviousInputNodesByMappingName(templateProcessor.myInputNodesByMappingName);
  try {
    List<SNode> outputNodes=templateProcessor.createOutputNodesForTemplateNode(mappingName,templateNode,inputNode,0);
    if (outputNodes == null) {
      throw new TemplateProcessingFailureException();
    }
    return outputNodes;
  }
 catch (  StackOverflowError e) {
    LOG.error("generation thread run out of stack space :(");
    if (generator.getGenerationTracer().isTracing()) {
      LOG.error("failed branch was:");
      logCurrentGenerationBranch(generator,true);
    }
 else {
      LOG.error("try to increase JVM stack size (-Xss option)");
      LOG.error("to get more diagnostic generate model with the 'save transient models' option");
    }
    throw new GenerationFailureException("couldn't process template",inputNode,templateNode,null,e);
  }
 finally {
    generator.setPreviousInputNodesByMappingName(old);
  }
}
