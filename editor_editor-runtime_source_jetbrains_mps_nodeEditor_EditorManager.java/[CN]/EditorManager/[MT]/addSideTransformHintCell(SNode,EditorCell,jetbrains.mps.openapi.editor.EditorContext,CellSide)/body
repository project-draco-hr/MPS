{
  final EditorCell_STHint sideTransformHintCell=new EditorCell_STHint(context,node,side);
  final CellInfo nodeCellInfo=getEditorComponent(context).getRecentlySelectedCellInfo();
  sideTransformHintCell.setAction(jetbrains.mps.openapi.editor.cells.CellActionType.DELETE,new AbstractCellAction(){
    @Override public void execute(    final jetbrains.mps.openapi.editor.EditorContext context){
      removeSTHintAndChangeSelection(context,node,nodeCellInfo);
    }
  }
);
  sideTransformHintCell.setAction(jetbrains.mps.openapi.editor.cells.CellActionType.RIGHT_TRANSFORM,new AbstractCellAction(){
    @Override public void execute(    jetbrains.mps.openapi.editor.EditorContext context){
      removeSTHintAndChangeSelection(context,node,nodeCellInfo);
    }
  }
);
  sideTransformHintCell.setAction(jetbrains.mps.openapi.editor.cells.CellActionType.LEFT_TRANSFORM,new AbstractCellAction(){
    @Override public void execute(    jetbrains.mps.openapi.editor.EditorContext context){
      removeSTHintAndChangeSelection(context,node,nodeCellInfo);
    }
  }
);
  KeyMap keyMap=new KeyMapImpl();
  keyMap.putAction(KeyMap.KEY_MODIFIERS_NONE,"VK_ESCAPE",new KeyMapActionImpl(){
    @Override public void execute(    jetbrains.mps.openapi.editor.EditorContext context){
      removeSTHintAndChangeSelection(context,node,nodeCellInfo);
    }
  }
);
  sideTransformHintCell.addKeyMap(keyMap);
  final String transformTag=(String)node.getUserObject(SIDE_TRANSFORM_HINT_ANCHOR_TAG);
  sideTransformHintCell.setSubstituteInfo(new AbstractNodeSubstituteInfo(context){
    @Override protected List<SubstituteAction> createActions(){
      List<SubstituteAction> list=ModelActions.createSideTransformHintSubstituteActions(node,side,transformTag,context.getOperationContext());
      List<SubstituteAction> wrapperList=new ArrayList<SubstituteAction>(list.size());
      for (      final SubstituteAction action : list) {
        wrapperList.add(new NodeSubstituteActionWrapper(action){
          @Override public SNode substitute(          @Nullable jetbrains.mps.openapi.editor.EditorContext context,          String pattern){
            ModelAccess.instance().runWriteActionInCommand(new Runnable(){
              @Override public void run(){
                SNodeEditorUtil.removeRightTransformHint(node);
                SNodeEditorUtil.removeLeftTransformHint(node);
              }
            }
);
            return super.substitute(context,pattern);
          }
          public String toString(){
            return "RTWrapper for " + action + "("+ action.getClass()+ ")";
          }
        }
);
      }
      return wrapperList;
    }
  }
);
  EditorCell resultCell;
  Object anchorId=node.getUserObject(SIDE_TRANSFORM_HINT_ANCHOR_CELL_ID);
  EditorCell anchorCell=anchorId == null ? null : CellFinders.byId(node,anchorId.toString()).find(nodeCell,true);
  if (anchorCell != null && anchorCell != nodeCell) {
    jetbrains.mps.openapi.editor.cells.EditorCell_Collection cellCollection=anchorCell.getParent();
    int index;
    if (side == CellSide.RIGHT) {
      index=cellCollection.indexOf(anchorCell) + 1;
    }
 else {
      index=cellCollection.indexOf(anchorCell);
    }
    cellCollection.addEditorCellAt(index,sideTransformHintCell,false);
    resultCell=nodeCell;
    sideTransformHintCell.setAnchor(anchorCell);
  }
 else {
    EditorCell_Collection rowWrapper=EditorCell_Collection.createHorizontal(context,node);
    rowWrapper.setSelectable(false);
    rowWrapper.addEditorCell(nodeCell);
    if (side == CellSide.RIGHT) {
      rowWrapper.addEditorCell(sideTransformHintCell);
    }
 else {
      rowWrapper.addEditorCellAt(0,sideTransformHintCell,false);
    }
    resultCell=rowWrapper;
    sideTransformHintCell.setAnchor(nodeCell);
  }
  return resultCell;
}
