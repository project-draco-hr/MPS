{
  List<IFile> filesToDelete=ListSequence.fromList(new ArrayList<IFile>());
  Queue<IFile> dirQueue=QueueSequence.fromQueueAndArray(new LinkedList<IFile>(),rootDir);
  while (QueueSequence.fromQueue(dirQueue).isNotEmpty()) {
    IFile dir=QueueSequence.fromQueue(dirQueue).removeFirstElement();
    String dirpath=DirUtil.normalizeAsDir(dir.getPath());
    int diridx=Arrays.binarySearch(pathsToKeep,dirpath);
    for (    Tuples._2<IFile,String> fileAndPath : Sequence.fromIterable(getChildren(dir)).select(new ISelector<IFile,Tuples._2<IFile,String>>(){
      public Tuples._2<IFile,String> select(      IFile f){
        return MultiTuple.<IFile,String>from(f,DirUtil.normalize(f.getPath()));
      }
    }
).sort(new ISelector<Tuples._2<IFile,String>,String>(){
      public String select(      Tuples._2<IFile,String> t){
        return t._1();
      }
    }
,true)) {
      if (fileAndPath._0().isDirectory()) {
        int fidx=Arrays.binarySearch(pathsToKeep,DirUtil.normalizeAsDir(fileAndPath._1()));
        fidx=(fidx < 0 ? -1 - fidx : fidx);
        if (fidx >= pathsToKeep.length || !(DirUtil.startsWith(pathsToKeep[fidx],fileAndPath._1()))) {
          ListSequence.fromList(filesToDelete).addElement(fileAndPath._0());
          if (fidx >= pathsToKeep.length) {
            break;
          }
        }
 else         if (fidx < pathsToKeep.length) {
          QueueSequence.fromQueue(dirQueue).addLastElement(fileAndPath._0());
        }
      }
 else {
        int fidx=Arrays.binarySearch(pathsToKeep,fileAndPath._1());
        if (fidx < 0 && diridx < 0) {
          ListSequence.fromList(filesToDelete).addElement(fileAndPath._0());
        }
      }
    }
  }
  return filesToDelete;
}
