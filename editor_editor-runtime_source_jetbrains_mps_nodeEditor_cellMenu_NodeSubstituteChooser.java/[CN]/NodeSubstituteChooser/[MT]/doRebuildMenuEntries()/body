{
  myMenuEmpty=false;
  final String pattern=getPatternEditor().getPattern();
  List<SubstituteAction> matchingActions=getMatchingActions(pattern,false);
  boolean needToTrim=true;
  if (!matchingActions.isEmpty()) {
    for (    SubstituteAction action : matchingActions) {
      if (action.canSubstitute(pattern)) {
        needToTrim=false;
        break;
      }
    }
  }
  String patternToFind=pattern;
  if (needToTrim) {
    patternToFind=IntelligentInputUtil.trimLeft(pattern);
    matchingActions=getMatchingActions(patternToFind,false);
  }
  try {
    Collections.sort(matchingActions,SubstituteActionUtil.createComparator(patternToFind));
    if (myIsSmart) {
      sortSmartActions(matchingActions);
    }
  }
 catch (  Exception e) {
    LOG.error(e,e);
  }
  mySubstituteActions=matchingActions;
  if (mySubstituteActions.size() == 0) {
    myMenuEmpty=true;
    mySubstituteActions.add(new AbstractNodeSubstituteAction(){
      @Override public String getMatchingText(      String pattern){
        return "No variants for \"" + getPatternEditor().getPattern() + "\"";
      }
      @Override public String getVisibleMatchingText(      String pattern){
        return getMatchingText(pattern);
      }
      @Override public SNode doSubstitute(      @Nullable final jetbrains.mps.openapi.editor.EditorContext editorContext,      String pattern){
        return null;
      }
    }
);
  }
  int textLength=0;
  int descriptionLength=0;
  for (  SubstituteAction item : mySubstituteActions) {
    try {
      textLength=Math.max(textLength,getTextLength(item,pattern));
      descriptionLength=Math.max(descriptionLength,getDescriptionLength(item,pattern));
    }
 catch (    Throwable t) {
      LOG.error(t,t);
    }
  }
}
