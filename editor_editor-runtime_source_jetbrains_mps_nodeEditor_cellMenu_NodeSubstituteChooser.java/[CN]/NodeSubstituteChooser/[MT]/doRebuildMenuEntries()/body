{
  myMenuEmpty=false;
  final String pattern=getPatternEditor().getPattern();
  List<SubstituteAction> matchingActions=getMatchingActions(pattern,false);
  boolean needToTrim;
  String trimPattern=IntelligentInputUtil.trimLeft(pattern);
  if (pattern.equals(trimPattern)) {
    needToTrim=false;
  }
 else {
    needToTrim=true;
    if (!matchingActions.isEmpty()) {
      for (      SubstituteAction action : matchingActions) {
        if (action.canSubstitute(pattern)) {
          needToTrim=false;
          break;
        }
      }
    }
  }
  if (needToTrim) {
    matchingActions=getMatchingActions(trimPattern,false);
  }
  try {
    if (myIsSmart) {
      sortSmartActions(matchingActions);
    }
 else {
      Collections.sort(matchingActions,SubstituteActionUtil.createComparator(needToTrim ? trimPattern : pattern));
    }
  }
 catch (  Exception e) {
    LOG.error(e,e);
  }
  mySubstituteActions=matchingActions;
  if (mySubstituteActions.size() == 0) {
    myMenuEmpty=true;
    mySubstituteActions.add(new AbstractNodeSubstituteAction(){
      @Override public String getMatchingText(      String pattern){
        return "No suggestions for \"" + getPatternEditor().getPattern() + "\"";
      }
      @Override public String getVisibleMatchingText(      String pattern){
        return getMatchingText(pattern);
      }
      @Override public SNode doSubstitute(      @Nullable final jetbrains.mps.openapi.editor.EditorContext editorContext,      String pattern){
        return null;
      }
    }
);
  }
  myPopupWindow.resetMaxSize();
  for (  SubstituteAction item : mySubstituteActions) {
    Dimension dimension=getCellRenderer().getMax(item);
    myPopupWindow.updateMaxHeight(dimension.height);
    myPopupWindow.updateMaxWidth(dimension.width);
  }
}
