{
  final ITypeContextOwner contextOwner=myIsSmart ? new NonReusableTypecheckingContextOwner() : myEditorComponent.getTypecheckingContextOwner();
  return TypeContextManager.getInstance().runTypeCheckingComputation(contextOwner,myEditorComponent.getEditedNode(),new Computation<List<SubstituteAction>>(){
    @Override public List<SubstituteAction> compute(    TypeCheckingContext context){
      if (myIsSmart) {
        return myNodeSubstituteInfo.getSmartMatchingActions(pattern,strictMatching,myContextCell);
      }
 else {
        return myNodeSubstituteInfo.getMatchingActions(pattern,strictMatching);
      }
    }
  }
);
}
