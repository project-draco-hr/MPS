{
  Map<String,List<String>> generatedFiles=getGeneratedFiles(currentToOriginalMap);
  List<GenerationRootDependencies> unchanged=null;
  List<GenerationRootDependencies> rootDependencies=new ArrayList<GenerationRootDependencies>(roots.length);
  Map<String,String> externalHashes=new HashMap<String,String>();
  for (  RootDependenciesBuilder l : roots) {
    SNode originalRoot=l.getOriginalRoot();
    List<String> files=generatedFiles.get(originalRoot != null ? originalRoot.getNodeId().toString() : "");
    if (files == null) {
      files=Collections.emptyList();
    }
    GenerationRootDependencies dep;
    if (l.isUnchanged()) {
      dep=l.getSavedDependencies();
      if (unchanged == null) {
        unchanged=new ArrayList<GenerationRootDependencies>();
      }
      unchanged.add(dep);
    }
 else {
      dep=GenerationRootDependencies.fromData(l,files);
    }
    rootDependencies.add(dep);
    for (    String modelReference : dep.getExternal()) {
      if (!externalHashes.containsKey(modelReference)) {
        SModelDescriptor sm=SModelRepository.getInstance().getModelDescriptor(SModelReference.fromString(modelReference));
        Map<String,String> hashes=incrementalStrategy.getModelHashes(sm,operationContext);
        String value=hashes != null ? hashes.get(GeneratableSModel.FILE) : null;
        externalHashes.put(modelReference,value);
      }
    }
  }
  return new GenerationDependencies(rootDependencies,modelHash,parametersHash,externalHashes,unchanged == null ? Collections.<GenerationRootDependencies>emptyList() : unchanged,skippedCount,fromCacheCount,dependenciesTraces);
}
