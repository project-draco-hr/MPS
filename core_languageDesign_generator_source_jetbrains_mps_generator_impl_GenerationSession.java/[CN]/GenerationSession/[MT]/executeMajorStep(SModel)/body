{
  myTransientModelsCount=0;
  info("generating model \"" + inputModel.getSModelFqName() + "\"");
  if (myGenerationPlan.getMappingConfigurations(myMajorStep).isEmpty()) {
    warning("skip model \"" + inputModel.getSModelFqName() + "\" : no generator available");
    return new GenerationStatus(inputModel,null,null,false,false,false);
  }
  printGenerationStepData(inputModel);
  mySessionContext=new GenerationSessionContext(myInvocationContext,inputModel,myGenerationPlan,mySessionContext);
  GeneratorLogger logger=new GeneratorLogger(mySessionContext);
  RuleManager ruleManager=new RuleManager(myGenerationPlan,myMajorStep);
  GenerationStatus status;
  try {
    SModel outputModel=executeMacroStepInternal(inputModel,logger,ruleManager);
    boolean wasErrors=logger.getErrorCount() > 0;
    boolean wasWarnigns=logger.getWarningCount() > 0;
    status=new GenerationStatus(inputModel,outputModel,mySessionContext.getTraceMap(),wasErrors,wasWarnigns,false);
    if (status.isError()) {
      warning("model \"" + inputModel.getSModelFqName() + "\" has been generated with errors");
    }
 else {
      info("model \"" + inputModel.getSModelFqName() + "\" has been generated successfully");
    }
  }
 catch (  GenerationCanceledException gce) {
    throw gce;
  }
catch (  GenerationFailureException gfe) {
    LOG.error(gfe.getMessage());
    error("model \"" + inputModel.getSModelFqName() + "\" generation failed : "+ gfe);
    status=new GenerationStatus.ERROR(inputModel);
  }
catch (  Throwable e) {
    LOG.error(e);
    error("model \"" + inputModel.getSModelFqName() + "\" generation failed : "+ e);
    status=new GenerationStatus.ERROR(inputModel);
  }
  return status;
}
