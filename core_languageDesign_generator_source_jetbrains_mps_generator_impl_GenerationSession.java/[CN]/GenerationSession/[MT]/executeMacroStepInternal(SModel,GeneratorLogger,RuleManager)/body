{
  SModel currentInputModel=inputModel;
  IGenerationTracer tracer=mySessionContext.getGenerationTracer();
  if (myReverseRoots && inputModel == mySessionContext.getOriginalInputModel()) {
    SModel currentInputModel_clone=createTransientModel();
    info("reversing roots '" + currentInputModel.getSModelFqName() + "' --> '"+ currentInputModel_clone.getSModelFqName()+ "'");
    List<SNode> rrr=currentInputModel.getRoots();
    SNode[] roots=rrr.toArray(new SNode[rrr.size()]);
    for (int i=0; i < roots.length / 2; i++) {
      SNode temp=roots[i];
      roots[i]=roots[roots.length - 1 - i];
      roots[roots.length - 1 - i]=temp;
    }
    for (    SNode node : roots) {
      SNode outputNode=CloneUtil.clone(node,currentInputModel_clone,true);
      currentInputModel_clone.addRoot(outputNode);
    }
    recycleWasteModel(currentInputModel);
    currentInputModel=currentInputModel_clone;
  }
  currentInputModel=preProcessModel(logger,ruleManager,currentInputModel);
  SModel currentOutputModel=createTransientModel();
  tracer.startTracing(currentInputModel,currentOutputModel);
  currentInputModel.setLoading(false);
  boolean somethingHasBeenGenerated=applyRules(currentInputModel,currentOutputModel,true,ruleManager,logger);
  if (!somethingHasBeenGenerated) {
    currentOutputModel.validateLanguagesAndImports();
    recycleWasteModel(currentInputModel);
    return currentOutputModel;
  }
  int secondaryMappingRepeatCount=1;
  while (true) {
    currentOutputModel.validateLanguagesAndImports();
    info("generating model '" + currentOutputModel.getSModelFqName() + "'");
    mySessionContext.clearTransientObjects();
    SModel transientModel=createTransientModel();
    recycleWasteModel(currentInputModel);
    currentInputModel=currentOutputModel;
    currentInputModel.setLoading(false);
    tracer.startTracing(currentInputModel,transientModel);
    if (!applyRules(currentInputModel,transientModel,false,ruleManager,logger)) {
      tracer.discardTracing(currentInputModel,transientModel);
      info("remove empty model '" + transientModel.getSModelFqName() + "'");
      SModelRepository.getInstance().removeModelDescriptor(transientModel.getModelDescriptor());
      myTransientModelsCount--;
      break;
    }
    if (++secondaryMappingRepeatCount > 10) {
      logger.showErrorMessage(null,"failed to generate output after 10 repeated mappings");
      if (tracer.isTracing()) {
        logger.showErrorMessage(null,"last rules applied:");
        List<Pair<SNode,SNode>> pairs=tracer.getAllAppiedRulesWithInputNodes(transientModel.getSModelReference());
        for (        Pair<SNode,SNode> pair : pairs) {
          logger.showErrorMessage(pair.o1,"rule: " + pair.o1.getDebugText());
          logger.showErrorMessage(pair.o2,"-- input: " + (pair.o2 != null ? pair.o2.getDebugText() : "n/a"));
        }
      }
 else {
        logger.showErrorMessage(null,"to get more diagnostic generate model with the 'save transient models' option");
      }
      throw new GenerationFailureException("failed to generate output after 10 repeated mappings");
    }
    currentOutputModel=transientModel;
  }
  currentOutputModel.setLoading(true);
  currentOutputModel=postProcessModel(logger,ruleManager,currentOutputModel);
  return currentOutputModel;
}
