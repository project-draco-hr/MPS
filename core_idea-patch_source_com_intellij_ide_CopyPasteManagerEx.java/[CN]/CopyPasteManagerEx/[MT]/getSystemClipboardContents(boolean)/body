{
  final Transferable[] contents=new Transferable[]{null};
  final boolean[] success=new boolean[]{false};
  Runnable accessor=new Runnable(){
    public void run(){
      try {
        for (int i=0; i < 3; i++) {
          try {
            contents[0]=Toolkit.getDefaultToolkit().getSystemClipboard().getContents(CopyPasteManagerEx.this);
          }
 catch (          IllegalStateException e) {
            try {
              Thread.sleep(50);
            }
 catch (            InterruptedException e1) {
            }
            continue;
          }
          break;
        }
        success[0]=true;
      }
 catch (      Throwable e) {
        LOG.info(e);
      }
 finally {
        Thread.interrupted();
      }
    }
  }
;
  if (Patches.SUN_BUG_ID_4818143) {
    final Future<?> accessorFuture=ApplicationManager.getApplication().executeOnPooledThread(accessor);
    long start=System.currentTimeMillis();
    try {
      int delay=DELAY_UNTIL_ABORT_CLIPBOARD_ACCESS;
      if (myBugHappened) {
        delay=myMaxNormalTiming;
      }
      accessorFuture.get(delay,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
    }
catch (    TimeoutException e) {
    }
catch (    ExecutionException e) {
      LOG.error(e);
    }
    if (success[0]) {
      long timing=System.currentTimeMillis() - start;
      if (timing < MAX_NORMAL_CLIPBOARD_ACCESS_DELAY) {
        myMaxNormalTiming=(int)Math.max(myMaxNormalTiming,timing);
      }
      myBugHappened=false;
      return contents[0];
    }
    accessorFuture.cancel(true);
    myBugHappened=true;
    if (showMessage) {
      showWorkaroundMessage();
    }
 else {
      LOG.warn("Can't access to SystemClipboard");
    }
    return null;
  }
 else {
    accessor.run();
    return contents[0];
  }
}
