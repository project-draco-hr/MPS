{
  return runUpdateMessagesAction(new Computable<Boolean>(){
    @Override public Boolean compute(){
      boolean needsUpdate=ModelAccess.instance().runReadAction(new Computable<Boolean>(){
        @Override public Boolean compute(){
          final SNode editedNode=component.getEditedNode();
          return editedNode != null && SNodeUtil.isAccessible(editedNode,MPSModuleRepository.getInstance());
        }
      }
);
      if (!needsUpdate)       return false;
      final Set<BaseEditorChecker> checkersToRecheck=new LinkedHashSet<BaseEditorChecker>();
      boolean rootWasCheckedOnce=wasCheckedOnce(component);
      if (!rootWasCheckedOnce) {
        checkersToRecheck.addAll(checkers);
      }
 else {
        ModelAccess.instance().runReadAction(new Runnable(){
          @Override public void run(){
            if (myStopThread || myCancellable.isCancelled())             return;
            for (            BaseEditorChecker checker : checkers) {
              if (checker.hasDramaticalEventProtected(events) && (!essentialOnly || checker.isEssentialProtected())) {
                checkersToRecheck.add(checker);
              }
            }
          }
        }
);
      }
      if ((checkersToRecheck.isEmpty() && checkersToRemove.isEmpty()) || myStopThread || myCancellable.isCancelled())       return false;
      List<BaseEditorChecker> checkersToRecheckList=new ArrayList<BaseEditorChecker>(checkersToRecheck);
      Collections.sort(checkersToRecheckList,new PriorityComparator());
      boolean recreateInspectorMessages=mainEditorMessagesChanged || !myInspectorMessagesCreated;
      if (component instanceof InspectorEditorComponent) {
        myInspectorMessagesCreated=true;
      }
 else {
        myCheckedOnceEditors.add(component);
      }
      return updateEditor(component,events,rootWasCheckedOnce,checkersToRecheckList,checkersToRemove,recreateInspectorMessages,applyQuickFixes);
    }
  }
);
}
