{
  final Map<SNode,SNode> nodesAndTypes=new HashMap<SNode,SNode>();
  int i=1;
  Boolean good=true;
  for (boolean mostSpecific=false; i <= 2; mostSpecific=!(mostSpecific), i++) {
    int indexOfArg=0;
    for (    Expression actualArg : actualArgs) {
      final TypeCheckingContext typeCheckingContext=TypeContextManager.getInstance().createTypeCheckingContext(actualArg.getNode());
      final SNode term=actualArg.getNode();
      SNode typeOfArg;
      if (nodesAndTypes.containsKey(term)) {
        typeOfArg=nodesAndTypes.get(term);
      }
 else {
        if (typeCheckingContext == null) {
          typeOfArg=null;
        }
 else {
          typeOfArg=typeCheckingContext.runTypeCheckingActionInEditorQueries(new Computable<SNode>(){
            @Override public SNode compute(){
              return typeCheckingContext.getTypeOf(term,TypeChecker.getInstance());
            }
          }
);
          nodesAndTypes.put(term,typeOfArg);
        }
      }
      List<? extends BaseMethodDeclaration> candidates1=MethodResolveUtil.selectByParameterType(typeOfArg,indexOfArg,candidates,typeByTypeVar,mostSpecific);
      if (candidates1.isEmpty()) {
        good=false;
        break;
      }
      if (candidates1.size() == 1) {
        return new Pair<BaseMethodDeclaration,Boolean>(candidates1.get(0),good);
      }
      candidates=candidates1;
      indexOfArg++;
    }
  }
  return new Pair<BaseMethodDeclaration,Boolean>(candidates.get(0),good);
}
