{
  Map<SNode,SNode> nodesAndTypes=new HashMap<SNode,SNode>();
  int i=1;
  Boolean good=true;
  for (boolean mostSpecific=false; i <= 2; mostSpecific=!(mostSpecific), i++) {
    int indexOfArg=0;
    for (    Expression actualArg : actualArgs) {
      TypeCheckingContext typeCheckingContext=TypeContextManager.getInstance().createTypeCheckingContext(actualArg.getNode());
      SNode term=actualArg.getNode();
      SNode typeOfArg;
      if (nodesAndTypes.containsKey(term)) {
        typeOfArg=nodesAndTypes.get(term);
      }
 else {
        if (typeCheckingContext == null) {
          typeOfArg=null;
        }
 else {
          typeCheckingContext.setInEditorQueriesMode();
          typeOfArg=typeCheckingContext.getTypeOf(term,TypeChecker.getInstance());
          nodesAndTypes.put(term,typeOfArg);
          typeCheckingContext.resetIsInEditorQueriesMode();
        }
      }
      List<? extends BaseMethodDeclaration> candidates1=MethodResolveUtil.selectByParameterType(typeOfArg,indexOfArg,candidates,typeByTypeVar,mostSpecific);
      if (candidates1.isEmpty()) {
        good=false;
        break;
      }
      if (candidates1.size() == 1) {
        return new Pair<BaseMethodDeclaration,Boolean>(candidates1.get(0),good);
      }
      candidates=candidates1;
      indexOfArg++;
    }
  }
  return new Pair<BaseMethodDeclaration,Boolean>(candidates.get(0),good);
}
