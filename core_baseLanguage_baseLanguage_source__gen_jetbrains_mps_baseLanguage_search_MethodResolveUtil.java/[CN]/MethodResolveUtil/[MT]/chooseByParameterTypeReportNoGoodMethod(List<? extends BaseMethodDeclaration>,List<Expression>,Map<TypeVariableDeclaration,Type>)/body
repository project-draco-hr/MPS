{
  Map<SNode,SNode> nodesAndTypes=new HashMap<SNode,SNode>();
  int i=1;
  Boolean good=true;
  for (boolean mostSpecific=false; i <= 2; mostSpecific=!(mostSpecific), i++) {
    int indexOfArg=0;
    for (    Expression actualArg : actualArgs) {
      final SNode term=actualArg.getNode();
      SNode typeOfArg;
      if (nodesAndTypes.containsKey(term)) {
        typeOfArg=nodesAndTypes.get(term);
      }
 else {
        final TypeCheckingContext typeCheckingContext=TypeContextManager.getInstance().createTypeCheckingContextForResolve(actualArg.getNode());
        typeOfArg=typeCheckingContext.runTypeCheckingAction(new Computable<SNode>(){
          public SNode compute(){
            return typeCheckingContext.getTypeOf(term,TypeChecker.getInstance());
          }
        }
);
        typeCheckingContext.dispose();
        nodesAndTypes.put(term,typeOfArg);
      }
      List<? extends BaseMethodDeclaration> candidates1=MethodResolveUtil.selectByParameterType(typeOfArg,indexOfArg,candidates,typeByTypeVar,mostSpecific);
      if (candidates1.isEmpty()) {
        good=false;
        break;
      }
      if (candidates1.size() == 1) {
        return new Pair<BaseMethodDeclaration,Boolean>(candidates1.get(0),good);
      }
      candidates=candidates1;
      indexOfArg++;
    }
  }
  return new Pair<BaseMethodDeclaration,Boolean>(candidates.get(0),good);
}
