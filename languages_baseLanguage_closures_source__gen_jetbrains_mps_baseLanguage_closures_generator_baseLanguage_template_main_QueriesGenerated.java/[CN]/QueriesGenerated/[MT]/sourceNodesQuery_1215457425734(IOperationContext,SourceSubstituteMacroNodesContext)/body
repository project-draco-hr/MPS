{
  List<SNode> paramDecls=SLinkOperations.getTargets(_context.getNode(),"parameter",true);
  SNode literal=_context.getNode();
  SNode ct=(SNode)Values.LITERAL_TARGET.get(_context,literal);
  if (ct != null) {
    Iterable<SNode> imds=Classifier_Behavior.call_methods_5292274854859311639(SLinkOperations.getTarget(ct,"classifier",false));
    if (Sequence.fromIterable(imds).isNotEmpty()) {
      SNode imd=Sequence.fromIterable(imds).first();
      List<SNode> res=ListSequence.fromList(new ArrayList<SNode>());
      int idx=0;
      for (      SNode pd : SLinkOperations.getTargets(imd,"parameter",true)) {
        if (idx >= ListSequence.fromList(paramDecls).count()) {
          _context.showErrorMessage(_context.getNode(),"Method parameters count doesn't match closure parameters count: " + SPropertyOperations.getString(imd,"shortDescription"));
          break;
        }
        SNode newpd=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParameterDeclaration",null);
        SLinkOperations.setTarget(newpd,"type",FunctionTypeUtil.unmeet(FunctionTypeUtil.unbound(ClassifierTypeUtil.resolveType(SLinkOperations.getTarget(pd,"type",true),ct))),true);
        SPropertyOperations.set(newpd,"name",SPropertyOperations.getString(ListSequence.fromList(paramDecls).getElement(idx),"name"));
        SPropertyOperations.set(newpd,"isFinal","" + (SPropertyOperations.getBoolean(ListSequence.fromList(paramDecls).getElement(idx),"isFinal")));
        idx++;
        ListSequence.fromList(res).addElement(newpd);
      }
      return res;
    }
  }
  return ListSequence.fromList(new ArrayList<SNode>());
}
