{
  NonCancelableSection section=ProgressIndicatorProvider.startNonCancelableSectionIfSupported();
  try {
    for (    PsiJavaFile jf : myDataSource.getJavaFiles()) {
      SNode javaImports=getImports(jf.getImportList().getAllImportStatements());
      ASTConverter converter=new ASTConverter(myMps2PsiMapper);
      Set<SNodeId> roots=SetSequence.fromSet(new HashSet<SNodeId>());
      for (      PsiClass cls : jf.getClasses()) {
        SNode node=converter.convertClass(cls);
        if (SNodeOperations.isInstanceOf(node,MetaAdapterFactory.getConcept(new UUID(-935030926396207931l,-6610165693999523818l),1107461130800l,"jetbrains.mps.baseLanguage.structure.Classifier"))) {
          AttributeOperations.setAttribute(SNodeOperations.cast(node,MetaAdapterFactory.getConcept(new UUID(-935030926396207931l,-6610165693999523818l),1107461130800l,"jetbrains.mps.baseLanguage.structure.Classifier")),new IAttributeDescriptor.NodeAttribute("jetbrains.mps.baseLanguage.structure.JavaImports"),javaImports);
        }
        into.addRootNode(node);
        SetSequence.fromSet(roots).addElement(node.getNodeId());
      }
      if (SetSequence.fromSet(roots).isNotEmpty()) {
        MapSequence.fromMap(myRootsPerFile).put(jf.getName(),roots);
      }
    }
  }
 catch (  Exception e) {
    LOG.error("could not build stub model for code PSI: you may not be able to reference java code from MPS",e);
  }
 finally {
    section.done();
  }
}
