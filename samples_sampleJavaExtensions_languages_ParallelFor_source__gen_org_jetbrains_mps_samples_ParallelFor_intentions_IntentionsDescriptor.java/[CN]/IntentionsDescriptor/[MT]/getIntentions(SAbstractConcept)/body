{
  if (myCached.containsKey(concept)) {
    return Arrays.asList(myCached.get(concept));
  }
  IntentionFactory[] intentions=EMPTY_ARRAY;
{
    SAbstractConcept cncpt=concept;
switch (index_hphjzv_d0f.index(cncpt)) {
case 0:
      if (true) {
        intentions=new IntentionFactory[4];
        intentions[0]=new MarkAsThreadSafe_Intention();
        intentions[1]=new UnmarkAsThreadSafe_Intention();
        intentions[2]=new MarkAsNonThreadSafe_Intention();
        intentions[3]=new UnmarkAsNonThreadSafe_Intention();
      }
    break;
case 1:
  if (true) {
    intentions=new IntentionFactory[2];
    intentions[0]=new MarkInstanceMethodCallAsThreadSafe_Intention();
    intentions[1]=new UnmarkInstanceMethodCallAsThreadSafe_Intention();
  }
break;
case 2:
if (true) {
intentions=new IntentionFactory[1];
intentions[0]=new TurnToParallelForEachStatement_Intention();
}
break;
case 3:
if (true) {
intentions=new IntentionFactory[4];
intentions[0]=new MarkLocalStaticMethodCallAsThreadSafe_Intention();
intentions[1]=new UnmarkLocalStaticMethodCallAsThreadSafe_Intention();
intentions[2]=new UnmarkLocalInstanceMethodCallAsThreadSafe_Intention();
intentions[3]=new MarkLocalInstanceMethodCallAsThreadSafe_Intention();
}
break;
case 4:
if (true) {
intentions=new IntentionFactory[2];
intentions[0]=new DetachFromThreadPool_Intention();
intentions[1]=new TurnToForEachStatement_Intention();
}
break;
case 5:
if (true) {
intentions=new IntentionFactory[2];
intentions[0]=new MarkStaticMethodCallAsThreadSafe_Intention();
intentions[1]=new UnmarkStaticMethodCallAsThreadSafe_Intention();
}
break;
case 6:
if (true) {
intentions=new IntentionFactory[2];
intentions[0]=new MarkVariableDeclarationAsThreadSafe_Intention();
intentions[1]=new UnmarkVariableAsThreadSafe_Intention();
}
break;
default :
}
}
myCached.put(concept,intentions);
return Arrays.asList(intentions);
}
