{
  StructuralNodeSet result=new StructuralNodeSet();
  if (MatchingUtil.matchNodes(a,b)) {
    result.add(a);
    return result;
  }
  if (collectBottoms(a,true).contains(b)) {
    result.add(a);
    return result;
  }
  if (collectBottoms(b,true).contains(a)) {
    result.add(b);
    return result;
  }
  StructuralNodeSet<?> superTypesA=subTypesToSuperTypes.get(a) != null ? new StructuralNodeSet(subTypesToSuperTypes.get(a)) : new StructuralNodeSet();
  superTypesA.add(a);
  StructuralNodeSet<?> superTypesB=subTypesToSuperTypes.get(b) != null ? new StructuralNodeSet(subTypesToSuperTypes.get(b)) : new StructuralNodeSet();
  superTypesB.add(b);
  for (  SNode superTypeA : new HashSet<SNode>(superTypesA)) {
    boolean matches=false;
    for (    SNode superTypeB : superTypesB) {
      if (MatchingUtil.matchNodes(superTypeA,superTypeB)) {
        matches=true;
        break;
      }
    }
    if (!matches) {
      superTypesA.remove(superTypeA);
    }
  }
  StructuralNodeSet commonSupertypes=superTypesA;
  List<SNode> commonSupertypesSorted=new ArrayList<SNode>(commonSupertypes);
  Collections.sort(commonSupertypesSorted,new Comparator<SNode>(){
    public int compare(    SNode o1,    SNode o2){
      Integer distA1=subTypesToSuperTypes.get(a).getTag(o1);
      Integer distA2=subTypesToSuperTypes.get(a).getTag(o2);
      Integer distB1=subTypesToSuperTypes.get(b).getTag(o1);
      Integer distB2=subTypesToSuperTypes.get(b).getTag(o2);
      return (distA1 + distB1) - (distA2 + distB2);
    }
  }
);
  for (  SNode commonSupertype : commonSupertypesSorted) {
    if (!commonSupertypes.contains(commonSupertype)) {
      continue;
    }
    Set<SNode> superTypes=subTypesToSuperTypes.get(commonSupertype);
    if (superTypes != null) {
      for (      SNode superType : superTypes) {
        if (!MatchingUtil.matchNodes(superType,commonSupertype)) {
          commonSupertypes.removeStructurally(superType);
        }
      }
    }
  }
  return commonSupertypes;
}
