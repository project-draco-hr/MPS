{
  SNode subRepresentator=myTypeChecker.getEquationManager().getRepresentator(subtype);
  SNode superRepresentator=myTypeChecker.getEquationManager().getRepresentator(supertype);
  Set<ConceptDeclaration> superConcepts=getSuperConcepts(subtype,supertype);
  if (!superConcepts.isEmpty()) {
    Set<String> roles=new HashSet<String>();
    Set<String> covariantRoles=new HashSet<String>();
    Set<String> contraVariantRoles=new HashSet<String>();
    Set<String> invariantRoles=new HashSet<String>();
    Set<String> allowsNull=new HashSet<String>();
    collectVariantRoles(superConcepts,allowsNull,covariantRoles,contraVariantRoles,invariantRoles,roles);
    if (!covariantRoles.isEmpty() || !contraVariantRoles.isEmpty() || !invariantRoles.isEmpty()) {
      for (      String role : roles) {
        List<SNode> subChildren=subRepresentator.getChildren(role);
        subChildren.add(subRepresentator.getReferent(role));
        List<SNode> superChildren=superRepresentator.getChildren(role);
        superChildren.add(superRepresentator.getReferent(role));
        while (subChildren.size() < superChildren.size()) {
          subChildren.add(null);
        }
        while (superChildren.size() < subChildren.size()) {
          superChildren.add(null);
        }
        Iterator<SNode> subIt=subChildren.iterator();
        Iterator<SNode> superIt=superChildren.iterator();
        for (; subIt.hasNext(); ) {
          SNode subChild=myTypeChecker.getAdaptationManager().adaptType(subIt.next());
          SNode superChild=myTypeChecker.getAdaptationManager().adaptType(superIt.next());
          if (covariantRoles.contains(role)) {
            if (allowsNull.contains(role) && superChild == null)             continue;
            if (!isSubtype(subChild,superChild))             return false;
          }
 else           if (contraVariantRoles.contains(role)) {
            if (allowsNull.contains(role) && subChild == null)             continue;
            if (!isSubtype(superChild,subChild))             return false;
          }
 else           if (invariantRoles.contains(role)) {
            if (allowsNull.contains(role) && superChild == null)             continue;
            if (!MatchingUtil.matchNodes(subChild,superChild))             return false;
          }
        }
      }
      return true;
    }
  }
  Set<SNode> frontier=new HashSet<SNode>();
  Set<SNode> newFrontier=new HashSet<SNode>();
  frontier.add(subRepresentator);
  while (!frontier.isEmpty()) {
    for (    SNode node : frontier) {
      Set<SNode> ancestors=collectSupertypes(node);
      if (ancestors == null)       continue;
      ancestors.remove(node);
      if (ancestors.contains(superRepresentator))       return true;
      newFrontier.addAll(ancestors);
    }
    frontier=newFrontier;
    newFrontier=new HashSet<SNode>();
  }
  frontier=new HashSet<SNode>();
  newFrontier=new HashSet<SNode>();
  frontier.add(superRepresentator);
  while (!frontier.isEmpty()) {
    for (    SNode node : frontier) {
      Set<SNode> descendants=collectSubtypes(node);
      if (descendants == null)       continue;
      descendants.remove(node);
      if (descendants.contains(subRepresentator))       return true;
      newFrontier.addAll(descendants);
    }
    frontier=newFrontier;
    newFrontier=new HashSet<SNode>();
  }
  return false;
}
