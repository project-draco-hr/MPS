{
  SNode subRepresentator=myTypeChecker.getEquationManager().getRepresentator(subtype);
  SNode superRepresentator=myTypeChecker.getEquationManager().getRepresentator(supertype);
  Set<ConceptDeclaration> superConcepts=new HashSet<ConceptDeclaration>();
{
    Set<ConceptDeclaration> subConcepts=new HashSet<ConceptDeclaration>();
    ConceptDeclaration subConcept=subtype.findConceptDeclaration(GlobalScope.getInstance());
    subConcepts.add(subConcept);
    while (subConcept.getExtends() != null) {
      subConcept=subConcept.getExtends();
      subConcepts.add(subConcept);
    }
    ConceptDeclaration superConcept=supertype.findConceptDeclaration(GlobalScope.getInstance());
    superConcepts.add(superConcept);
    while (superConcept.getExtends() != null) {
      superConcept=superConcept.getExtends();
      superConcepts.add(superConcept);
    }
    superConcepts.retainAll(subConcepts);
  }
  if (!superConcepts.isEmpty()) {
    Set<String> roles=new HashSet<String>();
    Set<String> covariantRoles=new HashSet<String>();
    Set<String> contraVariantRoles=new HashSet<String>();
    Set<String> invariantRoles=new HashSet<String>();
    Set<String> allowsNull=new HashSet<String>();
    for (    ConceptDeclaration superConcept : superConcepts) {
      if (myVarianceRules.containsKey(superConcept)) {
        SubtypingVarianceRule rule=myVarianceRules.get(superConcept);
        for (        LinkVariance linkVariance : CollectionUtil.iteratorAsIterable(rule.linkVariances())) {
          String role=linkVariance.getLinkDeclaration().getRole();
          if (linkVariance.getAllowsNull()) {
            allowsNull.add(role);
          }
          if (linkVariance.getVariance() == _Variance_Enum.covariant) {
            covariantRoles.add(role);
          }
          if (linkVariance.getVariance() == _Variance_Enum.contravariant) {
            contraVariantRoles.add(role);
          }
          if (linkVariance.getVariance() == _Variance_Enum.invariant) {
            invariantRoles.add(role);
          }
        }
        roles.addAll(CollectionUtil.map(CollectionUtil.iteratorAsList(superConcept.linkDeclarations()),new Mapper<LinkDeclaration,String>(){
          public String map(          LinkDeclaration p){
            return p.getRole();
          }
        }
));
      }
    }
    if (!covariantRoles.isEmpty() || !contraVariantRoles.isEmpty() || !invariantRoles.isEmpty()) {
      for (      String role : roles) {
        List<SNode> subChildren=subRepresentator.getChildren(role);
        subChildren.add(subRepresentator.getReferent(role));
        List<SNode> superChildren=superRepresentator.getChildren(role);
        superChildren.add(superRepresentator.getReferent(role));
        while (subChildren.size() < superChildren.size()) {
          subChildren.add(null);
        }
        while (superChildren.size() < subChildren.size()) {
          superChildren.add(null);
        }
        Iterator<SNode> subIt=subChildren.iterator();
        Iterator<SNode> superIt=superChildren.iterator();
        for (; subIt.hasNext(); ) {
          SNode subChild=myTypeChecker.getAdaptationManager().adaptType(subIt.next());
          SNode superChild=myTypeChecker.getAdaptationManager().adaptType(superIt.next());
          if (covariantRoles.contains(role)) {
            if (allowsNull.contains(role) && superChild == null)             continue;
            if (!isSubtype(subChild,superChild))             return false;
          }
 else           if (contraVariantRoles.contains(role)) {
            if (allowsNull.contains(role) && subChild == null)             continue;
            if (!isSubtype(superChild,subChild))             return false;
          }
 else           if (invariantRoles.contains(role)) {
            if (allowsNull.contains(role) && superChild == null)             continue;
            if (!MatchingUtil.matchNodes(subChild,superChild))             return false;
          }
        }
      }
      return true;
    }
  }
  Set<SNode> frontier=new HashSet<SNode>();
  Set<SNode> newFrontier=new HashSet<SNode>();
  frontier.add(subRepresentator);
  while (!frontier.isEmpty()) {
    for (    SNode node : frontier) {
      Set<SNode> ancestors=collectSupertypes(node);
      if (ancestors == null)       continue;
      ancestors.remove(node);
      if (ancestors.contains(superRepresentator))       return true;
      newFrontier.addAll(ancestors);
    }
    frontier=newFrontier;
    newFrontier=new HashSet<SNode>();
  }
  frontier=new HashSet<SNode>();
  newFrontier=new HashSet<SNode>();
  frontier.add(superRepresentator);
  while (!frontier.isEmpty()) {
    for (    SNode node : frontier) {
      Set<SNode> descendants=collectSubtypes(node);
      if (descendants == null)       continue;
      descendants.remove(node);
      if (descendants.contains(subRepresentator))       return true;
      newFrontier.addAll(descendants);
    }
    frontier=newFrontier;
    newFrontier=new HashSet<SNode>();
  }
  return false;
}
