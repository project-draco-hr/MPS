{
  final ProgressIndicatorProgressStrategy pips=new ProgressIndicatorProgressStrategy();
  WorkbenchMakeService.this.getSession();
  final MakeTask task=new MakeTask(ProjectHelper.toIdeaProject(WorkbenchMakeService.this.getSession().getContext().getProject()),taskName,scripts,taskName,clustRes,new WorkbenchMakeService.Controller(controller,mh,pips),mh,PerformInBackgroundOption.DEAF){
    @Override protected void aboutToStart(){
      notifyListeners(new MakeNotification(WorkbenchMakeService.this,MakeNotification.Kind.SCRIPT_ABOUT_TO_START));
    }
    @Override protected void done(){
      currentProcess.compareAndSet(this,null);
      attemptCloseSession();
      notifyListeners(new MakeNotification(WorkbenchMakeService.this,MakeNotification.Kind.SCRIPT_FINISHED));
    }
    @Override protected void displayInfo(    String info){
      WorkbenchMakeService.this.displayInfo(info);
    }
    @Override protected void useProgressIndicator(    ProgressIndicator pi){
      pips.setProgressIndicator(pi);
    }
  }
;
  MakeSession session=WorkbenchMakeService.this.getSession();
  try {
    session.doExecute(new Runnable(){
      public void run(){
        SwingUtilities.invokeLater(new Runnable(){
          public void run(){
            IdeEventQueue.getInstance().flushQueue();
            if (currentProcess.compareAndSet(null,task)) {
              ProgressManager.getInstance().run(task);
            }
 else {
              throw new IllegalStateException("unexpected: make process already running");
            }
            IdeEventQueue.getInstance().flushQueue();
          }
        }
);
      }
    }
);
  }
 catch (  RuntimeException rex) {
    if (currentProcess.get() == null) {
      abortSession();
    }
    throw rex;
  }
  return task;
}
