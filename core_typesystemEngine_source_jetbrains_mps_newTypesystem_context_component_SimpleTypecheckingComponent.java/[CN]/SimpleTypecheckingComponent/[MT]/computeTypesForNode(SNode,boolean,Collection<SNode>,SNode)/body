{
  if (node == null)   return;
  boolean incrementalMode=isIncrementalMode();
  AccessTracking accessTracking=createAccessTracking();
  myQueue.add(node);
  myQueue.addAll(additionalNodes);
  for (SNode sNode=myQueue.poll(); sNode != null; sNode=myQueue.poll()) {
    if (myFullyCheckedNodes.contains(sNode)) {
      continue;
    }
    Set<SNode> candidatesForFrontier=new LinkedHashSet<SNode>();
    if (forceChildrenCheck) {
      candidatesForFrontier.addAll(IterableUtil.asCollection(sNode.getChildren()));
    }
    for (    SNode candidate : candidatesForFrontier) {
      if (candidate == null || myFullyCheckedNodes.contains(candidate))       continue;
      myQueue.add(candidate);
    }
    if (!myPartlyCheckedNodes.contains(sNode)) {
      accessTracking.installReadListeners();
      boolean typeAffected=false;
      try {
        myNodes.add(sNode);
        typeAffected=applyRulesToNode(sNode);
      }
  finally {
        accessTracking.removeReadListeners();
      }
      accessTracking.postProcess(sNode,typeAffected);
      myPartlyCheckedNodes.add(sNode);
    }
    myFullyCheckedNodes.add(sNode);
    if (typeCalculated(targetNode) != null)     return;
  }
}
