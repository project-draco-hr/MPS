{
  Integer index=myIndexMap.get(id);
  if (index == null) {
    return null;
  }
switch (((int)index)) {
case 0:
    return myConceptAtLeastNTimesRegexp;
case 1:
  return myConceptBinaryRegexp;
case 2:
return myConceptCharacterSymbolClassPart;
case 3:
return myConceptDotRegexp;
case 4:
return myConceptFindMatchExpression;
case 5:
return myConceptFindMatchStatement;
case 6:
return myConceptForEachMatchStatement;
case 7:
return myConceptFromNToMTimesRegexp;
case 8:
return myConceptInlineRegexpExpression;
case 9:
return myConceptIntersectionSymbolClassPart;
case 10:
return myConceptIntervalSymbolClassPart;
case 11:
return myConceptLazyPlusRegexp;
case 12:
return myConceptLazyQuestionRegexp;
case 13:
return myConceptLazyStarRegexp;
case 14:
return myConceptLineEndRegexp;
case 15:
return myConceptLineStartRegexp;
case 16:
return myConceptLiteralReplacement;
case 17:
return myConceptLookRegexp;
case 18:
return myConceptMatchParensRegexp;
case 19:
return myConceptMatchRegexpExpression;
case 20:
return myConceptMatchRegexpOperation;
case 21:
return myConceptMatchRegexpStatement;
case 22:
return myConceptMatchVariableReference;
case 23:
return myConceptMatchVariableReferenceRegexp;
case 24:
return myConceptMatchVariableReferenceReplacement;
case 25:
return myConceptNTimesRegexp;
case 26:
return myConceptNegativeLookAheadRegexp;
case 27:
return myConceptNegativeLookBehindRegexp;
case 28:
return myConceptNegativeSymbolClassRegexp;
case 29:
return myConceptOrRegexp;
case 30:
return myConceptParensRegexp;
case 31:
return myConceptPlusRegexp;
case 32:
return myConceptPositiveLookAheadRegexp;
case 33:
return myConceptPositiveLookBehindRegexp;
case 34:
return myConceptPositiveSymbolClassRegexp;
case 35:
return myConceptPredefinedSymbolClassDeclaration;
case 36:
return myConceptPredefinedSymbolClassRegexp;
case 37:
return myConceptPredefinedSymbolClassSymbolClassPart;
case 38:
return myConceptPredefinedSymbolClasses;
case 39:
return myConceptQuestionRegexp;
case 40:
return myConceptRegexp;
case 41:
return myConceptRegexpDeclaration;
case 42:
return myConceptRegexpDeclarationReferenceRegexp;
case 43:
return myConceptRegexpExpression;
case 44:
return myConceptRegexpUsingConstruction;
case 45:
return myConceptRegexps;
case 46:
return myConceptReplaceBlock;
case 47:
return myConceptReplaceRegexpOperation;
case 48:
return myConceptReplaceWithRegexpExpression;
case 49:
return myConceptReplaceWithRegexpOperation;
case 50:
return myConceptReplacement;
case 51:
return myConceptSeqRegexp;
case 52:
return myConceptSplitExpression;
case 53:
return myConceptSplitOperation;
case 54:
return myConceptStarRegexp;
case 55:
return myConceptStringLiteralRegexp;
case 56:
return myConceptSymbolClassPart;
case 57:
return myConceptSymbolClassRegexp;
case 58:
return myConceptSymbolClassRegexpAndPart;
case 59:
return myConceptUnaryRegexp;
case 60:
return myConceptUnicodeCharacterRegexp;
default :
throw new IllegalStateException();
}
}
