{
{
    SAbstractConcept cncpt=concept;
    Integer preIndex=indices_1htk8d_a0nc.get(cncpt);
    int switchIndex=(preIndex == null ? -1 : preIndex);
switch (switchIndex) {
case 0:
      if (true) {
        return myConceptAtLeastNTimesRegexp;
      }
    break;
case 1:
  if (true) {
    return myConceptBinaryRegexp;
  }
break;
case 2:
if (true) {
return myConceptCharacterSymbolClassPart;
}
break;
case 3:
if (true) {
return myConceptDotRegexp;
}
break;
case 4:
if (true) {
return myConceptFindMatchExpression;
}
break;
case 5:
if (true) {
return myConceptFindMatchStatement;
}
break;
case 6:
if (true) {
return myConceptForEachMatchStatement;
}
break;
case 7:
if (true) {
return myConceptFromNToMTimesRegexp;
}
break;
case 8:
if (true) {
return myConceptInlineRegexpExpression;
}
break;
case 9:
if (true) {
return myConceptIntersectionSymbolClassPart;
}
break;
case 10:
if (true) {
return myConceptIntervalSymbolClassPart;
}
break;
case 11:
if (true) {
return myConceptLazyPlusRegexp;
}
break;
case 12:
if (true) {
return myConceptLazyQuestionRegexp;
}
break;
case 13:
if (true) {
return myConceptLazyStarRegexp;
}
break;
case 14:
if (true) {
return myConceptLineEndRegexp;
}
break;
case 15:
if (true) {
return myConceptLineStartRegexp;
}
break;
case 16:
if (true) {
return myConceptLiteralReplacement;
}
break;
case 17:
if (true) {
return myConceptLookRegexp;
}
break;
case 18:
if (true) {
return myConceptMatchParensRegexp;
}
break;
case 19:
if (true) {
return myConceptMatchRegexpExpression;
}
break;
case 20:
if (true) {
return myConceptMatchRegexpOperation;
}
break;
case 21:
if (true) {
return myConceptMatchRegexpStatement;
}
break;
case 22:
if (true) {
return myConceptMatchVariableReference;
}
break;
case 23:
if (true) {
return myConceptMatchVariableReferenceRegexp;
}
break;
case 24:
if (true) {
return myConceptMatchVariableReferenceReplacement;
}
break;
case 25:
if (true) {
return myConceptNTimesRegexp;
}
break;
case 26:
if (true) {
return myConceptNegativeLookAheadRegexp;
}
break;
case 27:
if (true) {
return myConceptNegativeLookBehindRegexp;
}
break;
case 28:
if (true) {
return myConceptNegativeSymbolClassRegexp;
}
break;
case 29:
if (true) {
return myConceptOrRegexp;
}
break;
case 30:
if (true) {
return myConceptParensRegexp;
}
break;
case 31:
if (true) {
return myConceptPlusRegexp;
}
break;
case 32:
if (true) {
return myConceptPositiveLookAheadRegexp;
}
break;
case 33:
if (true) {
return myConceptPositiveLookBehindRegexp;
}
break;
case 34:
if (true) {
return myConceptPositiveSymbolClassRegexp;
}
break;
case 35:
if (true) {
return myConceptPredefinedSymbolClassDeclaration;
}
break;
case 36:
if (true) {
return myConceptPredefinedSymbolClassRegexp;
}
break;
case 37:
if (true) {
return myConceptPredefinedSymbolClassSymbolClassPart;
}
break;
case 38:
if (true) {
return myConceptPredefinedSymbolClasses;
}
break;
case 39:
if (true) {
return myConceptQuestionRegexp;
}
break;
case 40:
if (true) {
return myConceptRegexp;
}
break;
case 41:
if (true) {
return myConceptRegexpDeclaration;
}
break;
case 42:
if (true) {
return myConceptRegexpDeclarationReferenceRegexp;
}
break;
case 43:
if (true) {
return myConceptRegexpExpression;
}
break;
case 44:
if (true) {
return myConceptRegexpUsingConstruction;
}
break;
case 45:
if (true) {
return myConceptRegexps;
}
break;
case 46:
if (true) {
return myConceptReplaceBlock;
}
break;
case 47:
if (true) {
return myConceptReplaceRegexpOperation;
}
break;
case 48:
if (true) {
return myConceptReplaceWithRegexpExpression;
}
break;
case 49:
if (true) {
return myConceptReplaceWithRegexpOperation;
}
break;
case 50:
if (true) {
return myConceptReplacement;
}
break;
case 51:
if (true) {
return myConceptSeqRegexp;
}
break;
case 52:
if (true) {
return myConceptSplitExpression;
}
break;
case 53:
if (true) {
return myConceptSplitOperation;
}
break;
case 54:
if (true) {
return myConceptStarRegexp;
}
break;
case 55:
if (true) {
return myConceptStringLiteralRegexp;
}
break;
case 56:
if (true) {
return myConceptSymbolClassPart;
}
break;
case 57:
if (true) {
return myConceptSymbolClassRegexp;
}
break;
case 58:
if (true) {
return myConceptSymbolClassRegexpAndPart;
}
break;
case 59:
if (true) {
return myConceptUnaryRegexp;
}
break;
case 60:
if (true) {
return myConceptUnicodeCharacterRegexp;
}
break;
default :
}
}
return null;
}
