{
switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0b,conceptFqName)) {
case 0:
    return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.AtLeastNTimesRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").properties("n").alias("{n,}","at least n times").create();
case 1:
  return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").children(new String[]{"left","right"},new boolean[]{false,false}).abstract_().create();
case 2:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.CharacterSymbolClassPart").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").properties("character").alias("'","character").create();
case 3:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.DotRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").alias(".","dot regexp (any character)").create();
case 4:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.FindMatchExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"inputExpression"},new boolean[]{false}).alias("=~","").create();
case 5:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.FindMatchStatement").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction").children(new String[]{"expr","body"},new boolean[]{false,false}).alias("if (expr =~ regex) {","").create();
case 6:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ForEachMatchStatement").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction").children(new String[]{"expr","body"},new boolean[]{false,false}).alias("while (expr =~ regex) {","").create();
case 7:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.FromNToMTimesRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").properties("n","m").alias("{n,m}","at least n but not more than m times").create();
case 8:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.InlineRegexpExpression").super_("jetbrains.mps.baseLanguage.regexp.structure.RegexpExpression").parents("jetbrains.mps.baseLanguage.regexp.structure.RegexpExpression").properties("dotAll","multiLine","caseInsensitive").children(new String[]{"regexp"},new boolean[]{false}).alias("/regexp/","").create();
case 9:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.IntersectionSymbolClassPart").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").children(new String[]{"left","right"},new boolean[]{false,false}).alias("&&","intersection of classes").create();
case 10:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.IntervalSymbolClassPart").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").properties("start","end").alias("-","character range").create();
case 11:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LazyPlusRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("+?","one or more times, reluctant").create();
case 12:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LazyQuestionRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("??","once or not at all, reluctant").create();
case 13:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LazyStarRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("*?","zero or more times, reluctant").create();
case 14:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LineEndRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").alias("$","line end").create();
case 15:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LineStartRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").alias("^","line start").create();
case 16:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LiteralReplacement").super_("jetbrains.mps.baseLanguage.regexp.structure.Replacement").parents("jetbrains.mps.baseLanguage.regexp.structure.Replacement","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").properties("text").create();
case 17:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").children(new String[]{"regexp"},new boolean[]{false}).abstract_().create();
case 18:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchParensRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp","jetbrains.mps.lang.core.structure.INamedConcept","jetbrains.mps.baseLanguage.structure.IVariableAssignment","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"regexp"},new boolean[]{false}).alias("(name:","matching parens").create();
case 19:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"inputExpression"},new boolean[]{false}).alias("matches","").create();
case 20:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpOperation").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.baseLanguage.structure.IOperation","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction","jetbrains.mps.lang.core.structure.BaseConcept").alias("matches","").create();
case 21:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpStatement").super_("jetbrains.mps.baseLanguage.structure.Statement").parents("jetbrains.mps.baseLanguage.structure.Statement","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction").children(new String[]{"body","expr"},new boolean[]{false,false}).alias("if (expr matches regexp) {","match with regexp").create();
case 22:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReference").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").references("match").create();
case 23:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReferenceRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").references("match").create();
case 24:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReferenceReplacement").super_("jetbrains.mps.baseLanguage.regexp.structure.Replacement").parents("jetbrains.mps.baseLanguage.regexp.structure.Replacement").references("match").create();
case 25:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.NTimesRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").properties("n").alias("{n}","exactly n times").create();
case 26:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.NegativeLookAheadRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").alias("(?!","negative look ahead").create();
case 27:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.NegativeLookBehindRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").alias("(?<!","negative look behind").create();
case 28:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.NegativeSymbolClassRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp").alias("[^","negative symbol class").create();
case 29:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.OrRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp").alias("|","").create();
case 30:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ParensRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").children(new String[]{"expr"},new boolean[]{false}).alias("(","parens").create();
case 31:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PlusRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("+","one or more times").create();
case 32:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PositiveLookAheadRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").alias("(?=","").create();
case 33:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PositiveLookBehindRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp").alias("(?<=","positive look behind").create();
case 34:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PositiveSymbolClassRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp").alias("[","positive symbol class").create();
case 35:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassDeclaration").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.lang.core.structure.INamedConcept").properties("description").create();
case 36:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").references("symbolClass").create();
case 37:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassSymbolClassPart").super_("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").parents("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").references("declaration").create();
case 38:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClasses").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.lang.core.structure.INamedConcept").children(new String[]{"symbolClass"},new boolean[]{true}).create();
case 39:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.QuestionRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("?","once or not at all").create();
case 40:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.Regexp").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").abstract_().create();
case 41:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.RegexpDeclaration").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.lang.core.structure.INamedConcept").properties("description").children(new String[]{"regexp"},new boolean[]{false}).create();
case 42:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.RegexpDeclarationReferenceRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").references("regexp").create();
case 43:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.RegexpExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").abstract_().create();
case 44:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction").interface_().children(new String[]{"regexp"},new boolean[]{false}).create();
case 45:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.Regexps").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.lang.core.structure.INamedConcept").children(new String[]{"regexp"},new boolean[]{true}).create();
case 46:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ReplaceBlock").super_("jetbrains.mps.baseLanguage.structure.Closure").parents("jetbrains.mps.baseLanguage.structure.Closure").create();
case 47:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ReplaceRegexpOperation").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.baseLanguage.structure.IOperation","jetbrains.mps.lang.core.structure.BaseConcept").properties("dotAll","multiLine","caseInsensitive","globalReplace").children(new String[]{"search","replacement"},new boolean[]{false,true}).alias("s/regexp/replacement/","").create();
case 48:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ReplaceWithRegexpExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"expr","replaceBlock"},new boolean[]{false,false}).alias("replace with regexp","").create();
case 49:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.ReplaceWithRegexpOperation").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.baseLanguage.structure.IOperation","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction","jetbrains.mps.lang.core.structure.BaseConcept").children(new String[]{"replaceBlock"},new boolean[]{false}).alias("replace with","replace with regexp").create();
case 50:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.Replacement").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").abstract_().create();
case 51:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SeqRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp").alias("seq","").create();
case 52:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SplitExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"expr"},new boolean[]{false}).alias("split with","split with regexp").create();
case 53:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SplitOperation").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.baseLanguage.structure.IOperation","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault","jetbrains.mps.lang.core.structure.BaseConcept").alias("split with","split with regexp").create();
case 54:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.StarRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").parents("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").alias("*","zero or more times").create();
case 55:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.StringLiteralRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").properties("text").alias("'","").create();
case 56:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexpAndPart").abstract_().create();
case 57:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp","jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexpAndPart").children(new String[]{"part"},new boolean[]{true}).abstract_().create();
case 58:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexpAndPart").interface_().create();
case 59:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").children(new String[]{"regexp"},new boolean[]{false}).abstract_().create();
case 60:
return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.regexp.structure.UnicodeCharacterRegexp").super_("jetbrains.mps.baseLanguage.regexp.structure.Regexp").parents("jetbrains.mps.baseLanguage.regexp.structure.Regexp").properties("code").alias("\\uhhhh","").create();
default :
return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);
}
}
