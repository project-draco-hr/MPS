{
switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0b,conceptFqName)) {
case 0:
    return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.AtLeastNTimesRegexp","jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp"},new String[]{"n"},new String[]{},new String[]{},new boolean[]{},false,false,"{n,}","at least n times","");
case 1:
  return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp","jetbrains.mps.baseLanguage.regexp.structure.Regexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.Regexp"},new String[]{},new String[]{},new String[]{"left","right"},new boolean[]{false,false},true,false,"","","");
case 2:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.CharacterSymbolClassPart","jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart"},new String[]{"character"},new String[]{},new String[]{},new boolean[]{},false,false,"'","character","");
case 3:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.DotRegexp","jetbrains.mps.baseLanguage.regexp.structure.Regexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.Regexp"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,".","dot regexp (any character)","");
case 4:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.FindMatchExpression","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{"inputExpression"},new boolean[]{false},false,false,"=~","","");
case 5:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.FindMatchStatement","jetbrains.mps.baseLanguage.structure.Statement",false,new String[]{"jetbrains.mps.baseLanguage.structure.Statement","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction"},new String[]{},new String[]{},new String[]{"expr","body"},new boolean[]{false,false},false,false,"if (expr =~ regex) {","","");
case 6:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.ForEachMatchStatement","jetbrains.mps.baseLanguage.structure.Statement",false,new String[]{"jetbrains.mps.baseLanguage.structure.Statement","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction"},new String[]{},new String[]{},new String[]{"expr","body"},new boolean[]{false,false},false,false,"while (expr =~ regex) {","","");
case 7:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.FromNToMTimesRegexp","jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp"},new String[]{"n","m"},new String[]{},new String[]{},new boolean[]{},false,false,"{n,m}","at least n but not more than m times","");
case 8:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.InlineRegexpExpression","jetbrains.mps.baseLanguage.regexp.structure.RegexpExpression",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.RegexpExpression"},new String[]{"dotAll","multiLine","caseInsensitive"},new String[]{},new String[]{"regexp"},new boolean[]{false},false,false,"/regexp/","","");
case 9:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.IntersectionSymbolClassPart","jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart"},new String[]{},new String[]{},new String[]{"left","right"},new boolean[]{false,false},false,false,"&&","intersection of classes","");
case 10:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.IntervalSymbolClassPart","jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart"},new String[]{"start","end"},new String[]{},new String[]{},new boolean[]{},false,false,"-","character range","");
case 11:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.LazyPlusRegexp","jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"+?","one or more times, reluctant","");
case 12:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.LazyQuestionRegexp","jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"??","once or not at all, reluctant","");
case 13:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.LazyStarRegexp","jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"*?","zero or more times, reluctant","");
case 14:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.LineEndRegexp","jetbrains.mps.baseLanguage.regexp.structure.Regexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.Regexp"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"$","line end","");
case 15:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.LineStartRegexp","jetbrains.mps.baseLanguage.regexp.structure.Regexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.Regexp"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"^","line start","");
case 16:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.LiteralReplacement","jetbrains.mps.baseLanguage.regexp.structure.Replacement",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.Replacement","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{"text"},new String[]{},new String[]{},new boolean[]{},false,false,"","","");
case 17:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.LookRegexp","jetbrains.mps.baseLanguage.regexp.structure.Regexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.Regexp"},new String[]{},new String[]{},new String[]{"regexp"},new boolean[]{false},true,false,"","","");
case 18:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.MatchParensRegexp","jetbrains.mps.baseLanguage.regexp.structure.Regexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.Regexp","jetbrains.mps.lang.core.structure.INamedConcept","jetbrains.mps.baseLanguage.structure.IVariableAssignment","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{"regexp"},new boolean[]{false},false,false,"(name:","matching parens","");
case 19:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpExpression","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{"inputExpression"},new boolean[]{false},false,false,"matches","","");
case 20:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpOperation","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.baseLanguage.structure.IOperation","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction","jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"matches","","");
case 21:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.MatchRegexpStatement","jetbrains.mps.baseLanguage.structure.Statement",false,new String[]{"jetbrains.mps.baseLanguage.structure.Statement","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction"},new String[]{},new String[]{},new String[]{"body","expr"},new boolean[]{false,false},false,false,"if (expr matches regexp) {","match with regexp","");
case 22:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReference","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression"},new String[]{},new String[]{"match"},new String[]{},new boolean[]{},false,false,"","","");
case 23:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReferenceRegexp","jetbrains.mps.baseLanguage.regexp.structure.Regexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.Regexp"},new String[]{},new String[]{"match"},new String[]{},new boolean[]{},false,false,"","","");
case 24:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.MatchVariableReferenceReplacement","jetbrains.mps.baseLanguage.regexp.structure.Replacement",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.Replacement"},new String[]{},new String[]{"match"},new String[]{},new boolean[]{},false,false,"","","");
case 25:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.NTimesRegexp","jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp"},new String[]{"n"},new String[]{},new String[]{},new boolean[]{},false,false,"{n}","exactly n times","");
case 26:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.NegativeLookAheadRegexp","jetbrains.mps.baseLanguage.regexp.structure.LookRegexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.LookRegexp"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"(?!","negative look ahead","");
case 27:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.NegativeLookBehindRegexp","jetbrains.mps.baseLanguage.regexp.structure.LookRegexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.LookRegexp"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"(?<!","negative look behind","");
case 28:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.NegativeSymbolClassRegexp","jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"[^","negative symbol class","");
case 29:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.OrRegexp","jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"|","","");
case 30:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.ParensRegexp","jetbrains.mps.baseLanguage.regexp.structure.Regexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.Regexp"},new String[]{},new String[]{},new String[]{"expr"},new boolean[]{false},false,false,"(","parens","");
case 31:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.PlusRegexp","jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"+","one or more times","");
case 32:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.PositiveLookAheadRegexp","jetbrains.mps.baseLanguage.regexp.structure.LookRegexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.LookRegexp"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"(?=","","");
case 33:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.PositiveLookBehindRegexp","jetbrains.mps.baseLanguage.regexp.structure.LookRegexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.LookRegexp"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"(?<=","positive look behind","");
case 34:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.PositiveSymbolClassRegexp","jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"[","positive symbol class","");
case 35:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassDeclaration","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.lang.core.structure.INamedConcept"},new String[]{"description"},new String[]{},new String[]{},new boolean[]{},false,false,"","","");
case 36:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassRegexp","jetbrains.mps.baseLanguage.regexp.structure.Regexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.Regexp"},new String[]{},new String[]{"symbolClass"},new String[]{},new boolean[]{},false,false,"","","");
case 37:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClassSymbolClassPart","jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart"},new String[]{},new String[]{"declaration"},new String[]{},new boolean[]{},false,false,"","","");
case 38:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.PredefinedSymbolClasses","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.lang.core.structure.INamedConcept"},new String[]{},new String[]{},new String[]{"symbolClass"},new boolean[]{true},false,false,"","","");
case 39:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.QuestionRegexp","jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"?","once or not at all","");
case 40:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.Regexp","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{},new String[]{},new boolean[]{},true,false,"","","");
case 41:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.RegexpDeclaration","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.lang.core.structure.INamedConcept"},new String[]{"description"},new String[]{},new String[]{"regexp"},new boolean[]{false},false,false,"","","");
case 42:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.RegexpDeclarationReferenceRegexp","jetbrains.mps.baseLanguage.regexp.structure.Regexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.Regexp"},new String[]{},new String[]{"regexp"},new String[]{},new boolean[]{},false,false,"","","");
case 43:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.RegexpExpression","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression"},new String[]{},new String[]{},new String[]{},new boolean[]{},true,false,"","","");
case 44:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction",null,true,new String[]{},new String[]{},new String[]{},new String[]{"regexp"},new boolean[]{false},false,false,"","","");
case 45:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.Regexps","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.lang.core.structure.INamedConcept"},new String[]{},new String[]{},new String[]{"regexp"},new boolean[]{true},false,false,"","","");
case 46:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.ReplaceBlock","jetbrains.mps.baseLanguage.structure.Closure",false,new String[]{"jetbrains.mps.baseLanguage.structure.Closure"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"","","");
case 47:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.ReplaceRegexpOperation","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.baseLanguage.structure.IOperation","jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{"dotAll","multiLine","caseInsensitive","globalReplace"},new String[]{},new String[]{"search","replacement"},new boolean[]{false,true},false,false,"s/regexp/replacement/","","");
case 48:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.ReplaceWithRegexpExpression","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{"expr","replaceBlock"},new boolean[]{false,false},false,false,"replace with regexp","","");
case 49:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.ReplaceWithRegexpOperation","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.baseLanguage.structure.IOperation","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction","jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{},new String[]{"replaceBlock"},new boolean[]{false},false,false,"replace with","replace with regexp","");
case 50:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.Replacement","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{},new String[]{},new boolean[]{},true,false,"","","");
case 51:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.SeqRegexp","jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.BinaryRegexp"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"seq","","");
case 52:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.SplitExpression","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{"expr"},new boolean[]{false},false,false,"split with","split with regexp","");
case 53:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.SplitOperation","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.baseLanguage.structure.IOperation","jetbrains.mps.baseLanguage.regexp.structure.RegexpUsingConstruction","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault","jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"split with","split with regexp","");
case 54:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.StarRegexp","jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp"},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"*","zero or more times","");
case 55:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.StringLiteralRegexp","jetbrains.mps.baseLanguage.regexp.structure.Regexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.Regexp"},new String[]{"text"},new String[]{},new String[]{},new boolean[]{},false,false,"'","","");
case 56:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassPart","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexpAndPart"},new String[]{},new String[]{},new String[]{},new boolean[]{},true,false,"","","");
case 57:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexp","jetbrains.mps.baseLanguage.regexp.structure.Regexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.Regexp","jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexpAndPart"},new String[]{},new String[]{},new String[]{"part"},new boolean[]{true},true,false,"","","");
case 58:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.SymbolClassRegexpAndPart",null,true,new String[]{},new String[]{},new String[]{},new String[]{},new boolean[]{},false,false,"","","");
case 59:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.UnaryRegexp","jetbrains.mps.baseLanguage.regexp.structure.Regexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.Regexp"},new String[]{},new String[]{},new String[]{"regexp"},new boolean[]{false},true,false,"","","");
case 60:
return new CompiledConceptDescriptor("jetbrains.mps.baseLanguage.regexp.structure.UnicodeCharacterRegexp","jetbrains.mps.baseLanguage.regexp.structure.Regexp",false,new String[]{"jetbrains.mps.baseLanguage.regexp.structure.Regexp"},new String[]{"code"},new String[]{},new String[]{},new boolean[]{},false,false,"\\uhhhh","","");
default :
return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);
}
}
