{
  IdTableBuilding.registerIdIndexer(MPSFileTypeFactory.MODEL_FILE_TYPE,new FileTypeIdIndexer(){
    @NotNull public Map<IdIndexEntry,Integer> map(    FileContent inputData){
      final CharSequence chars=inputData.getContentAsText();
      final char[] charsArray=CharArrayUtil.fromSequenceWithoutCopying(chars);
      Map<IdIndexEntry,Integer> result=new HashMap<IdIndexEntry,Integer>();
      int wordStart=-1;
      for (int i=0; i < charsArray.length; i++) {
        char c=charsArray[i];
        if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z') {
          if (wordStart == -1) {
            wordStart=i;
          }
        }
 else         if (wordStart >= 0) {
          processWord(result,charsArray,wordStart,i - wordStart);
          wordStart=-1;
        }
      }
      return result;
    }
    private void processWord(    Map<IdIndexEntry,Integer> result,    char[] chars,    int offset,    int len){
      if (chars[offset + len] != '=' || chars[offset] != 't') {
        return;
      }
      if (contains(chars,offset,TARGET_NODE_ID_PREFIX)) {
        offset+=TARGET_NODE_ID_PREFIX.length();
        int end=indexOfQuote(chars,offset);
        if (end > offset) {
          int e=offset;
          while (e < end && chars[e] >= '0' && chars[e] <= '9') {
            e++;
          }
          if (e > offset) {
            if (e < end && chars[e] == 'v') {
              e++;
            }
            if (e + 1 < end && chars[e] == '.') {
              offset=e + 1;
            }
          }
          result.put(new IdIndexEntry(unescape(new String(chars,offset,end - offset)),true),offset);
        }
      }
 else       if (contains(chars,offset,TYPE_PREFIX)) {
        offset+=TYPE_PREFIX.length();
        int end=indexOfQuote(chars,offset);
        if (end > offset && contains(chars,end + 1," id=\"")) {
          result.put(new IdIndexEntry(unescape(new String(chars,offset,end - offset)),true),offset);
        }
      }
    }
    private int indexOfQuote(    char[] chars,    int start){
      for (int i=start; i < chars.length; i++) {
        if (chars[i] == '"') {
          return i;
        }
        if (chars[i] == '\n') {
          return -1;
        }
      }
      return -1;
    }
    private boolean contains(    char[] chars,    int offset,    String s){
      if (offset + s.length() >= chars.length) {
        return false;
      }
      for (int i=0; i < s.length(); i++) {
        if (chars[offset + i] != s.charAt(i)) {
          return false;
        }
      }
      return true;
    }
    private String unescape(    String s){
      return StringEscapeUtils.unescapeXml(s);
    }
  }
);
}
