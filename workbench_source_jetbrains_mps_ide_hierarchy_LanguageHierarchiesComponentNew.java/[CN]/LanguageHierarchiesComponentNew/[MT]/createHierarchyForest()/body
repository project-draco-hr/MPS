{
  List<ConceptContainer> result=new ArrayList<ConceptContainer>();
  Map<AbstractConceptDeclaration,ConceptContainer> processed=new HashMap<AbstractConceptDeclaration,ConceptContainer>();
  SModel structureModel=myLanguage.getStructureModelDescriptor().getSModel();
  ConceptDeclaration baseConcept=SModelUtil_new.getBaseConcept();
  Set<AbstractConceptDeclaration> conceptFrontier=new HashSet<AbstractConceptDeclaration>();
  Set<AbstractConceptDeclaration> newFrontier=new HashSet<AbstractConceptDeclaration>();
  Set<AbstractConceptDeclaration> visited=new HashSet<AbstractConceptDeclaration>();
  conceptFrontier.addAll(structureModel.getRootsAdapters(AbstractConceptDeclaration.class));
  while (!conceptFrontier.isEmpty()) {
    for (    AbstractConceptDeclaration concept : conceptFrontier) {
      if (visited.contains(concept)) {
        continue;
      }
      visited.add(concept);
      ConceptContainer descConceptContainer=processed.get(concept);
      if (descConceptContainer == null) {
        descConceptContainer=new ConceptContainer(concept,this,concept.getModel() != structureModel);
        processed.put(concept,descConceptContainer);
      }
      List<AbstractConceptDeclaration> ancestors=new ArrayList<AbstractConceptDeclaration>();
      if (concept instanceof ConceptDeclaration) {
        ConceptDeclaration conceptDeclaration=(ConceptDeclaration)concept;
        for (        InterfaceConceptReference iref : conceptDeclaration.getImplementses()) {
          ancestors.add(iref.getIntfc());
        }
        ConceptDeclaration anExtends=conceptDeclaration.getExtends();
        if (anExtends != null && anExtends != baseConcept) {
          ancestors.add(anExtends);
        }
      }
 else       if (concept instanceof InterfaceConceptDeclaration) {
        InterfaceConceptDeclaration interfaceConceptDeclaration=(InterfaceConceptDeclaration)concept;
        for (        InterfaceConceptReference iref : interfaceConceptDeclaration.getExtendses()) {
          ancestors.add(iref.getIntfc());
        }
      }
      boolean root=true;
      for (      AbstractConceptDeclaration ancestor : ancestors) {
        if (!(mySkipAncestors && ancestor.getModel() != structureModel)) {
          root=false;
          newFrontier.add(ancestor);
          ConceptContainer parentConceptContainer=processed.get(ancestor);
          if (parentConceptContainer == null) {
            parentConceptContainer=new ConceptContainer(ancestor,this,concept.getModel() != structureModel);
            processed.put(ancestor,parentConceptContainer);
          }
          parentConceptContainer.addChild(descConceptContainer);
        }
      }
      if (root) {
        result.add(processed.get(concept));
      }
    }
    conceptFrontier=newFrontier;
    newFrontier=new HashSet<AbstractConceptDeclaration>();
  }
  myRoots=result;
  Set<ConceptContainer> frontier=new HashSet<ConceptContainer>(myRoots);
  Set<ConceptContainer> newContFrontier=new HashSet<ConceptContainer>();
  Set<ConceptContainer> containers=new HashSet<ConceptContainer>();
  int maxRank=0;
  while (!frontier.isEmpty()) {
    for (    ConceptContainer container : frontier) {
      if (containers.contains(container)) {
        continue;
      }
      containers.add(container);
      for (      ConceptContainer child : container.getChildren()) {
        newContFrontier.add(child);
        child.setRank(Math.max(child.getRank(),container.getRank() + 1));
        maxRank=Math.max(child.getRank(),maxRank);
      }
    }
    frontier=newContFrontier;
    newContFrontier=new HashSet<ConceptContainer>();
  }
  myLevels=new List[maxRank + 1];
  myNodes=new ArrayList<ConceptContainer>(processed.values());
  for (  ConceptContainer conceptContainer : myNodes) {
    List<ConceptContainer> list=myLevels[conceptContainer.getRank()];
    if (list == null) {
      list=new ArrayList<ConceptContainer>();
      myLevels[conceptContainer.getRank()]=list;
    }
    list.add(conceptContainer);
  }
  for (int i=0; i < myLevels.length; i++) {
    List<ConceptContainer> list=myLevels[i];
    if (i == 0) {
      Collections.sort(list,new Comparator<ConceptContainer>(){
        public int compare(        ConceptContainer o1,        ConceptContainer o2){
          return o1.getChildren().size() - o2.getChildren().size();
        }
      }
);
      List<ConceptContainer> newList=new ArrayList<ConceptContainer>();
      for (int j=0; j < list.size(); j+=2) {
        newList.add(list.get(j));
      }
      int last=list.size() - 1;
      last=last - (list.size() % 2);
      for (int j=last; j >= 0; j-=2) {
        newList.add(list.get(j));
      }
      myLevels[i]=newList;
    }
 else {
      final int j=i;
      Collections.sort(list,new Comparator<ConceptContainer>(){
        public int compare(        ConceptContainer o1,        ConceptContainer o2){
          List<ConceptContainer> prevList=myLevels[j - 1];
          float sum1=0;
          float n1=0;
          for (          ConceptContainer parent1 : o1.getParents()) {
            sum1+=prevList.indexOf(parent1);
            n1++;
          }
          float sum2=0;
          float n2=0;
          for (          ConceptContainer parent2 : o2.getParents()) {
            sum2+=prevList.indexOf(parent2);
            n2++;
          }
          return Math.round((sum1 / n1) - (sum2 / n2));
        }
      }
);
    }
  }
  Collections.sort(myNodes);
  return;
}
