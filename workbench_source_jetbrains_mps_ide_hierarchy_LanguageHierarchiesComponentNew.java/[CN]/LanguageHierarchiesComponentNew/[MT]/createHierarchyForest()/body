{
  List<ConceptContainer> result=new ArrayList<ConceptContainer>();
  Map<AbstractConceptDeclaration,ConceptContainer> processed=new HashMap<AbstractConceptDeclaration,ConceptContainer>();
  SModel structureModel=myLanguage.getStructureModelDescriptor().getSModel();
  ConceptDeclaration baseConcept=SModelUtil_new.getBaseConcept();
  Set<AbstractConceptDeclaration> conceptFrontier=new HashSet<AbstractConceptDeclaration>();
  Set<AbstractConceptDeclaration> newFrontier=new HashSet<AbstractConceptDeclaration>();
  Set<AbstractConceptDeclaration> visited=new HashSet<AbstractConceptDeclaration>();
  conceptFrontier.addAll(structureModel.getRootsAdapters(AbstractConceptDeclaration.class));
  while (!conceptFrontier.isEmpty()) {
    for (    AbstractConceptDeclaration concept : conceptFrontier) {
      if (visited.contains(concept)) {
        continue;
      }
      visited.add(concept);
      ConceptContainer descConceptContainer=processed.get(concept);
      if (descConceptContainer == null) {
        descConceptContainer=new ConceptContainer(concept,this,concept.getModel() != structureModel);
        processed.put(concept,descConceptContainer);
      }
      List<AbstractConceptDeclaration> ancestors=new ArrayList<AbstractConceptDeclaration>();
      if (concept instanceof ConceptDeclaration) {
        ConceptDeclaration conceptDeclaration=(ConceptDeclaration)concept;
        for (        InterfaceConceptReference iref : conceptDeclaration.getImplementses()) {
          ancestors.add(iref.getIntfc());
        }
        ConceptDeclaration anExtends=conceptDeclaration.getExtends();
        if (anExtends != null && anExtends != baseConcept) {
          ancestors.add(anExtends);
        }
      }
 else       if (concept instanceof InterfaceConceptDeclaration) {
        InterfaceConceptDeclaration interfaceConceptDeclaration=(InterfaceConceptDeclaration)concept;
        for (        InterfaceConceptReference iref : interfaceConceptDeclaration.getExtendses()) {
          ancestors.add(iref.getIntfc());
        }
      }
      boolean root=true;
      for (      AbstractConceptDeclaration ancestor : ancestors) {
        if (!(mySkipAncestors && ancestor.getModel() != structureModel)) {
          root=false;
          newFrontier.add(ancestor);
          ConceptContainer parentConceptContainer=processed.get(ancestor);
          if (parentConceptContainer == null) {
            parentConceptContainer=new ConceptContainer(ancestor,this,concept.getModel() != structureModel);
            processed.put(ancestor,parentConceptContainer);
          }
          parentConceptContainer.addChild(descConceptContainer);
          descConceptContainer.setRank(Math.max(descConceptContainer.getRank(),parentConceptContainer.getRank() + 1));
        }
      }
      if (root) {
        result.add(processed.get(concept));
      }
    }
    conceptFrontier=newFrontier;
    newFrontier=new HashSet<AbstractConceptDeclaration>();
  }
  myRoots=result;
  myNodes=new ArrayList<ConceptContainer>(processed.values());
  Collections.sort(myNodes);
  return;
}
