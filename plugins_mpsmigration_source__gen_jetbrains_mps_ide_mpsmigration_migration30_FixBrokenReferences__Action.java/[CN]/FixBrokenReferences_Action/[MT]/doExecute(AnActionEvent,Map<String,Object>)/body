{
  try {
    ScopeResolver resolver=new ScopeResolver();
    List<SModule> modulelist=(((List<SModule>)MapSequence.fromMap(_params).get("modules")) == null ? ((MPSProject)MapSequence.fromMap(_params).get("project")).getModulesWithGenerators() : ((List<SModule>)MapSequence.fromMap(_params).get("modules")));
    List<SModel> modellist=(List<SModel>)((((List<SModel>)MapSequence.fromMap(_params).get("models")) == null || ((List<SModel>)MapSequence.fromMap(_params).get("models")).isEmpty() ? ListSequence.fromList(modulelist).translate(new ITranslator2<SModule,SModel>(){
      public Iterable<SModel> translate(      SModule it){
        return it.getModels();
      }
    }
).where(new IWhereFilter<SModel>(){
      public boolean accept(      SModel m){
        return SModelStereotype.isUserModel(m) && !(m.isReadOnly());
      }
    }
).toListSequence() : ((List<SModel>)MapSequence.fromMap(_params).get("models"))));
    Map<SNodePointer,Tuples._2<SReference,SReference>> resolvedR=MapSequence.fromMap(new HashMap<SNodePointer,Tuples._2<SReference,SReference>>());
    Map<SNodePointer,SReference> unresolvedR=MapSequence.fromMap(new HashMap<SNodePointer,SReference>());
    final Map<SNodePointer,Integer> counterR=MapSequence.fromMap(new HashMap<SNodePointer,Integer>());
    for (    SModel model : ListSequence.fromList(modellist)) {
      if (LOG.isEnabledFor(Priority.WARN)) {
        LOG.warn("processing model " + SModelOperations.getModelName(model));
      }
      for (      SNode node : ListSequence.fromList(SModelOperations.getNodes(model,null))) {
        for (        final SReference ref : Sequence.fromIterable(SNodeOperations.getReferences(node))) {
          if (jetbrains.mps.util.SNodeOperations.getTargetNodeSilently(ref) == null) {
            SNodePointer nptr=new SNodePointer(ref.getTargetSModelReference(),ref.getTargetNodeId());
            MapSequence.fromMap(counterR).put(nptr,(MapSequence.fromMap(counterR).get(nptr) == null ? 1 : MapSequence.fromMap(counterR).get(nptr) + 1));
            if (LOG.isEnabledFor(Priority.WARN)) {
              LOG.warn(" reference =" + FixBrokenReferences_Action.this.refInfo(ref,_params));
            }
            boolean r=resolver.resolve(ref,node,new GlobalOperationContext());
            SReference rref=Sequence.fromIterable(SNodeOperations.getReferences(node)).findFirst(new IWhereFilter<SReference>(){
              public boolean accept(              SReference r){
                return eq_g50bqp_a0a0a0a0a0a4a0a0a1a9a0a5(SLinkOperations.getRole(r),SLinkOperations.getRole(ref));
              }
            }
);
            if (r) {
              Tuples._2<SReference,SReference> result=MultiTuple.<SReference,SReference>from(ref,rref);
              if (MapSequence.fromMap(resolvedR).get(nptr) == null || eq_g50bqp_a0a1a5a0a0a1a9a0a5(MapSequence.fromMap(resolvedR).get(nptr),MultiTuple.<SReference,SReference>from(ref,rref))) {
                MapSequence.fromMap(resolvedR).put(nptr,result);
                if (LOG.isEnabledFor(Priority.WARN)) {
                  LOG.warn("resolved to=" + FixBrokenReferences_Action.this.refInfo(rref,_params));
                }
              }
 else {
                if (LOG.isEnabledFor(Priority.ERROR)) {
                  LOG.error("resolving differently: " + FixBrokenReferences_Action.this.refInfo(rref,_params));
                }
                if (LOG.isEnabledFor(Priority.ERROR)) {
                  LOG.error("  before was resolved: " + FixBrokenReferences_Action.this.refInfo(MapSequence.fromMap(resolvedR).get(nptr)._1(),_params));
                }
              }
            }
 else {
              MapSequence.fromMap(unresolvedR).put(nptr,ref);
              if (LOG.isEnabledFor(Priority.ERROR)) {
                LOG.error("unresolved =" + FixBrokenReferences_Action.this.refInfo(rref,_params));
              }
            }
          }
        }
      }
    }
    if (MapSequence.fromMap(unresolvedR).count() > 0) {
      if (LOG.isEnabledFor(Priority.ERROR)) {
        LOG.error(MapSequence.fromMap(unresolvedR).count() + " distinct references were not resolved:");
      }
      for (      SReference ref : MapSequence.fromMap(unresolvedR).sort(new ISelector<IMapping<SNodePointer,SReference>,String>(){
        public String select(        IMapping<SNodePointer,SReference> it){
          return it.key().toString();
        }
      }
,true).select(new ISelector<IMapping<SNodePointer,SReference>,SReference>(){
        public SReference select(        IMapping<SNodePointer,SReference> it){
          return it.value();
        }
      }
)) {
        if (LOG.isEnabledFor(Priority.ERROR)) {
          LOG.error(" reference =" + FixBrokenReferences_Action.this.refInfo(ref,_params) + "; source="+ ref.getSourceNode().getReference());
        }
      }
    }
    if (LOG.isEnabledFor(Priority.WARN)) {
      LOG.warn(MapSequence.fromMap(resolvedR).count() + " distinct references were resolved (total " + MapSequence.fromMap(resolvedR).select(new ISelector<IMapping<SNodePointer,Tuples._2<SReference,SReference>>,Integer>(){
        public Integer select(        IMapping<SNodePointer,Tuples._2<SReference,SReference>> it){
          return (MapSequence.fromMap(counterR).get(it.key()) == null ? 0 : MapSequence.fromMap(counterR).get(it.key()));
        }
      }
).foldLeft(0,new ILeftCombinator<Integer,Integer>(){
        public Integer combine(        Integer s,        Integer ri){
          return s + ri;
        }
      }
)+ ")");
    }
    for (    IMapping<SNodePointer,Tuples._2<SReference,SReference>> it : MapSequence.fromMap(resolvedR)) {
      if (LOG.isEnabledFor(Priority.WARN)) {
        LOG.warn(" ref (" + MapSequence.fromMap(counterR).get(it.key()) + ")="+ FixBrokenReferences_Action.this.refInfo(it.value()._0(),_params));
      }
      if (LOG.isEnabledFor(Priority.WARN)) {
        LOG.warn(" resolved to=" + FixBrokenReferences_Action.this.refInfo(it.value()._1(),_params));
      }
    }
    SModelRepository.getInstance().saveAll();
  }
 catch (  Throwable t) {
    if (LOG.isEnabledFor(Priority.ERROR)) {
      LOG.error("User's action execute method failed. Action:" + "FixBrokenReferences",t);
    }
  }
}
