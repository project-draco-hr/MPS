{
  boolean needsUpdate;
synchronized (myLock) {
    needsUpdate=ListSequence.fromList(this.myCandidates).isEmpty();
  }
  if (needsUpdate) {
    ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable(){
      @Override public void run(){
        collectCandidates(new ProgressMonitorAdapter(ProgressManager.getInstance().getProgressIndicator()));
      }
    }
,"Searching for nodes",false,myProject);
  }
synchronized (myLock) {
    ListSequence.fromList(this.myCandidates).removeSequence(ListSequence.fromList(this.myValues));
    return ListSequence.fromList(this.myCandidates).select(new ISelector<T,SNodeReference>(){
      public SNodeReference select(      T it){
        return unwrap(it);
      }
    }
).toListSequence();
  }
}
