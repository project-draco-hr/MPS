{
  myMessagesChanged=false;
  Set<EditorMessage> messages=new LinkedHashSet<EditorMessage>();
  NodeTypesComponent typesComponent=getNodeTypesComponent(node);
  if (typesComponent != null) {
    if (!wasCheckedOnce || !TypeChecker.getInstance().isCheckedRoot(node.getContainingRoot())) {
      try {
        myMessagesChanged=true;
        TypeChecker.getInstance().checkRoot(node.getContainingRoot());
      }
 catch (      Throwable t) {
        LOG.error(t);
        typesComponent.setChecked();
        return messages;
      }
    }
  }
  if (typesComponent != null) {
    if (!wasCheckedOnce || !typesComponent.isCheckedNonTypesystem()) {
      try {
        myMessagesChanged=true;
        typesComponent.applyNonTypesystemRulesToRoot(operationContext);
      }
 catch (      Throwable t) {
        LOG.error(t);
      }
    }
    for (    Pair<SNode,List<IErrorReporter>> errorNode : typesComponent.getNodesWithErrors()) {
      List<IErrorReporter> errors=new ArrayList<IErrorReporter>(errorNode.o2);
      Collections.sort(errors,new Comparator<IErrorReporter>(){
        public int compare(        IErrorReporter o1,        IErrorReporter o2){
          return o2.getMessageStatus().compareTo(o1.getMessageStatus());
        }
      }
);
      boolean instantIntentionApplied=false;
      for (      IErrorReporter errorReporter : errors) {
        MessageStatus status=errorReporter.getMessageStatus();
        String errorString=errorReporter.reportError();
        HighlighterMessage message=createHighlighterMessage(errorNode.o1,NameUtil.capitalize(status.getPresentation()) + ": " + errorString,errorReporter);
        IntentionProvider intentionProvider=errorReporter.getIntentionProvider();
        if (intentionProvider != null && intentionProvider.isExecutedImmediately() && !IMMEDIATE_QFIX_DISABLED) {
          if (!instantIntentionApplied) {
            final QuickFix_Runtime intention=intentionProvider.getQuickFix();
            if (intention != null) {
              instantIntentionApplied=true;
              if (!myOnceExecutedQuickFixes.contains(intention)) {
                myOnceExecutedQuickFixes.add(intention);
                LaterInvocator.invokeLater(new Runnable(){
                  public void run(){
                    ModelAccess.instance().runWriteActionInCommand(new Runnable(){
                      public void run(){
                        CommandProcessor.getInstance().runUndoTransparentAction(new Runnable(){
                          public void run(){
                            intention.execute(node);
                          }
                        }
);
                      }
                    }
);
                  }
                }
,ModalityState.NON_MODAL);
              }
            }
          }
        }
 else {
          if (intentionProvider != null) {
            intentionProvider.setIsError(status == MessageStatus.ERROR);
          }
          message.setIntentionProvider(intentionProvider);
        }
        messages.add(message);
      }
    }
  }
  return messages;
}
