{
  Iterable<SNode> result=SLinkOperations.getChildren(enumConstant,MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0xfc367388b3L,0x6d60019ab157734L,"method"));
  Map<String,Set<SNode>> nameToMethodsMap=MapSequence.fromMap(new HashMap<String,Set<SNode>>());
  for (  SNode methodToCheck : Sequence.fromIterable(result).where(new IWhereFilter<SNode>(){
    public boolean accept(    SNode it){
      return canOverride(it);
    }
  }
)) {
    SetSequence.fromSet(safeGet(nameToMethodsMap,SPropertyOperations.getString(methodToCheck,MetaAdapterFactory.getProperty(0xceab519525ea4f22L,0x9b92103b95ca8c0cL,0x110396eaaa4L,0x110396ec041L,"name")))).addElement(methodToCheck);
  }
  if (MapSequence.fromMap(nameToMethodsMap).isNotEmpty()) {
    SNode dummy=SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0x1107e0cb103L,"jetbrains.mps.baseLanguage.structure.AnonymousClass"));
    SLinkOperations.setTarget(dummy,MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0x1107e0cb103L,0x1107e0fd2a0L,"classifier"),container);
    collectOverridingMethodsInClassifierHierarchy(dummy,nameToMethodsMap,SetSequence.fromSet(new HashSet<SNode>()));
  }
}
