{
  return new AbstractAction("Generate Stub From Class File"){
    public void actionPerformed(    ActionEvent e){
      CommandProcessor.instance().executeCommand(getContext(),new Runnable(){
        public void run(){
          MPSProject project=getContext().getProject();
          SemanticModel targetModel=targetClass.getSemanticModel();
          String fqName=targetModel.getFQName();
          String name=targetClass.getName();
          String className=fqName + '.' + name;
          SemanticModel tmpModel=new SemanticModel();
          tmpModel.setLoading(true);
          targetModel.addImportedModel(tmpModel);
          try {
            JavaClassMap javaClassMap=JavaClassMaps.getJavaClassMap(tmpModel);
            ClassConcept tmpClass=null;
            try {
              tmpClass=javaClassMap.get(className);
            }
 catch (            Exception e1) {
              e1.printStackTrace();
            }
            if (tmpClass == null) {
              JOptionPane.showMessageDialog(myContainer,"Class not found:\n" + className,"Class Not Found",JOptionPane.ERROR_MESSAGE);
              return;
            }
            targetClass.setExtendedClass(toModelClass(tmpClass.getExtendedClass(),targetModel,project));
            Iterator<StaticFieldDeclaration> staticFields=tmpClass.staticFields();
            while (staticFields.hasNext()) {
              StaticFieldDeclaration staticFieldDeclaration=staticFields.next();
              StaticFieldDeclaration copy=(StaticFieldDeclaration)createValidCopy(staticFieldDeclaration,targetModel,project);
              targetClass.addStaticField(copy);
            }
            Iterator<FieldDeclaration> fields=tmpClass.fields();
            while (fields.hasNext()) {
              FieldDeclaration fieldDeclaration=fields.next();
              FieldDeclaration copy=(FieldDeclaration)createValidCopy(fieldDeclaration,targetModel,project);
              targetClass.addField(copy);
            }
            Iterator<ConstructorDeclaration> constructors=tmpClass.constructors();
            while (constructors.hasNext()) {
              ConstructorDeclaration constructorDeclaration=constructors.next();
              ConstructorDeclaration copy=(ConstructorDeclaration)createValidCopy(constructorDeclaration,targetModel,project);
              targetClass.addConstructor(copy);
            }
            Iterator<InstanceMethodDeclaration> methods=tmpClass.methods();
            while (methods.hasNext()) {
              InstanceMethodDeclaration instanceMethodDeclaration=methods.next();
              InstanceMethodDeclaration copy=(InstanceMethodDeclaration)createValidCopy(instanceMethodDeclaration,targetModel,project);
              targetClass.addMethod(copy);
            }
            Iterator<StaticMethodDeclaration> staticMethods=tmpClass.staticMethods();
            while (staticMethods.hasNext()) {
              StaticMethodDeclaration staticMethodDeclaration=staticMethods.next();
              StaticMethodDeclaration copy=(StaticMethodDeclaration)createValidCopy(staticMethodDeclaration,targetModel,project);
              targetClass.addStaticMethod(copy);
            }
            targetModel.fireModelChangedDramaticallyEvent();
            JOptionPane.showMessageDialog(myContainer,"Added:\n" + tmpClass.getStaticFieldsCount() + " static fields\n"+ tmpClass.getFieldsCount()+ " fields\n"+ tmpClass.getConstructorsCount()+ " constructors\n"+ tmpClass.getMethodsCount()+ " methods\n"+ tmpClass.getStaticMethodsCount()+ " static methods","Class Has Been Generated",JOptionPane.INFORMATION_MESSAGE);
            tmpClass.delete();
          }
  finally {
            targetModel.deleteImportedModel(tmpModel);
          }
        }
      }
,"Generate Stab from Class File");
    }
    private SemanticNode createValidCopy(    SemanticNode node,    SemanticModel targetModel,    MPSProject project){
      SemanticNode copy=ContextUtil.copyNode(node,targetModel,project);
      replaceClasses(copy,targetModel,project);
      if (copy instanceof BaseMethodDeclaration) {
        BaseMethodDeclaration method=(BaseMethodDeclaration)copy;
        Iterator<ParameterDeclaration> iterator=method.parameters();
        int count=0;
        while (iterator.hasNext()) {
          ParameterDeclaration parameterDeclaration=iterator.next();
          parameterDeclaration.setName("parm" + (count++));
        }
      }
      return copy;
    }
    private void replaceClasses(    SemanticNode node,    SemanticModel targetModel,    MPSProject project){
      List<SemanticReference> references=node.getReferences();
      for (int i=0; i < references.size(); i++) {
        SemanticReference reference=references.get(i);
        SemanticNode referent=reference.getTargetNode();
        if (referent instanceof ClassConcept) {
          ClassConcept classInModel=toModelClass((ClassConcept)referent,targetModel,project);
          node.insertReferent(referent,reference.getRole(),classInModel);
          node.removeReferent(reference.getRole(),referent);
        }
      }
      List<SemanticNode> children=node.getChildren();
      for (int i=0; i < children.size(); i++) {
        SemanticNode child=children.get(i);
        replaceClasses(child,targetModel,project);
      }
    }
    private ClassConcept toModelClass(    ClassConcept tmpClass,    SemanticModel targetModel,    MPSProject project){
      ClassConcept modelClass=SemanticModelUtil.findJavaClass(NameUtil.nodeFQName(tmpClass),getContext().getProject());
      if (modelClass == null) {
        modelClass=SemanticModelUtil.findJavaClass("java.lang.Object",project);
      }
      if (modelClass != null && targetModel != modelClass.getSemanticModel()) {
        targetModel.addImportedModel(modelClass.getSemanticModel());
      }
      return modelClass;
    }
  }
;
}
