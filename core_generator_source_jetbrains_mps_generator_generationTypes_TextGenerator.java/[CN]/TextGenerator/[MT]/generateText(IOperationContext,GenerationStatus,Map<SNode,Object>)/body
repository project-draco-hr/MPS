{
  boolean hasErrors=false;
  ModelDependencies dependRoot=new ModelDependencies();
  status.setBLDependencies(dependRoot);
  SModel outputModel=status.getOutputModel();
  if (outputModel == null)   return !hasErrors;
  DebugInfoBuilder debugInfoBuilder=null;
  if (myGenerateDebugInfo) {
    debugInfoBuilder=new DebugInfoBuilder();
    status.setDebugInfo(debugInfoBuilder.getDebugInfo());
  }
  StringBuilder[] buffers=new StringBuilder[]{new StringBuilder(8192),new StringBuilder(32768)};
  for (  SNode outputNode : outputModel.roots()) {
    try {
      buffers[0].setLength(0);
      buffers[1].setLength(0);
      if (buffers[0].capacity() > 100000) {
        buffers[0]=new StringBuilder(8192);
      }
      if (buffers[1].capacity() > 200000) {
        buffers[1]=new StringBuilder(32768);
      }
      TextGenerationResult result=TextGenerationUtil.generateText(context,outputNode,myFailIfNoTextgen,myGenerateDebugInfo,buffers);
      hasErrors|=result.hasErrors();
      if (result.hasErrors()) {
        myTextGenProblems.addAll(result.problems());
      }
 else {
        Object contents=result.getResult();
        if (TextGenerationUtil.NO_TEXTGEN != contents) {
          String fileName=getFileName(outputNode);
          if (debugInfoBuilder != null) {
            debugInfoBuilder.fillDebugInfo(fileName,result.getPositions(),result.getScopePositions(),result.getUnitPositions(),status.getOriginalInputModel());
          }
          fillDependencies(dependRoot,outputNode,fileName,result);
          outputNodeContents.put(outputNode,contents);
        }
 else {
        }
      }
    }
  finally {
      TextGenManager.reset();
    }
  }
  return !hasErrors;
}
