{
  if (node1 == node2)   return true;
  if (node1 == null)   return false;
  if (node2 == null)   return false;
  if (!node1.getConcept().getQualifiedName().equals(node2.getConcept().getQualifiedName()))   return false;
  final Set<String> propertyNames=new HashSet<String>();
  propertyNames.addAll(IterableUtil.asCollection(node1.getPropertyNames()));
  propertyNames.addAll(IterableUtil.asCollection(node2.getPropertyNames()));
  final HashMap<String,SProperty> propertyDeclarations=new HashMap<String,SProperty>();
  for (  SProperty p : node1.getConcept().getProperties()) {
    propertyDeclarations.put(p.getName(),p);
  }
  for (  String propertyName : propertyNames) {
    SProperty propertyDeclaration=propertyDeclarations.get(propertyName);
    String stringValue1=node1.getProperty(propertyName);
    String stringValue2=node2.getProperty(propertyName);
    Object propertyValue1=stringValue1;
    Object propertyValue2=stringValue2;
    if (propertyDeclaration == null) {
      SNode diagnosticsNode=stringValue1 != null ? node1 : node2;
      LOG.warning("can't find a property declaration for property " + propertyName + " in a concept "+ diagnosticsNode.getConcept().getQualifiedName(),diagnosticsNode);
      LOG.warning("try to compare just properties' internal values");
    }
 else {
      SDataType dataType=propertyDeclaration.getType();
      if (dataType != null) {
        propertyValue1=dataType.fromString(stringValue1);
        propertyValue2=dataType.fromString(stringValue2);
      }
    }
    if (!EqualUtil.equals(propertyValue1,propertyValue2))     return false;
  }
  Set<String> referenceRoles=jetbrains.mps.util.SNodeOperations.getReferenceRoles(node1);
  referenceRoles.addAll(jetbrains.mps.util.SNodeOperations.getReferenceRoles(node2));
  for (  String role : referenceRoles) {
    SNode target1=node1.getReferenceTarget(role);
    SNode target2=node2.getReferenceTarget(role);
    if (matchModifier.accept(target1,target2)) {
      matchModifier.performAction(target1,target2);
      continue;
    }
    if (target2 != target1)     return false;
  }
  Set<String> childRoles=jetbrains.mps.util.SNodeOperations.getChildRoles(node1,matchAttributes);
  childRoles.addAll(jetbrains.mps.util.SNodeOperations.getChildRoles(node2,matchAttributes));
  for (  String role : childRoles) {
    List<SNode> children1=((List)IterableUtil.asList(node1.getChildren(role)));
    List<SNode> children2=((List)IterableUtil.asList(node2.getChildren(role)));
    if (matchModifier.acceptList(children1,children2)) {
      matchModifier.performGroupAction(children1,children2);
      continue;
    }
    Iterator<? extends SNode> childrenIterator=children1.iterator();
    for (    SNode child2 : children2.toArray(new SNode[children2.size()])) {
      SNode child1=childrenIterator.hasNext() ? childrenIterator.next() : null;
      if (matchModifier.accept(child1,child2)) {
        matchModifier.performAction(child1,child2);
        continue;
      }
      if (!matchNodes(child1,child2,matchModifier,matchAttributes))       return false;
    }
    while (childrenIterator.hasNext()) {
      SNode child1=childrenIterator.next();
      SNode child2=null;
      if (matchModifier.accept(child1,child2)) {
        matchModifier.performAction(child1,child2);
        continue;
      }
      if (!matchNodes(child1,child2,matchModifier,matchAttributes))       return false;
    }
  }
  return true;
}
