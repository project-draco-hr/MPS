{
  if (node1 == node2)   return true;
  if (node1 == null)   return false;
  if (node2 == null)   return false;
  if (!node1.getConcept().equals(node2.getConcept()))   return false;
  final Set<SProperty> properties=new HashSet<SProperty>();
  properties.addAll(IterableUtil.asSet(node1.getProperties()));
  properties.addAll(IterableUtil.asSet(node2.getProperties()));
  for (  SProperty property : properties) {
    String stringValue1=node1.getProperty(property);
    String stringValue2=node2.getProperty(property);
    if (!IterableUtil.asCollection(node1.getConcept().getProperties()).contains(property)) {
      SNode diagnosticsNode=stringValue1 != null ? node1 : node2;
      LOG.warning("can't find a property declaration for property `" + property.getName() + "` in a concept "+ diagnosticsNode.getConcept().getQualifiedName(),diagnosticsNode);
      LOG.warning("try to compare just properties' internal values");
    }
    if (!EqualUtil.equals(stringValue1,stringValue2))     return false;
  }
  Set<SReferenceLink> referenceRoles=new HashSet<SReferenceLink>();
  for (  SReference ref : node1.getReferences()) {
    referenceRoles.add(ref.getLink());
  }
  for (  SReference ref : node2.getReferences()) {
    referenceRoles.add(ref.getLink());
  }
  for (  SReferenceLink role : referenceRoles) {
    SNode target1=node1.getReferenceTarget(role);
    SNode target2=node2.getReferenceTarget(role);
    if (matchModifier.accept(target1,target2)) {
      matchModifier.performAction(target1,target2);
      continue;
    }
    if (target2 != target1)     return false;
  }
  Set<SContainmentLink> childRoles=jetbrains.mps.util.SNodeOperations.getChildRoles(node1,matchAttributes);
  childRoles.addAll(jetbrains.mps.util.SNodeOperations.getChildRoles(node2,matchAttributes));
  for (  SContainmentLink role : childRoles) {
    List<SNode> children1=IterableUtil.asList(node1.getChildren(role));
    List<SNode> children2=IterableUtil.asList(node2.getChildren(role));
    if (matchModifier.acceptList(children1,children2)) {
      matchModifier.performGroupAction(children1,children2);
      continue;
    }
    Iterator<? extends SNode> childrenIterator=children1.iterator();
    for (    SNode child2 : children2.toArray(new SNode[children2.size()])) {
      SNode child1=childrenIterator.hasNext() ? childrenIterator.next() : null;
      if (matchModifier.accept(child1,child2)) {
        matchModifier.performAction(child1,child2);
        continue;
      }
      if (!matchNodes(child1,child2,matchModifier,matchAttributes))       return false;
    }
    while (childrenIterator.hasNext()) {
      SNode child1=childrenIterator.next();
      SNode child2=null;
      if (matchModifier.accept(child1,child2)) {
        matchModifier.performAction(child1,child2);
        continue;
      }
      if (!matchNodes(child1,child2,matchModifier,matchAttributes))       return false;
    }
  }
  return true;
}
