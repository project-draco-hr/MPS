{
  if (node1 == node2)   return true;
  if (node1 == null)   return false;
  if (node2 == null)   return false;
  if (!node1.getConceptFqName().equals(node2.getConceptFqName()))   return false;
  final Set<String> propertyNames=new HashSet<String>();
  PropertyVisitor collector=new PropertyVisitor(){
    public boolean visitProperty(    String name,    String value){
      propertyNames.add(name);
      return true;
    }
  }
;
  node1.visitProperties(collector);
  node2.visitProperties(collector);
  SNode typeDeclaration=node1.getConceptDeclarationNode();
  for (  String propertyName : propertyNames) {
    SNode propertyDeclaration=SModelSearchUtil.findPropertyDeclaration(typeDeclaration,propertyName);
    String propertyValue1=node1.getProperty(propertyName);
    String propertyValue2=node2.getProperty(propertyName);
    if (propertyDeclaration == null) {
      SNode diagnosticsNode=node1.getProperty(propertyName) != null ? node1 : node2;
      LOG.warning("can't find a property declaration for property " + propertyName + " in a concept "+ typeDeclaration,diagnosticsNode);
      LOG.warning("try to compare just properties' internal values");
      if (!EqualUtil.equals(propertyValue1,propertyValue2))       return false;
    }
 else {
      PropertySupport propertySupport=PropertySupport.getPropertySupport(propertyDeclaration);
      if (!EqualUtil.equals(propertySupport.fromInternalValue(propertyValue1),propertySupport.fromInternalValue(propertyValue2)))       return false;
    }
  }
  Set<String> referenceRoles=node1.getReferenceRoles();
  referenceRoles.addAll(node2.getReferenceRoles());
  for (  String role : referenceRoles) {
    SNode target1=node1.getReferent(role);
    SNode target2=node2.getReferent(role);
    if (matchModifier.accept(target1,target2)) {
      matchModifier.performAction(target1,target2);
      continue;
    }
    if (target2 != target1)     return false;
  }
  Set<String> childRoles=node1.getChildRoles(matchAttributes);
  childRoles.addAll(node2.getChildRoles(matchAttributes));
  for (  String role : childRoles) {
    List<SNode> children1=node1.getChildren(role);
    List<SNode> children2=node2.getChildren(role);
    if (matchModifier.acceptList(children1,children2)) {
      matchModifier.performGroupAction(children1,children2);
      continue;
    }
    Iterator<SNode> childrenIterator=children1.iterator();
    for (    SNode child2 : children2.toArray(new SNode[children2.size()])) {
      SNode child1=childrenIterator.hasNext() ? childrenIterator.next() : null;
      if (matchModifier.accept(child1,child2)) {
        matchModifier.performAction(child1,child2);
        continue;
      }
      if (!matchNodes(child1,child2,matchModifier,matchAttributes))       return false;
    }
    while (childrenIterator.hasNext()) {
      SNode child1=childrenIterator.next();
      SNode child2=null;
      if (matchModifier.accept(child1,child2)) {
        matchModifier.performAction(child1,child2);
        continue;
      }
      if (!matchNodes(child1,child2,matchModifier,matchAttributes))       return false;
    }
  }
  return true;
}
