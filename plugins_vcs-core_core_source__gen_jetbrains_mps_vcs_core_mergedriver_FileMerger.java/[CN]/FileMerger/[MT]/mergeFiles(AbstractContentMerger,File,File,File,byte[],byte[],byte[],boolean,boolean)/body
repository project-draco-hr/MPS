{
  contentMerger.setConflictMarks(conflictStart,conflictEnd,separator);
  FileInputStream baseIS=null;
  FileInputStream localIS=null;
  FileInputStream latestIS=null;
  OutputStream out=null;
  try {
    baseIS=new FileInputStream(baseFile);
    localIS=new FileInputStream(localFile);
    latestIS=new FileInputStream(latestFile);
    byte[] baseContent=ReadUtil.read(baseIS);
    byte[] localContent=ReadUtil.read(localIS);
    byte[] latestContent=ReadUtil.read(latestIS);
    FileUtil.closeFileSafe(localIS);
    out=(overwrite ? new FileOutputStream(localFile) : System.out);
    Tuples._2<Integer,byte[]> mergeResult=contentMerger.mergeContents(baseContent,localContent,latestContent);
    if (mergeResult == null) {
      mergeResult=MultiTuple.<Integer,byte[]>from(AbstractContentMerger.FATAL_ERROR,localContent);
    }
    out.write((convertCRLF ? convert(mergeResult._1()) : mergeResult._1()));
    return (int)mergeResult._0();
  }
 catch (  IOException e) {
    e.printStackTrace();
    return AbstractContentMerger.FATAL_ERROR;
  }
 finally {
    FileUtil.closeFileSafe(baseIS);
    FileUtil.closeFileSafe(localIS);
    FileUtil.closeFileSafe(latestIS);
    FileUtil.closeFileSafe(out);
  }
}
