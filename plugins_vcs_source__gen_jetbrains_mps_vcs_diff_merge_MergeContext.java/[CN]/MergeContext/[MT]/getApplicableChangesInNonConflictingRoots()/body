{
  return SetSequence.fromSet(MapSequence.fromMap(myRootToChanges).keySet()).<ModelChange>translate(new ITranslator2<SNodeId,ModelChange>(){
    public Iterable<ModelChange> translate(    SNodeId root){
      Iterable<ModelChange> unresolvedForRoot=ListSequence.fromList(MapSequence.fromMap(myRootToChanges).get(root)).where(new IWhereFilter<ModelChange>(){
        public boolean accept(        ModelChange ch){
          return !(isChangeResolved(ch));
        }
      }
);
      if (Sequence.fromIterable(unresolvedForRoot).all(new IWhereFilter<ModelChange>(){
        public boolean accept(        ModelChange ch){
          return Sequence.fromIterable(getConflictedWith(ch)).isEmpty();
        }
      }
)) {
        return unresolvedForRoot;
      }
 else {
        return Sequence.fromIterable(Collections.<ModelChange>emptyList());
      }
    }
  }
);
}
