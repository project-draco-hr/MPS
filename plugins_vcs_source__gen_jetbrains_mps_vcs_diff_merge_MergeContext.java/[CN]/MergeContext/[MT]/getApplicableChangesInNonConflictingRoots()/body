{
  return SetSequence.<SNodeId>fromSet(MapSequence.fromMap(myRootToChanges).keySet()).<ModelChange>translate(new ITranslator2<SNodeId,ModelChange>(){
    public Iterable<ModelChange> translate(    SNodeId root){
      Iterable<ModelChange> unresolvedForRoot=ListSequence.<ModelChange>fromList(MapSequence.<SNodeId,List<ModelChange>>fromMap(myRootToChanges).get(root)).where(new IWhereFilter<ModelChange>(){
        public boolean accept(        ModelChange ch){
          return !(SetSequence.<ModelChange>fromSet(myResolvedChanges).contains(ch));
        }
      }
);
      if (Sequence.<ModelChange>fromIterable(unresolvedForRoot).all(new IWhereFilter<ModelChange>(){
        public boolean accept(        ModelChange ch){
          return Sequence.<ModelChange>fromIterable(getConflictedWith(ch)).isEmpty();
        }
      }
)) {
        return unresolvedForRoot;
      }
 else {
        return Sequence.<ModelChange>fromIterable(Collections.<ModelChange>emptyList());
      }
    }
  }
).concat(ListSequence.<ModelChange>fromList(myMetadataChanges).where(new IWhereFilter<ModelChange>(){
    public boolean accept(    ModelChange ch){
      return !(SetSequence.<ModelChange>fromSet(myResolvedChanges).contains(ch));
    }
  }
));
}
