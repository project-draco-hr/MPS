{
  return SetSequence.fromSet(MapSequence.fromMap(myRootToChanges).keySet()).<ModelChange>translate(new ITranslator2<SNodeId,ModelChange>(){
    public Iterable<ModelChange> translate(    SNodeId root){
      Iterable<ModelChange> unresolvedForRoot=ListSequence.fromList(MapSequence.fromMap(myRootToChanges).get(root)).where(new IWhereFilter<ModelChange>(){
        public boolean accept(        ModelChange ch){
          return !(SetSequence.fromSet(myResolvedChanges).contains(ch));
        }
      }
);
      if (Sequence.fromIterable(unresolvedForRoot).all(new IWhereFilter<ModelChange>(){
        public boolean accept(        ModelChange ch){
          return Sequence.fromIterable(getConflictedWith(ch)).isEmpty();
        }
      }
)) {
        return unresolvedForRoot;
      }
 else {
        return Sequence.fromIterable(Collections.<ModelChange>emptyList());
      }
    }
  }
).concat(ListSequence.fromList(myMetadataChanges).where(new IWhereFilter<ModelChange>(){
    public boolean accept(    ModelChange ch){
      return !(SetSequence.fromSet(myResolvedChanges).contains(ch));
    }
  }
));
}
