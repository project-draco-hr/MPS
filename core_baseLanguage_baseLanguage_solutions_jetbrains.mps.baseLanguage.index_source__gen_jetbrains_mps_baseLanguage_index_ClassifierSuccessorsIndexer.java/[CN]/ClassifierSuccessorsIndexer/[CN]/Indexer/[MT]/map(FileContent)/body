{
  final Map<GlobalSNodeId,List<GlobalSNodeId>> result=MapSequence.fromMap(new HashMap<GlobalSNodeId,List<GlobalSNodeId>>());
  ModelAccess.instance().runIndexing(new Runnable(){
    public void run(){
      SModel sModel=BaseSNodeDescriptorIndex.doModelParsing(inputData);
      for (      final SNode nextNode : sModel.nodes()) {
        if (isInstanceOfClassConcept(nextNode)) {
          SNode classNode=(SNode)nextNode;
          if (SLinkOperations.getTarget(classNode,"superclass",true) != null) {
            safeMap(SLinkOperations.getTarget(classNode,"superclass",true),classNode);
          }
          for (          SNode implementedInterface : ListSequence.fromList(SLinkOperations.getTargets(classNode,"implementedInterface",true))) {
            safeMap(implementedInterface,classNode);
          }
          if (isInstanceOfAnonymousClassConcept(classNode)) {
            safeMap(classNode.getReference(SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.AnonymousClass","classifier"),"role")),classNode);
          }
        }
 else         if (isInstanceOfInterfaceConcept(nextNode)) {
          SNode interfaceNode=(SNode)nextNode;
          for (          SNode extendedInterface : ListSequence.fromList(SLinkOperations.getTargets(interfaceNode,"extendedInterface",true))) {
            safeMap(extendedInterface,interfaceNode);
          }
        }
      }
    }
    private void safeMap(    SNode classifierType,    SNode node){
      safeMap(classifierType.getReference(SPropertyOperations.getString(SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.ClassifierType","classifier"),"role")),node);
    }
    private void safeMap(    SReference reference,    SNode node){
      GlobalSNodeId key=GlobalSNodeId.createSNodeId(reference);
      if (key == null) {
        return;
      }
      List<GlobalSNodeId> successors=MapSequence.fromMap(result).get(key);
      if (successors == null) {
        successors=ListSequence.fromList(new ArrayList<GlobalSNodeId>());
        MapSequence.fromMap(result).put(key,successors);
      }
      ListSequence.fromList(successors).addElement(new GlobalSNodeId(node));
    }
    private boolean isInstanceOfClassConcept(    SNode node){
      String conceptFQName=node.getConceptFqName();
      return "jetbrains.mps.baseLanguage.structure.ClassConcept".equals(conceptFQName) || "jetbrains.mps.baseLanguage.structure.AnonymousClass".equals(conceptFQName) || "jetbrains.mps.baseLanguage.structure.EnumClass".equals(conceptFQName)|| "jetbrains.mps.baseLanguageInternal.structure.ExtractStaticInnerClassConcept".equals(conceptFQName)|| "jetbrains.mps.baseLanguage.unitTest.structure.BTestCase".equals(conceptFQName);
    }
    private boolean isInstanceOfAnonymousClassConcept(    SNode node){
      return "jetbrains.mps.baseLanguage.structure.AnonymousClass".equals(node.getConceptFqName());
    }
    private boolean isInstanceOfInterfaceConcept(    SNode node){
      String conceptFQName=node.getConceptFqName();
      return "jetbrains.mps.baseLanguage.structure.Interface".equals(conceptFQName) || "jetbrains.mps.baseLanguage.structure.Annotation".equals(conceptFQName);
    }
  }
);
  return result;
}
