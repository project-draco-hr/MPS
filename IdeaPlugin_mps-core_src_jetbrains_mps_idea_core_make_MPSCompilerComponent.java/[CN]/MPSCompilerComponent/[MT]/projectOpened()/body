{
  CompilerManager compilerManager=CompilerManager.getInstance(project);
  final List<String> errorMessages=new ArrayList<String>();
  project.getMessageBus().connect().subscribe(CustomBuilderMessageHandler.TOPIC,new RefreshFilesCompilationStatusListener());
  project.getMessageBus().connect().subscribe(CustomBuilderMessageHandler.TOPIC,new NavigateToNodesWithErrors(errorMessages));
  compilerManager.addCompilableFileType(MPSFileTypeFactory.MPS_FILE_TYPE);
  compilerManager.addCompilableFileType(MPSFileTypeFactory.MPS_ROOT_FILE_TYPE);
  compilerManager.addBeforeTask(new CompileTask(){
    @Override public boolean execute(    final CompileContext context){
      final CompileScope compileScope=context.getCompileScope();
      if (compileScope == null)       return true;
      final boolean compileFlag[]=new boolean[1];
      try {
        compileFlag[0]=CompilerWorkspaceConfiguration.class.getDeclaredField(ApplicationInfo.getInstance().getMajorVersion().equals("12") ? "USE_COMPILE_SERVER" : "USE_OUT_OF_PROCESS_BUILD").getBoolean(CompilerWorkspaceConfiguration.getInstance(project));
      }
 catch (      IllegalAccessException e) {
      }
catch (      NoSuchFieldException e) {
      }
      if (!compileFlag[0]) {
        final VirtualFile[] files=compileScope.getFiles(MPSFileTypeFactory.MPS_FILE_TYPE,true);
        final VirtualFile[] rootFiles=compileScope.getFiles(MPSFileTypeFactory.MPS_ROOT_FILE_TYPE,true);
        if (files.length > 0 || rootFiles.length > 0) {
          context.addMessage(CompilerMessageCategory.ERROR,"Generating MPS models is not supported for in-process compiler",null,0,0);
          return false;
        }
      }
      StringBuilder sb=new StringBuilder();
      PluginLibrariesContributor pluginLibContributor=ApplicationManager.getApplication().getComponent(PluginLibrariesContributor.class);
      for (      LibDescriptor library : pluginLibContributor.getLibraries()) {
        String path=FileUtil.toSystemDependentName(library.path);
        if (sb.length() > 0) {
          sb.append(";");
        }
        sb.append(path);
      }
      compileScope.putUserData(MPSMakeConstants.MPS_LANGUAGES,sb.toString());
      final File repositoryCache=new File(CompilerPaths.getCompilerSystemDirectory(project),"mps_repository.dat");
      final long start=System.nanoTime();
      ModelAccess.instance().runReadAction(new Runnable(){
        @Override public void run(){
          CachedRepositoryData cachedRepositoryData=MPSRepositoryUtil.buildData(LibraryInitializer.getInstance().getModuleHandles());
          ModelOutputStream mos=null;
          try {
            mos=new ModelOutputStream(new FileOutputStream(repositoryCache));
            cachedRepositoryData.save(mos);
            compileScope.putUserData(MPSMakeConstants.MPS_REPOSITORY,repositoryCache.getPath());
          }
 catch (          IOException e) {
            context.addMessage(CompilerMessageCategory.INFORMATION,"cannot save cache for MPS, generation may be slow",null,0,0);
          }
 finally {
            jetbrains.mps.util.FileUtil.closeFileSafe(mos);
          }
        }
      }
);
      long result=(System.nanoTime() - start) / 1000000;
      if (CompilerWorkspaceConfiguration.getInstance(project).COMPILER_PROCESS_ADDITIONAL_VM_OPTIONS.contains("-Dmps.jps.debug=true")) {
        context.addMessage(CompilerMessageCategory.INFORMATION,"repository cache saved in " + result + " ms",null,0,0);
      }
      return true;
    }
  }
);
  compilerManager.addAfterTask(new CompileTask(){
    @Override public boolean execute(    CompileContext context){
      for (      String errmsg : errorMessages) {
        ModelNodeNavigatable navigatable=ModelNodeNavigatable.extractNavigatable(errmsg,context.getProject(),null);
        context.addMessage(CompilerMessageCategory.ERROR,errmsg,null,-1,-1,navigatable);
      }
      boolean noErrors=errorMessages.isEmpty();
      errorMessages.clear();
      return noErrors;
    }
  }
);
}
