{
  CompilerManager compilerManager=CompilerManager.getInstance(project);
  final List<String> errorMessages=new ArrayList<String>();
  project.getMessageBus().connect().subscribe(CustomBuilderMessageHandler.TOPIC,new RefreshFilesCompilationStatusListener());
  project.getMessageBus().connect().subscribe(CustomBuilderMessageHandler.TOPIC,new NavigateToNodesWithErrors(errorMessages));
  compilerManager.addCompilableFileType(MPSFileTypeFactory.MODEL_FILE_TYPE);
  for (  MPSCompiler2 compiler : compilerManager.getCompilers(MPSCompiler2.class)) {
    compilerManager.removeCompiler(compiler);
  }
  compilerManager.addCompiler(new MPSCompiler2(project));
  compilerManager.addBeforeTask(new CompileTask(){
    @Override public boolean execute(    final CompileContext context){
      if (!CompilerWorkspaceConfiguration.getInstance(project).USE_COMPILE_SERVER)       return true;
      StringBuilder sb=new StringBuilder();
      PluginLibrariesContributor pluginLibContributor=ApplicationManager.getApplication().getComponent(PluginLibrariesContributor.class);
      for (      LibDescriptor library : pluginLibContributor.getLibraries()) {
        String path=FileUtil.toSystemDependentName(library.path);
        if (sb.length() > 0) {
          sb.append(";");
        }
        sb.append(path);
      }
      context.getCompileScope().putUserData(MPSMakeConstants.MPS_LANGUAGES,sb.toString());
      final File repositoryCache=new File(CompilerPaths.getCompilerSystemDirectory(project),"mps_repository.dat");
      final long start=System.nanoTime();
      ModelAccess.instance().runReadAction(new Runnable(){
        @Override public void run(){
          CachedRepositoryData cachedRepositoryData=MPSRepositoryUtil.buildData(LibraryInitializer.getInstance().getModuleHandles());
          ModelOutputStream mos=null;
          try {
            mos=new ModelOutputStream(new FileOutputStream(repositoryCache));
            cachedRepositoryData.save(mos);
            context.getCompileScope().putUserData(MPSMakeConstants.MPS_REPOSITORY,repositoryCache.getPath());
          }
 catch (          IOException e) {
            context.addMessage(CompilerMessageCategory.INFORMATION,"cannot save cache for MPS, generation may be slow",null,0,0);
          }
 finally {
            jetbrains.mps.util.FileUtil.closeFileSafe(mos);
          }
        }
      }
);
      long result=(System.nanoTime() - start) / 1000000;
      if (CompilerWorkspaceConfiguration.getInstance(project).COMPILER_PROCESS_ADDITIONAL_VM_OPTIONS.contains("-Dmps.jps.debug=true")) {
        context.addMessage(CompilerMessageCategory.INFORMATION,"repository cache saved in " + result + " ms",null,0,0);
      }
      return true;
    }
  }
);
  compilerManager.addAfterTask(new CompileTask(){
    @Override public boolean execute(    CompileContext context){
      for (      String errmsg : errorMessages) {
        ModelNodeNavigatable navigatable=ModelNodeNavigatable.extractNavigatable(errmsg,context.getProject(),null);
        context.addMessage(CompilerMessageCategory.ERROR,errmsg,null,-1,-1,navigatable);
      }
      boolean noErrors=errorMessages.isEmpty();
      errorMessages.clear();
      return noErrors;
    }
  }
);
}
