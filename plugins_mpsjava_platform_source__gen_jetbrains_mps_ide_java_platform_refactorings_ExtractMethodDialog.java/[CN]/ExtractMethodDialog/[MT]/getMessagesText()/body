{
  this.myCanRefactor=true;
  StringBuffer buff=new StringBuffer();
  String methodName=this.myParameters.getName();
  if (methodName.length() == 0) {
    buff.append("Method name is empty.\n");
    this.myCanRefactor=false;
  }
 else {
    boolean nameIsGood=Character.isJavaIdentifierStart(methodName.charAt(0));
    for (int i=1; i < methodName.length(); i++) {
      nameIsGood=nameIsGood && Character.isJavaIdentifierPart(methodName.charAt(i));
    }
    if (!(nameIsGood)) {
      buff.append("Method name is incorrect.");
      this.myCanRefactor=false;
    }
  }
  if (this.myAnalyzeErrors != null) {
    buff.append(this.myAnalyzeErrors);
    this.myCanRefactor=false;
  }
  SNode overrides=this.myParameters.getOverridingMethodClass();
  if (overrides != null && !(this.myExtractIntoOuterContainer)) {
    if ((overrides == SNodeOperations.getAncestor(this.myParameters.getContainerMethod(),"jetbrains.mps.baseLanguage.structure.Classifier",false,false))) {
      buff.append("Such method already exists.\n");
    }
 else {
      buff.append("Method overrides method from class ").append(SPropertyOperations.getString(overrides,"name")).append("\n");
    }
    this.myCanRefactor=false;
  }
  if (buff.length() == 0) {
    buff.append("\n");
  }
  return buff.toString();
}
