{
  this.myCanRefactor=true;
  StringBuffer buff=new StringBuffer();
  String methodName=this.myParameters.getName();
  if (methodName.length() == 0) {
    buff.append("Method name is empty.\n");
    this.myCanRefactor=false;
  }
 else {
    boolean nameIsGood=Character.isJavaIdentifierStart(methodName.charAt(0));
    for (int i=1; i < methodName.length(); i++) {
      nameIsGood=nameIsGood && Character.isJavaIdentifierPart(methodName.charAt(i));
    }
    if (!(nameIsGood)) {
      buff.append("Method name is incorrect.");
      this.myCanRefactor=false;
    }
  }
  if (this.myAnalyzeErrors != null) {
    buff.append(this.myAnalyzeErrors);
    this.myCanRefactor=false;
  }
  SNode overrides=this.myParameters.getOverridingMethodClass();
  if (overrides != null && !(this.myExtractIntoOuterContainer)) {
    if ((overrides == SNodeOperations.getNodeAncestor(this.myParameters.getContainerMethod(),MetaAdapterFactory.getConcept(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0x101d9d3ca30L,"jetbrains.mps.baseLanguage.structure.Classifier"),false,false))) {
      buff.append("Such method already exists.\n");
    }
 else {
      buff.append("Method overrides method from class ").append(SPropertyOperations.getString(overrides,MetaAdapterFactory.getProperty(0xceab519525ea4f22L,0x9b92103b95ca8c0cL,0x110396eaaa4L,0x110396ec041L,"name"))).append("\n");
    }
    this.myCanRefactor=false;
  }
  if (buff.length() == 0) {
    buff.append("\n");
  }
  return buff.toString();
}
