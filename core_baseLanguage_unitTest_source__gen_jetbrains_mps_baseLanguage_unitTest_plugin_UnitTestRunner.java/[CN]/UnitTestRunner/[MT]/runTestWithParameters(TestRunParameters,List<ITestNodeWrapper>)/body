{
  final List<String> params=ListSequence.<String>fromList(new ArrayList<String>());
  final Wrappers._T<String> workingDir=new Wrappers._T<String>(null);
  final Wrappers._T<String> programParams=new Wrappers._T<String>(null);
  final Wrappers._T<String> vmParams=new Wrappers._T<String>(null);
  final Wrappers._T<String> classpathString=new Wrappers._T<String>();
  final Wrappers._T<List<String>> testsCommandLine=new Wrappers._T<List<String>>();
  final Wrappers._long testCommandLineLength=new Wrappers._long(0);
  ModelAccess.instance().runReadAction(new Runnable(){
    public void run(){
      if (UnitTestRunner.this.myRunParameters != null) {
        workingDir.value=UnitTestRunner.this.myRunParameters.getWorkingDirectory();
        programParams.value=UnitTestRunner.this.myRunParameters.getProgramParameters();
        vmParams.value=UnitTestRunner.this.myRunParameters.getVMParameters();
      }
      UnitTestRunner.this.addJavaCommand(params);
      ListSequence.<String>fromList(params).addSequence(ListSequence.<String>fromList(parameters.getVmParameters()));
      if (vmParams.value != null && StringUtils.isNotEmpty(vmParams.value)) {
        String[] paramList=UnitTestRunner.this.splitParams(vmParams.value);
        ListSequence.<String>fromList(params).addSequence(Sequence.<String>fromIterable(Sequence.fromArray(paramList)));
      }
      classpathString.value=UnitTestRunner.this.getClasspathString(tests,parameters.getClassPath());
      UnitTestRunner.this.addClassPath(params,classpathString.value);
      ListSequence.<String>fromList(params).addElement(parameters.getTestRunner());
      testsCommandLine.value=ListSequence.<String>fromList(new ArrayList<String>(ListSequence.<ITestNodeWrapper>fromList(tests).count()));
      for (      ITestNodeWrapper test : ListSequence.<ITestNodeWrapper>fromList(tests)) {
        List<String> parametersPart=ListSequence.<String>fromListAndArray(new ArrayList<String>(),(test.isTestCase() ? "-c" : "-m"),test.getFqName());
        testCommandLineLength.value=ListSequence.<String>fromList(parametersPart).foldLeft(testCommandLineLength.value,new ILeftCombinator<String,Long>(){
          public Long combine(          Long s,          String it){
            return s + it.length();
          }
        }
);
        ListSequence.<String>fromList(testsCommandLine.value).addSequence(ListSequence.<String>fromList(parametersPart));
      }
    }
  }
);
  if (classpathString.value.length() + testCommandLineLength.value < MAX_COMMAND_LINE) {
    ListSequence.<String>fromList(params).addSequence(ListSequence.<String>fromList(testsCommandLine.value));
  }
 else {
    File tmpFile=FileUtil.createTmpFile();
    tmpFile.deleteOnExit();
    try {
      PrintWriter writer=new PrintWriter(tmpFile);
      for (      String commandLinePiece : ListSequence.<String>fromList(testsCommandLine.value)) {
        writer.append(commandLinePiece);
        writer.append("\n");
      }
      writer.flush();
      writer.close();
      ListSequence.<String>fromList(params).addElement("-f");
      ListSequence.<String>fromList(params).addElement(tmpFile.getAbsolutePath());
    }
 catch (    FileNotFoundException e) {
      throw new ProcessNotCreatedException("Could not output run parameters to file " + tmpFile,this.getCommandLine(this.myRunParameters.getWorkingDirectory()));
    }
  }
  if (programParams.value != null && StringUtils.isNotEmpty(programParams.value)) {
    String[] paramList=this.splitParams(programParams.value);
    ListSequence.<String>fromList(params).addSequence(Sequence.<String>fromIterable(Sequence.fromArray(paramList)));
  }
  this.myProcessBuilder=new ProcessBuilder(params);
  if (workingDir.value != null && StringUtils.isNotEmpty(workingDir.value)) {
    this.myProcessBuilder.directory(new File(workingDir.value));
  }
  try {
    return this.myProcessBuilder.start();
  }
 catch (  Throwable e) {
    LOG.error("Can't run tests: " + e.getMessage(),e);
    throw new ProcessNotCreatedException(e.getMessage(),e,this.getCommandLine(this.myRunParameters.getWorkingDirectory()));
  }
}
