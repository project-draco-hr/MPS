{
  final List<String> params=ListSequence.<String>fromArray();
  this.addJavaCommand(params);
  if (this.unitTestPreferences.getStateObject().useDebug) {
    this.addDebug(params,this.unitTestPreferences.getStateObject().debugPort,false);
  }
  ListSequence.fromList(params).addSequence(ListSequence.fromList(parameters.getVmParameters()));
  ModelAccess.instance().runReadAction(new Runnable(){
    public void run(){
      UnitTestRunner.this.addClassPath(params,UnitTestRunner.this.getClasspathString(ListSequence.fromList(tests).first(),parameters.getCalssPath()));
    }
  }
);
  ListSequence.fromList(params).addElement(parameters.getTestRunner());
  ModelAccess.instance().runReadAction(new Runnable(){
    public void run(){
      for (      SNode test : ListSequence.fromList(tests)) {
        ListSequence.fromList(params).addSequence(ListSequence.fromList(ITestable_Behavior.call_getParametersPart_1215620460293(test)));
      }
    }
  }
);
  ProcessBuilder p=new ProcessBuilder(params);
  this.myComponent.appendInternal(this.getCommandString(p) + "\n\n");
  try {
    final Process pro=p.start();
    final UnitTestRunOutputReader outReader=new UnitTestRunOutputReader(pro.getInputStream(),this.myComponent,false);
    final UnitTestRunOutputReader errReader=new UnitTestRunOutputReader(pro.getErrorStream(),this.myComponent,true);
    this.myComponent.addCloseListener(new _FunctionTypes._void_P0_E0(){
      public void invoke(){
        outReader.interrupt();
        errReader.interrupt();
        pro.destroy();
      }
    }
);
    CyclicBarrier barrier=new CyclicBarrier(2,outReader.getExecutor());
    outReader.setBarrier(barrier);
    errReader.setBarrier(barrier);
    outReader.start();
    errReader.start();
    pro.waitFor();
  }
 catch (  Exception e) {
    Logger.getLogger(UnitTestRunner.class).error("Can't run tests",e);
  }
}
