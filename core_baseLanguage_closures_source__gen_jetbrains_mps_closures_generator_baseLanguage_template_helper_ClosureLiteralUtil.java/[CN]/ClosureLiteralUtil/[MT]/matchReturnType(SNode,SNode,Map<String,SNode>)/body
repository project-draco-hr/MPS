{
  Set<String> visited=new HashSet<String>();
  LinkedList<SNode> queue=new LinkedList<SNode>();
  queue.addLast(absType);
  while (!(queue.isEmpty())) {
    SNode candidate=queue.removeFirst();
    if (!(visited.contains(BaseConcept_Behavior.call_getPresentation_1180102203531(candidate)))) {
      if (SNodeOperations.isInstanceOf(candidate,"jetbrains.mps.baseLanguage.structure.TypeVariableReference") || (SNodeOperations.getConceptDeclaration(realType) == SNodeOperations.getConceptDeclaration(candidate) && (!(SNodeOperations.isInstanceOf(realType,"jetbrains.mps.baseLanguage.structure.ClassifierType")) || (SLinkOperations.getTarget(realType,"classifier",false) == SLinkOperations.getTarget(candidate,"classifier",false) && SLinkOperations.getCount(realType,"parameter") == SLinkOperations.getCount(candidate,"parameter"))))) {
        map=matchType(candidate,realType,map);
        return map;
      }
      visited.add(BaseConcept_Behavior.call_getPresentation_1180102203531(candidate));
      for (      SNode superType : TypeChecker.getInstance().getSubtypingManager().collectImmediateSupertypes(candidate)) {
        queue.addLast(superType);
      }
    }
  }
  return map;
}
