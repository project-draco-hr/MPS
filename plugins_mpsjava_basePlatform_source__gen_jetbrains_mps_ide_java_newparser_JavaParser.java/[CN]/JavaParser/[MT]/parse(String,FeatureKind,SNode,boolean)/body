{
  boolean stubsMode=FeatureKind.CLASS_STUB.equals(what);
  CodeSnippetParsingUtil util=new CodeSnippetParsingUtil(stubsMode);
  Map<String,String> settings=new HashMap<String,String>();
  settings.put(CompilerOptions.OPTION_Source,CompilerOptions.VERSION_1_6);
  settings.put(CompilerOptions.OPTION_DocCommentSupport,"enabled");
  ASTConverter converter=(FeatureKind.CLASS_STUB.equals(what) ? new ASTConverter(stubsMode) : new FullASTConverter(null));
  List<SNode> resultNodes=new ArrayList<SNode>();
  String resultPackageName=null;
  char[] source=code.toCharArray();
switch (what) {
case CLASS:
case CLASS_STUB:
    CompilationUnitDeclaration compRes=util.parseCompilationUnit(source,settings,true);
  if (compRes == null) {
    return JavaParser.JavaParseResult.UNKNOWN_ERROR;
  }
ASTNode[] astTypes=compRes.types;
if (astTypes != null && astTypes.length > 0) {
List<SNode> roots=new ArrayList<SNode>();
for (ASTNode astNode : astTypes) {
  SNode root=converter.convertRoot(astNode);
  annotateWithmports(compRes,root);
  ListSequence.fromList(roots).addElement(root);
}
resultNodes=roots;
}
attachComments(source,converter,util.recordedParsingInformation);
if (compRes.currentPackage != null) {
StringBuffer sb=new StringBuffer();
compRes.currentPackage.print(0,sb,false);
resultPackageName=sb.toString();
}
break;
case CLASS_CONTENT:
ASTNode[] astNodes=util.parseClassBodyDeclarations(source,0,source.length,settings,true,recovery);
if (astNodes != null && astNodes.length > 0) {
resultNodes=converter.convertClassContents(astNodes,context);
}
attachComments(source,converter,util.recordedParsingInformation);
break;
case STATEMENTS:
AbstractMethodDeclaration absMethod=util.parseStatements(source,settings,true,recovery);
if (absMethod == null) {
return JavaParser.JavaParseResult.UNKNOWN_ERROR;
}
Statement[] stmts=absMethod.statements;
if (stmts != null && stmts.length > 0) {
SNode stmtList=SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(new UUID(-935030926396207931l,-6610165693999523818l),1068580123136l,"jetbrains.mps.baseLanguage.structure.StatementList"));
((FullASTConverter)converter).convertStatementsInto(absMethod,stmtList);
attachComments(source,converter,util.recordedParsingInformation);
resultNodes=ListSequence.fromList(new ArrayList<SNode>());
for (SNode stmt : ListSequence.fromList(SLinkOperations.getChildren(stmtList,MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l,-6610165693999523818l),1068580123136l,1068581517665l,"statement")))) {
SNodeOperations.deleteNode(stmt);
ListSequence.fromList(resultNodes).addElement(stmt);
}
}
break;
default :
throw new IllegalArgumentException("Parsing other than class and statements is not supported yet ");
}
return new JavaParser.JavaParseResult(resultNodes,resultPackageName,problemDescription(util.recordedParsingInformation));
}
