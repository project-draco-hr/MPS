{
  boolean stubsMode=FeatureKind.CLASS_STUB.equals(what);
  CodeSnippetParsingUtil util=new CodeSnippetParsingUtil(stubsMode);
  Map<String,String> settings=new HashMap<String,String>();
  settings.put(CompilerOptions.OPTION_Source,CompilerOptions.VERSION_1_8);
  settings.put(CompilerOptions.OPTION_DocCommentSupport,"enabled");
  ASTConverter converter=(FeatureKind.CLASS_STUB.equals(what) ? new ASTConverterWithExpressions(stubsMode) : new FullASTConverter(null));
  List<SNode> resultNodes=new ArrayList<SNode>();
  String resultPackageName=null;
  char[] source=code.toCharArray();
switch (what) {
case CLASS:
case CLASS_STUB:
    CompilationUnitDeclaration compRes=util.parseCompilationUnit(source,settings,true);
  if (compRes == null) {
    return JavaParser.JavaParseResult.UNKNOWN_ERROR;
  }
ASTNode[] astTypes=compRes.types;
if (astTypes != null && astTypes.length > 0) {
List<SNode> roots=new ArrayList<SNode>();
for (ASTNode astNode : astTypes) {
  SNode root=converter.convertRoot(astNode);
  annotateWithmports(compRes,root);
  ListSequence.fromList(roots).addElement(root);
}
resultNodes=roots;
}
attachComments(source,converter,util.recordedParsingInformation);
if (compRes.currentPackage != null) {
StringBuffer sb=new StringBuffer();
compRes.currentPackage.print(0,sb,false);
resultPackageName=sb.toString();
}
break;
case CLASS_CONTENT:
ASTNode[] astNodes=util.parseClassBodyDeclarations(source,0,source.length,settings,true,recovery);
if (astNodes != null && astNodes.length > 0) {
resultNodes=converter.convertClassContents(astNodes,context);
}
attachComments(source,converter,util.recordedParsingInformation);
break;
case STATEMENTS:
AbstractMethodDeclaration absMethod=util.parseStatements(source,settings,true,recovery);
if (absMethod == null) {
return JavaParser.JavaParseResult.UNKNOWN_ERROR;
}
Statement[] stmts=absMethod.statements;
if (stmts != null && stmts.length > 0) {
SNode stmtList=SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0xf8cc56b200L,"jetbrains.mps.baseLanguage.structure.StatementList")));
((FullASTConverter)converter).convertStatementsInto(absMethod,stmtList);
attachComments(source,converter,util.recordedParsingInformation);
resultNodes=ListSequence.fromList(new ArrayList<SNode>());
for (SNode stmt : ListSequence.fromList(SLinkOperations.getChildren(stmtList,MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0xf8cc56b200L,0xf8cc6bf961L,"statement")))) {
SNodeOperations.deleteNode(stmt);
ListSequence.fromList(resultNodes).addElement(stmt);
}
}
break;
default :
throw new IllegalArgumentException("Parsing other than class and statements is not supported yet ");
}
return new JavaParser.JavaParseResult(resultNodes,resultPackageName,problemDescription(util.recordedParsingInformation));
}
