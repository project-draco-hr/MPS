{
  char[] content=source;
  int[][] comments=parseInfo.commentPositions;
  int[] lineends=parseInfo.lineEnds;
  final Wrappers._T<Map<SNode,Integer>> positions=new Wrappers._T<Map<SNode,Integer>>(MapSequence.fromMap(new HashMap<SNode,Integer>()));
  Iterable<FullASTConverter.CodeBlock> blocks=ListSequence.fromList(new ArrayList<FullASTConverter.CodeBlock>());
  Map<Integer,SNode> javadocs=converter.getJavadocs();
  if (converter instanceof FullASTConverter) {
    blocks=((FullASTConverter)converter).getCodeBlocks();
    positions.value=((FullASTConverter)converter).getPositions();
  }
  Iterable<FullASTConverter.CodeBlock> blcks=Sequence.fromIterable(blocks).sort(new Comparator<FullASTConverter.CodeBlock>(){
    public int compare(    FullASTConverter.CodeBlock a,    FullASTConverter.CodeBlock b){
      return a.getEndPos() - b.getEndPos();
    }
  }
,true);
  for (  int[] comment : comments) {
    if (comment[1] > 0) {
      SNode doc=MapSequence.fromMap(javadocs).get(comment[0]);
      List<String> lines=CommentHelper.processJavadoc(CommentHelper.splitString(content,lineends,comment[0],comment[1] + 1));
      for (      String text : ListSequence.fromList(lines)) {
        SNode commentLine=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.javadoc.structure.CommentLine",null);
        SPropertyOperations.set(SNodeOperations.cast(ListSequence.fromList(SLinkOperations.getTargets(commentLine,"part",true)).getElement(0),"jetbrains.mps.baseLanguage.javadoc.structure.TextCommentLinePart"),"text",text);
        ListSequence.fromList(SLinkOperations.getTargets(doc,"body",true)).addElement(commentLine);
      }
      continue;
    }
    final int linestart=Math.abs(comment[0]);
    SNode block=null;
    for (    FullASTConverter.CodeBlock blk : Sequence.fromIterable(blcks)) {
      if (blk.getStartPos() <= linestart && linestart <= blk.getEndPos()) {
        block=blk.getStatementList();
        break;
      }
    }
    if ((block != null)) {
      int pos=ListSequence.fromList(SLinkOperations.getTargets(block,"statement",true)).where(new IWhereFilter<SNode>(){
        public boolean accept(        SNode it){
          return !(MapSequence.fromMap(positions.value).containsKey(it)) || Math.abs(MapSequence.fromMap(positions.value).get(it)) <= linestart;
        }
      }
).count();
      for (      String line : ListSequence.fromList(CommentHelper.processComment(CommentHelper.splitString(content,lineends,linestart,Math.abs(comment[1]))))) {
        String line_=line;
        if (line.startsWith(" ")) {
          line_=line.substring(1);
        }
        SNode commentText=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TextCommentPart",null);
        SPropertyOperations.set(commentText,"text",line_);
        SNode commentLine=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.SingleLineComment",null);
        ListSequence.fromList(SLinkOperations.getTargets(commentLine,"commentPart",true)).addElement(commentText);
        ListSequence.fromList(SLinkOperations.getTargets(block,"statement",true)).insertElement(pos++,commentLine);
      }
    }
 else {
      LOG.warn("cannot find a place to import comment from " + "<Main type name>" + ":\n"+ new String(content,linestart,Math.abs(comment[1]) - linestart));
    }
  }
}
