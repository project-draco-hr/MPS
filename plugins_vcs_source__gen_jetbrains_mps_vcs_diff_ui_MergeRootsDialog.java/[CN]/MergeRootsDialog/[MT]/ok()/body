{
  List<ModelChange> changes=ListSequence.fromList(myMergeContext.getChangesForRoot(myRootId)).where(new IWhereFilter<ModelChange>(){
    public boolean accept(    ModelChange ch){
      return !(myMergeContext.isChangeResolved(ch));
    }
  }
).toListSequence();
  Iterable<ModelChange> conflictedChanges=ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>(){
    public boolean accept(    ModelChange ch){
      return Sequence.fromIterable(myMergeContext.getConflictedWith(ch)).isNotEmpty();
    }
  }
);
  if (Sequence.fromIterable(conflictedChanges).isNotEmpty()) {
    if (Messages.showYesNoDialog(this,String.format("You have %s left. You should resolve them manually.\n" + "Are you sure want to close merge roots dialog without resolving them?",NameUtil.formatNumericalString(Sequence.fromIterable(conflictedChanges).count(),"unresolved conflicting changes")),"Unresolved Conflicting Changes",Messages.getWarningIcon()) != 0) {
      return;
    }
  }
 else   if (ListSequence.fromList(changes).isNotEmpty()) {
    int answer=Messages.showYesNoCancelDialog(this,String.format("You have %s left. Do you want to resolve them automatically?",NameUtil.formatNumericalString(ListSequence.fromList(changes).count(),"unresolved changes")),"Unresolved Changes",Messages.getQuestionIcon());
    if (answer == 0) {
      ModelAccess.instance().runWriteActionInCommand(new Runnable(){
        public void run(){
          myMergeContext.applyAllNonConflictingChanges(myRootId);
          myStateToRestore=null;
          dispose();
        }
      }
);
      return;
    }
 else     if (answer == 1) {
    }
 else {
      return;
    }
  }
  myStateToRestore=null;
  dispose();
}
