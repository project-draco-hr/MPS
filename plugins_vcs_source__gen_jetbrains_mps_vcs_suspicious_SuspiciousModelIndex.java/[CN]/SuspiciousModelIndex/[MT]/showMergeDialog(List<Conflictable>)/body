{
  final Map<Project,List<VirtualFile>> toMerge=new HashMap<Project,List<VirtualFile>>();
  Map<VirtualFile,Conflictable> fileToConflictable=new LinkedHashMap<VirtualFile,Conflictable>();
  Set<Conflictable> toReload=new HashSet<Conflictable>();
  for (  Conflictable conflictable : conflictableList) {
    IFile ifile=conflictable.getFile();
    if (isInConflict(ifile)) {
      VirtualFile vfile=VirtualFileUtils.getVirtualFile(ifile);
      Conflictable prev=fileToConflictable.put(vfile,conflictable);
      if (prev == null) {
        Project project=getProjectForFile(vfile);
        List<VirtualFile> files=toMerge.get(project);
        if (files == null) {
          files=new LinkedList<VirtualFile>();
          toMerge.put(project,files);
        }
        files.add(vfile);
      }
    }
 else     if (conflictable.isConflictDetected() || conflictable.needReloading()) {
      toReload.add(conflictable);
    }
  }
  ModelChangesWatcher.instance().suspendTasksProcessing();
  for (  final Project project : toMerge.keySet()) {
    final List<VirtualFile> virtualFileList=new ArrayList<VirtualFile>();
    ApplicationManager.getApplication().invokeAndWait(new Runnable(){
      public void run(){
        virtualFileList.addAll(AbstractVcsHelper.getInstance(project).showMergeDialog(toMerge.get(project)));
      }
    }
,ModalityState.defaultModalityState());
    for (    VirtualFile vfile : virtualFileList) {
      Conflictable conflictable=fileToConflictable.get(vfile);
      if (conflictable != null) {
        toReload.add(conflictable);
      }
    }
  }
  return toReload;
}
