{
  final Map<Project,List<VirtualFile>> toMerge=new HashMap<Project,List<VirtualFile>>();
  final Map<VirtualFile,Conflictable> fileToConflictable=new LinkedHashMap<VirtualFile,Conflictable>();
  final Set<Conflictable> toReload=new HashSet<Conflictable>();
  ListSequence.fromList(tasks).visitAll(new IVisitor<Conflictable>(){
    public void visit(    Conflictable it){
      IFile ifile=it.getFile();
      if (isInConflict(ifile)) {
        VirtualFile vfile=VirtualFileUtils.getVirtualFile(ifile);
        Conflictable prev=fileToConflictable.put(vfile,it);
        if (prev != null) {
          return;
        }
        Project project=getProjectForFile(vfile);
        List<VirtualFile> files=toMerge.get(project);
        if (files == null) {
          files=new LinkedList<VirtualFile>();
          toMerge.put(project,files);
        }
        files.add(vfile);
      }
 else       if (it.isConflictDetected() || it.needReloading()) {
        toReload.add(it);
      }
    }
  }
);
  final Computable<Object> conflictableReload=new Computable<Object>(){
    public Object compute(){
      ModelAccess.instance().runWriteActionInCommand(new Runnable(){
        public void run(){
          MPSModuleRepository.getInstance().saveAll();
        }
      }
);
      for (      final Project project : toMerge.keySet()) {
        List<VirtualFile> virtualFileList=new ArrayList<VirtualFile>();
        virtualFileList.addAll(AbstractVcsHelper.getInstance(project).showMergeDialog(toMerge.get(project)));
        for (        VirtualFile vfile : virtualFileList) {
          Conflictable conflictable=fileToConflictable.get(vfile);
          if (conflictable != null) {
            toReload.add(conflictable);
          }
        }
      }
      ModelAccess.instance().runWriteActionInCommand(new Runnable(){
        public void run(){
          for (          Conflictable conflictable : toReload) {
            conflictable.reloadFromDisk();
          }
        }
      }
);
      return null;
    }
  }
;
  ApplicationManager.getApplication().invokeLater(new Runnable(){
    public void run(){
      myReloadManager.computeNoReload(conflictableReload);
      return;
    }
  }
,ModalityState.defaultModalityState());
}
