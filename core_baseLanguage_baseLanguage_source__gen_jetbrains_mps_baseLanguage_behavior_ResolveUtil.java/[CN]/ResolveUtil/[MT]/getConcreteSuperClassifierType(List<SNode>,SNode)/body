{
  SNode concreteMethodClassifierType=null;
  Collections.reverse(frontier);
  while (!(ListSequence.fromList(frontier).isEmpty())) {
    SNode currentType=ListSequence.fromList(frontier).removeElementAt(0);
    SNode currentClassifier=SLinkOperations.getTarget(currentType,"classifier",false);
    if (currentClassifier == classifier) {
      concreteMethodClassifierType=currentType;
      break;
    }
    if (SNodeOperations.isInstanceOf(currentClassifier,"jetbrains.mps.baseLanguage.structure.ClassConcept")) {
      SNode classConcept=SNodeOperations.cast(currentClassifier,"jetbrains.mps.baseLanguage.structure.ClassConcept");
      SNode superclass=SLinkOperations.getTarget(classConcept,"superclass",true);
      if ((superclass != null)) {
        ListSequence.fromList(frontier).addElement(getConcreteClassifierType(superclass,currentType));
      }
      for (      SNode intfc : SLinkOperations.getTargets(classConcept,"implementedInterface",true)) {
        ListSequence.fromList(frontier).addElement(getConcreteClassifierType(intfc,currentType));
      }
    }
    if (SNodeOperations.isInstanceOf(currentClassifier,"jetbrains.mps.baseLanguage.structure.Interface")) {
      SNode interfaceConcept=SNodeOperations.cast(currentClassifier,"jetbrains.mps.baseLanguage.structure.Interface");
      for (      SNode intfc : SLinkOperations.getTargets(interfaceConcept,"extendedInterface",true)) {
        ListSequence.fromList(frontier).addElement(getConcreteClassifierType(intfc,currentType));
      }
    }
  }
  return concreteMethodClassifierType;
}
