{
  ModelChange.assertLegalNodeChange(this);
  propertyValue=InternUtil.intern(propertyValue);
  if (usePropertySetter) {
    if ((myPropertySettersInProgress == null || !myPropertySettersInProgress.contains(propertyName)) && !myModel.isLoading()) {
      INodePropertySetter setter=ModelConstraintsManager.getInstance().getNodePropertySetter(this,propertyName);
      if (setter != null) {
        myPropertySettersInProgress=new HashSet<String>(1);
        myPropertySettersInProgress.add(propertyName);
        try {
          setter.execPropertySet(this,propertyName,propertyValue,GlobalScope.getInstance());
          return;
        }
  finally {
          myPropertySettersInProgress.remove(propertyName);
        }
      }
    }
  }
  if (myProperties == null) {
    myProperties=new LinkedHashMap<String,String>(1);
  }
  final String oldValue=myProperties.get(propertyName);
  if (propertyValue == null) {
    myProperties.remove(propertyName);
  }
 else {
    myProperties.put(propertyName,propertyValue);
  }
  if (ModelChange.needRegisterUndo(getModel())) {
    final String pv=propertyValue;
    UndoManager.instance().undoableActionPerformed(new NodeUndoableAction(){
      public void undo() throws UnexpectedUndoException {
        setProperty(propertyName,oldValue);
      }
      public String toString(){
        return "set property " + propertyName + " in "+ SNode.this+ " to "+ pv;
      }
    }
);
  }
  if (ModelChange.needFireEvents(getModel(),this)) {
    boolean addedOrRemoved=false;
    boolean isRemoved=false;
    if (SModelUtil_new.isEmptyPropertyValue(oldValue)) {
      addedOrRemoved=true;
      isRemoved=false;
    }
    if (SModelUtil_new.isEmptyPropertyValue(propertyValue)) {
      addedOrRemoved=true;
      isRemoved=true;
    }
    getModel().firePropertyChangedEvent(this,propertyName,oldValue,propertyValue,addedOrRemoved,isRemoved);
  }
}
