{
  propertyName=InternUtil.intern(propertyName);
  ModelChange.assertLegalNodeChange(this);
  propertyValue=InternUtil.intern(propertyValue);
  if (usePropertySetter) {
    if (!ourPropertySettersInProgress.contains(new Pair<SNode,String>(this,propertyName)) && !myModel.isLoading()) {
      INodePropertySetter setter=CONSTRAINTS_MANAGER.getNodePropertySetter(this,propertyName);
      if (setter != null) {
        ourPropertySettersInProgress=new HashSet<Pair<SNode,String>>(1);
        ourPropertySettersInProgress.add(new Pair<SNode,String>(this,propertyName));
        try {
          setter.execPropertySet(this,propertyName,propertyValue,GlobalScope.getInstance());
          return;
        }
 catch (        Throwable t) {
          LOG.error(t);
        }
 finally {
          ourPropertySettersInProgress.remove(new Pair<SNode,String>(this,propertyName));
        }
      }
    }
  }
  if (myProperties == null) {
    myProperties=new ListMap<String,String>();
  }
  if (ourMemberAccessModifier != null) {
    propertyName=ourMemberAccessModifier.getNewPropertyName(myModel,myConceptFqName,propertyName);
  }
  final String propertyName_=propertyName;
  final String oldValue=myProperties.get(propertyName_);
  if (propertyValue == null) {
    myProperties.remove(propertyName_);
  }
 else {
    myProperties.put(propertyName_,propertyValue);
  }
  if (ModelChange.needRegisterUndo(getModel())) {
    UndoUtil.addUndoableAction(new PropertyChangeUndoableAction(this,propertyName,oldValue,propertyValue));
  }
  if (ModelChange.needFireEvents(getModel(),this)) {
    boolean addedOrRemoved=false;
    boolean isRemoved=false;
    if (SModelUtil_new.isEmptyPropertyValue(oldValue)) {
      addedOrRemoved=true;
      isRemoved=false;
    }
    if (SModelUtil_new.isEmptyPropertyValue(propertyValue)) {
      addedOrRemoved=true;
      isRemoved=true;
    }
    getModel().firePropertyChangedEvent(this,propertyName_,oldValue,propertyValue);
  }
}
