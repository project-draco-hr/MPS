{
  assertCanChange();
  if (ourMemberAccessModifier != null) {
    role=ourMemberAccessModifier.getNewChildRole(getModel(),myConceptFqName,role);
  }
  final SNode schild=(SNode)child;
  SNode parentOfChild=schild.getParent();
  if (parentOfChild != null) {
    throw new RuntimeException(org.jetbrains.mps.openapi.model.SNodeUtil.getDebugText(schild) + " already has parent: " + org.jetbrains.mps.openapi.model.SNodeUtil.getDebugText(parentOfChild)+ "\n"+ "Couldn't add it to: "+ org.jetbrains.mps.openapi.model.SNodeUtil.getDebugText(this));
  }
  if (getTopmostAncestor() == child) {
    throw new RuntimeException("Trying to create a cyclic tree");
  }
  if (anchor != null) {
    if (anchor.getParent() != this) {
      throw new RuntimeException("anchor is not a child of this node" + " | " + "this: " + org.jetbrains.mps.openapi.model.SNodeUtil.getDebugText(this) + " | "+ "anchor: "+ org.jetbrains.mps.openapi.model.SNodeUtil.getDebugText(anchor));
    }
  }
  children_insertBefore(((SNode)anchor),schild);
  schild.setRoleInParent(role);
  UnregisteredNodes un=UnregisteredNodes.instance();
  if (un.contains(child) && myModelForUndo == null && !un.contains(this)) {
    startUndoTracking(getTopmostAncestor(),((SNode)child).myRepository);
  }
  if (myModel == null) {
    if (schild.myModel != null) {
      schild.clearModel();
    }
  }
 else {
    schild.registerInModel(myModel);
  }
  final String finalRole=role;
  performUndoableAction(new Computable<SNodeUndoableAction>(){
    @Override public SNodeUndoableAction compute(){
      return new InsertChildAtUndoableAction(SNode.this,anchor,finalRole,schild);
    }
  }
);
  if (myModel != null && ModelChange.needFireEvents(getModel(),this)) {
    myModel.fireChildAddedEvent(this,role,schild,((SNode)anchor));
  }
  nodeAdded(role,child);
}
