{
  Set<EditorMessage> messages=SetSequence.fromSet(new LinkedHashSet<EditorMessage>());
  if (SNodeOperations.getModel(rootNode) == null || SNodeOperations.getModel(rootNode).getModelDescriptor() == null) {
    return messages;
  }
  if (SNodeOperations.getModel(rootNode).isTransient()) {
    return messages;
  }
  boolean autoresolve=!(hasUnresolvedImportedModels(SNodeOperations.getModel(rootNode),editorContext));
  if (!(autoresolve)) {
    SetSequence.fromSet(messages).addElement(HighlightUtil.createWarningMessage(rootNode,"Containing model has unresolved model imports. Automatic refrence resolving is switched off to avoid incorrect reference target resolving.",this));
  }
  final Set<SReference> badReferences=collectBadReferences(rootNode);
  for (  SReference ref : SetSequence.fromSet(badReferences)) {
    EditorMessage message=HighlightUtil.createHighlighterMessage(ref.getSourceNode(),"Unresolved reference",this,editorContext);
    SetSequence.fromSet(messages).addElement(message);
  }
  if (autoresolve) {
    final IOperationContext operationContext=editorContext.getOperationContext();
    if (operationContext != null) {
      ModelAccess.instance().runWriteInEDT(new Runnable(){
        public void run(){
          ModelAccess.instance().runUndoTransparentCommand(new Runnable(){
            public void run(){
              TypeContextManager.getInstance().setComputeInNormalMode(true);
              ResolverComponent.getInstance().resolveScopesOnly(badReferences,operationContext);
              TypeContextManager.getInstance().setComputeInNormalMode(false);
            }
          }
,operationContext.getProject());
        }
      }
);
    }
  }
  return messages;
}
