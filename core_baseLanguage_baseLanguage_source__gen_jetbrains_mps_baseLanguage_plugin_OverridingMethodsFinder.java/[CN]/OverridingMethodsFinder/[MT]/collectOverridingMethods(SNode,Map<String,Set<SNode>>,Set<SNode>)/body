{
  Map<String,Set<SNode>> methodNameToMethodMapCopy=MapSequence.<String,Set<SNode>>fromMap(new HashMap<String,Set<SNode>>());
  for (  String methodName : SetSequence.<String>fromSet(MapSequence.fromMap(nameToMethodsMap).keySet())) {
    SetSequence.fromSet(safeGet(methodNameToMethodMapCopy,methodName)).addSequence(SetSequence.<SNode>fromSet(MapSequence.<String,Set<SNode>>fromMap(nameToMethodsMap).get(methodName)));
  }
  for (  final SNode classifierMethod : ListSequence.<SNode>fromList(SLinkOperations.getTargets(classifier,"method",true)).where(new IWhereFilter<SNode>(){
    public boolean accept(    SNode it){
      return canBeOverriden(it);
    }
  }
)) {
    Set<SNode> similarMethods=MapSequence.<String,Set<SNode>>fromMap(methodNameToMethodMapCopy).get(SPropertyOperations.getString(classifierMethod,"name"));
    if (similarMethods == null) {
      continue;
    }
    List<SNode> overridingMethods=new ArrayList<SNode>();
    for (    SNode overridingMethod : SetSequence.<SNode>fromSet(similarMethods).where(new IWhereFilter<SNode>(){
      public boolean accept(      SNode it){
        return BaseMethodDeclaration_Behavior.call_hasSameSignature_1213877350435(classifierMethod,it);
      }
    }
)) {
      SetSequence.fromSet(safeGet(this.myOverridingToOverridenMethodsMap,overridingMethod)).addElement(MultiTuple.<SNode,SNode>from(classifierMethod,classifier));
      ListSequence.<SNode>fromList(overridingMethods).addElement(overridingMethod);
    }
    SetSequence.fromSet(similarMethods).removeSequence(ListSequence.<SNode>fromList(overridingMethods));
    if (SetSequence.<SNode>fromSet(similarMethods).isEmpty()) {
      MapSequence.fromMap(methodNameToMethodMapCopy).removeKey(SPropertyOperations.getString(classifierMethod,"name"));
    }
  }
  if (!(MapSequence.<String,Set<SNode>>fromMap(methodNameToMethodMapCopy).isEmpty())) {
    collectOverridingMethodsInClassifierHierarchy(classifier,methodNameToMethodMapCopy,visitedClassifiers);
  }
}
