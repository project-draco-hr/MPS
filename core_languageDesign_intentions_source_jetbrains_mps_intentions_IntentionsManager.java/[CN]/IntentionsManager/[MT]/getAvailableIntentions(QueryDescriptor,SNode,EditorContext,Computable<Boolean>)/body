{
  Computable<Set<Pair<Intention,SNode>>> computable=new Computable<Set<Pair<Intention,SNode>>>(){
    public Set<Pair<Intention,SNode>> compute(){
      Set<Pair<Intention,SNode>> result=new HashSet<Pair<Intention,SNode>>();
      for (      Intention intention : getAvailableIntentionsForExactNode(node,context,false,query.isInstantiate(),terminated)) {
        result.add(new Pair<Intention,SNode>(intention,node));
      }
      SNode parent=node.getParent();
      while (parent != null) {
        for (        Intention intention : getAvailableIntentionsForExactNode(parent,context,true,query.isInstantiate(),terminated)) {
          result.add(new Pair<Intention,SNode>(intention,parent));
        }
        parent=parent.getParent();
      }
      if (query.getIntentionClass() != null) {
        for (        Pair<Intention,SNode> p : new ArrayList<Pair<Intention,SNode>>(result)) {
          if (!query.getIntentionClass().isAssignableFrom(p.getFirst().getClass())) {
            result.remove(p);
          }
        }
      }
      return result;
    }
  }
;
  try {
    TypeChecker.getInstance().enableGlobalSubtypingCache();
    Set<Pair<Intention,SNode>> intentions=ModelAccess.instance().runReadAction(computable);
    return intentions;
  }
  finally {
    TypeChecker.getInstance().clearGlobalSubtypingCache();
  }
}
