{
  final Map<ProgramState,E> stateValues=new HashMap<ProgramState,E>();
  for (  Instruction i : myProgram.getInstructions()) {
    stateValues.put(new ProgramState(i,false),myAnalyzer.initial(myProgram));
    stateValues.put(new ProgramState(i,true),myAnalyzer.initial(myProgram));
  }
  Queue<ProgramState> workList=new LinkedList<ProgramState>();
  for (  Instruction i : myProgram.getInstructions()) {
    workList.add(new ProgramState(i,false));
    workList.add(new ProgramState(i,true));
  }
  AnalysisDirection direction=myAnalyzer.getDirection();
  while (!workList.isEmpty()) {
    ProgramState current=workList.remove();
    Set<E> input=new HashSet<E>();
    for (    ProgramState s : direction.dependencies(current)) {
      if (stateValues.containsKey(s)) {
        input.add(stateValues.get(s));
      }
    }
    E oldValue=stateValues.get(current);
    E mergedValue=myAnalyzer.merge(myProgram,input);
    E newValue=myAnalyzer.fun(mergedValue,current);
    if (!newValue.equals(oldValue)) {
      stateValues.put(current,newValue);
      for (      ProgramState s : direction.dependents(current)) {
        workList.add(s);
      }
    }
  }
  return stateValues;
}
