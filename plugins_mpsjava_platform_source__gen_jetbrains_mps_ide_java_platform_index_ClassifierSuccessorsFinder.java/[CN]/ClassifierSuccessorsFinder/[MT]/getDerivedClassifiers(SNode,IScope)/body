{
  Set<VirtualFile> unModifiedModelFiles=SetSequence.fromSet(new HashSet<VirtualFile>());
  List<SNode> modifiedClasses=ListSequence.fromList(new ArrayList<SNode>());
  List<SNode> modifiedInterfaces=ListSequence.fromList(new ArrayList<SNode>());
  for (  SModelDescriptor md : scope.getModelDescriptors()) {
    if (!((md instanceof DefaultSModelDescriptor))) {
      continue;
    }
    DefaultSModelDescriptor emd=(DefaultSModelDescriptor)md;
    IFile modelFile=emd.getModelFile();
    if (modelFile == null) {
      continue;
    }
    if (emd.isChanged()) {
      SModel m=md.getSModel();
      ListSequence.fromList(modifiedClasses).addSequence(ListSequence.fromList(SModelOperations.getNodes(m,"jetbrains.mps.baseLanguage.structure.ClassConcept")));
      ListSequence.fromList(modifiedInterfaces).addSequence(ListSequence.fromList(SModelOperations.getNodes(m,"jetbrains.mps.baseLanguage.structure.Interface")));
    }
 else {
      SetSequence.fromSet(unModifiedModelFiles).addElement(VirtualFileUtils.getVirtualFile(modelFile));
    }
  }
  List<SNode> result=new ArrayList<SNode>();
  Queue<SNode> queue=QueueSequence.fromQueue(new LinkedList<SNode>());
  QueueSequence.fromQueue(queue).addLastElement(classifier);
  ClassifierSuccessorsFinder.ValueProcessor valueProcessor=new ClassifierSuccessorsFinder.ValueProcessor(result,queue);
  ClassifierSuccessorsFinder.ModifiedsuccessorFinder modifiedSuccessorFinder=new ClassifierSuccessorsFinder.ModifiedsuccessorFinder(modifiedClasses,modifiedInterfaces,result,queue);
  ClassifierSuccessorsFinder.SearchScope unModifiedFilesSearchScope=new ClassifierSuccessorsFinder.SearchScope(unModifiedModelFiles);
  while (!(QueueSequence.fromQueue(queue).isEmpty())) {
    SNode nextClassifier=QueueSequence.fromQueue(queue).removeFirstElement();
    FileBasedIndex.getInstance().processValues(ClassifierSuccessorsIndexer.NAME,new GlobalSNodeId(nextClassifier),null,valueProcessor,unModifiedFilesSearchScope);
    modifiedSuccessorFinder.process(nextClassifier);
  }
  return result;
}
