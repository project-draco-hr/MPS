{
  myTimer.suspend();
  int batchProcessMax=20;
  final ArrayList<Pair<MPSTreeNode,NodeUpdate>> updates=new ArrayList<Pair<MPSTreeNode,NodeUpdate>>(batchProcessMax);
  Pair<MPSTreeNode,NodeUpdate> u;
  while ((u=myUpdates.poll()) != null && --batchProcessMax >= 0) {
    updates.add(u);
  }
  if (!myUpdates.isEmpty()) {
    myTimer.resume();
  }
  if (updates.isEmpty()) {
    return;
  }
  ModelAccess.instance().runReadInEDT(new Runnable(){
    @Override public void run(){
      for (      Pair<MPSTreeNode,NodeUpdate> update : updates) {
        MPSTreeNode node=update.o1;
        if (!checkDisposed(node))         return;
        update.o2.update(node);
        node.updateNodePresentationInTree();
      }
    }
  }
);
}
