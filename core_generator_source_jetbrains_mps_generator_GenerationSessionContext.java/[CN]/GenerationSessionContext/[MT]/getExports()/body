{
  if (myExportsVault == null) {
    final ModelStreamManager streamManager=myEnvironment.getStreamProvider().getStreamManager(getOriginalInputModel());
    /** 
 * Adapts MultiStreamDataSource to StreamDataSource (picks one stream).
 */
class SingleStreamSource extends DataSourceBase implements StreamDataSource {
      private final MultiStreamDataSource myDataSource;
      private final String myStreamName;
      public SingleStreamSource(      @NotNull MultiStreamDataSource streamDataSource,      @NotNull String name){
        myDataSource=streamDataSource;
        myStreamName=name;
      }
      @Override public InputStream openInputStream() throws IOException {
        return myDataSource.openInputStream(myStreamName);
      }
      @Override public OutputStream openOutputStream() throws IOException {
        return myDataSource.openOutputStream(myStreamName);
      }
    }
    ;
    final ModelFactory modelFactory=PersistenceRegistry.getInstance().getDefaultModelFactory();
    SModel exportsModel;
    final SingleStreamSource source=new SingleStreamSource(streamManager.getOutputLocation(),"exports");
    try {
      if (IterableUtil.asSet(streamManager.getOutputLocation().getAvailableStreams()).contains("exports")) {
        exportsModel=modelFactory.load(source,Collections.<String,String>emptyMap());
      }
 else {
        exportsModel=modelFactory.create(source,Collections.singletonMap(ModelFactory.OPTION_MODELNAME,getOriginalInputModel().getModelName()));
      }
    }
 catch (    IOException ex) {
      throw new IllegalStateException("Could not create model to keep cross-model exports",ex);
    }
    myExportsVault=new ExportsVault(this,exportsModel);
  }
  return myExportsVault;
}
