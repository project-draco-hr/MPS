{
  MPSModuleRepository.getInstance().removeTransientModules();
  showMessageView();
  invocationContext.getProject().saveModels();
  List<SModelDescriptor> sourceModels=new ArrayList<SModelDescriptor>();
  for (  SModel model : _sourceModels) {
    sourceModels.add(model.getModelDescriptor());
  }
  clearMessages();
  handler.handle(new Message(MessageKind.INFORMATION,generationType.getStartText()));
  handler.handle(new Message(MessageKind.INFORMATION,"    target language: \"" + targetLanguage.getNamespace() + "\""));
  String outputFolder=invocationContext.getModule().getGeneratorOutputPath();
  if (!new File(outputFolder).exists()) {
    new File(outputFolder).mkdirs();
    try {
      myProject.getProjectHandler().addSourceRoot(outputFolder);
    }
 catch (    Exception e) {
      handler.handle(new Message(MessageKind.WARNING,"Can't add output folder to IDEA as sources"));
    }
  }
  handler.handle(new Message(MessageKind.INFORMATION,"    target root folder: \"" + outputFolder + "\""));
  boolean ideaPresent=myProject.getProjectHandler() != null;
  boolean compile=myCompileOnGeneration && ideaPresent && generationType.requiresCompilationInIDEAfterGeneration();
  long totalJob=ModelsProgressUtil.estimateTotalGenerationJobMillis(compile,sourceModels);
  progress.startTaskAnyway("generating",null,totalJob);
  try {
    boolean reloadClasses=true;
    if (!myCompileOnGeneration || !generationType.requiresCompilationInIDEABeforeGeneration()) {
      progress.addText("compilation in IntelliJ IDEA on generation is turned off or not needed");
      reloadClasses=false;
    }
 else     if (!ideaPresent) {
      progress.addText("IntelliJ IDEA with installed MPS is not present");
    }
 else {
      checkMonitorCanceled(progress);
      progress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);
      myProject.getProjectHandler().refreshFS();
      progress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);
      checkMonitorCanceled(progress);
      progress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);
      progress.addText("compiling output module...");
      CompilationResult compilationResult=myProject.getProjectHandler().buildModule(outputFolder);
      progress.addText("" + compilationResult);
      if (!compilationResult.isOk()) {
        reloadClasses=false;
      }
      boolean needCompileSourceLanguageModules=false;
      if (invocationContext instanceof ModuleContext) {
        ModuleContext ctx=(ModuleContext)invocationContext;
        if (ctx.getModule() instanceof Solution) {
          needCompileSourceLanguageModules=true;
        }
      }
      if (myCompileSourceLanguageModules && needCompileSourceLanguageModules) {
        for (        Language l : getPossibleSourceLanguages(_sourceModels,invocationContext.getScope())) {
          progress.addText("compiling " + l + "'s  module...");
          compilationResult=myProject.getProjectHandler().buildModule(l.getSourceDir().getPath());
          progress.addText("" + compilationResult);
          if (!compilationResult.isOk()) {
            reloadClasses=false;
          }
        }
      }
      progress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);
      checkMonitorCanceled(progress);
    }
    if (reloadClasses) {
      progress.addText("reloading MPS classes...");
      progress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);
      ReloadUtils.reloadAll(false);
      progress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);
      checkMonitorCanceled(progress);
    }
    GenerationStatus status=null;
    IGenerationSession generationSession;
    if (generatingEngine == GeneratingEngine.old) {
      generationSession=new GenerationSession(invocationContext,isSaveTransientModels(),progress,handler);
    }
 else {
      generationSession=new GenerationSession_New(invocationContext,isSaveTransientModels(),progress,handler);
    }
    for (    SModelDescriptor sourceModelDescriptor : sourceModels) {
      if (invocationContext.getModule() instanceof Language && sourceModelDescriptor.getModelUID().toString().contains(".structure") && targetLanguage.getNamespace().equals("jetbrains.mps.baseLanguage.ext.collections.lang")) {
        JavaNameUtil.ourAdaptorGenerator=true;
      }
      progress.addText("");
      String taskName=ModelsProgressUtil.generationModelTaskName(sourceModelDescriptor);
      progress.startLeafTask(taskName,ModelsProgressUtil.TASK_KIND_GENERATION);
      status=generationSession.generateModel(sourceModelDescriptor,targetLanguage,script);
      checkMonitorCanceled(progress);
      if (status.getOutputModel() != null) {
        generationType.handleOutput(invocationContext,status,progress,outputFolder);
      }
      generationSession.discardTransients();
      progress.finishTask(taskName);
      JavaNameUtil.ourAdaptorGenerator=false;
      if (!status.isOk()) {
        break;
      }
    }
    if (isSaveTransientModels()) {
      File solutionDescriptorFile=generationSession.saveTransientModels();
      progress.addText("update output models solution");
      handler.handle(new Message(MessageKind.INFORMATION,"update output models solution"));
      Solution outputModels=myProject.findSolution("outputModels");
      if (outputModels != null) {
        outputModels.reloadFromDisk();
      }
 else {
        myProject.addProjectSolution(solutionDescriptorFile);
      }
    }
    updateLanguagesGenerationRequiredStatus(invocationContext);
    checkMonitorCanceled(progress);
    progress.addText("");
    if (status.isOk()) {
      if (compile) {
        progress.addText("compiling in IntelliJ IDEA...");
        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);
        myProject.getProjectHandler().refreshFS();
        progress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);
        checkMonitorCanceled(progress);
        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);
        CompilationResult compilationResult=myProject.getProjectHandler().buildModule(outputFolder);
        progress.addText("" + compilationResult);
        progress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);
        checkMonitorCanceled(progress);
        if (compilationResult.isOk()) {
          progress.addText("reloading MPS classes...");
          progress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);
          ReloadUtils.reloadAll(false);
          progress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);
          checkMonitorCanceled(progress);
        }
      }
      progress.addText("generation completed successfully");
      handler.handle(new Message(MessageKind.INFORMATION,"generation completed successfully"));
      progress.finishSomehow();
    }
 else     if (status.isError()) {
      progress.addText("generation finished with errors");
      handler.handle(new Message(MessageKind.WARNING,"generation finished with errors"));
      progress.finishSomehow();
    }
  }
 catch (  GenerationCanceledException gce) {
    progress.addText("generation canceled");
    handler.handle(new Message(MessageKind.WARNING,"generation canceled"));
    progress.finishAnyway();
    showMessageView();
  }
catch (  Throwable t) {
    LOG.error(t);
    final String text=t.toString();
    progress.addText(text);
    handler.handle(new Message(MessageKind.ERROR,text));
    progress.finishSomehow();
  }
 finally {
    System.gc();
  }
}
