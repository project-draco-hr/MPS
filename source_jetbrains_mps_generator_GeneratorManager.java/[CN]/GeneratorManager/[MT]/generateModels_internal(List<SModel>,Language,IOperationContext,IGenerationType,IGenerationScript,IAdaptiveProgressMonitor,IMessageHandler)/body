{
  MPSModuleRepository.getInstance().removeTransientModules();
  MPSProject project=invocationContext.getProject();
  IProjectHandler projectHandler=project.getProjectHandler();
  showMessageView(project);
  project.saveModels();
  List<SModelDescriptor> sourceModels=new ArrayList<SModelDescriptor>();
  for (  SModel model : _sourceModels) {
    sourceModels.add(model.getModelDescriptor());
  }
  clearMessageVew(project);
  messages.handle(new Message(MessageKind.INFORMATION,generationType.getStartText()));
  String outputFolder=invocationContext.getModule().getGeneratorOutputPath();
  if (!new File(outputFolder).exists()) {
    new File(outputFolder).mkdirs();
    try {
      projectHandler.addSourceRoot(outputFolder);
    }
 catch (    Exception e) {
      messages.handle(new Message(MessageKind.WARNING,"Can't add output folder to IDEA as sources"));
    }
  }
  messages.handle(new Message(MessageKind.INFORMATION,"    target root folder: \"" + outputFolder + "\""));
  boolean ideaPresent=projectHandler != null;
  boolean compile=ideaPresent && ((myCompileOnGeneration && generationType.requiresCompilationInIDEAfterGeneration()) || (myCompileBeforeGeneration && generationType.requiresCompilationInIDEABeforeGeneration()));
  long totalJob=ModelsProgressUtil.estimateTotalGenerationJobMillis(compile,sourceModels);
  progress.startTaskAnyway("generating",null,totalJob);
  try {
    boolean reloadClasses=true;
    if (!myCompileBeforeGeneration || !generationType.requiresCompilationInIDEABeforeGeneration()) {
      progress.addText("compilation in IntelliJ IDEA before generation is turned off or not needed");
      reloadClasses=false;
    }
 else     if (!ideaPresent) {
      progress.addText("IntelliJ IDEA with installed MPS is not present");
    }
 else {
      checkMonitorCanceled(progress);
      progress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);
      projectHandler.refreshFS();
      progress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);
      checkMonitorCanceled(progress);
      progress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);
      progress.addText("compiling output module...");
      CompilationResult compilationResult=projectHandler.buildModule(outputFolder);
      progress.addText("" + compilationResult);
      if (!compilationResult.isOk()) {
        reloadClasses=false;
      }
      boolean needCompileSourceLanguageModules=false;
      if (invocationContext instanceof ModuleContext) {
        ModuleContext ctx=(ModuleContext)invocationContext;
        if (ctx.getModule() instanceof Solution) {
          needCompileSourceLanguageModules=true;
        }
      }
      if (myCompileSourceLanguageModules && needCompileSourceLanguageModules) {
        for (        Language l : getPossibleSourceLanguages(_sourceModels,invocationContext.getScope())) {
          progress.addText("compiling " + l + "'s  module...");
          compilationResult=projectHandler.buildModule(l.getSourceDir().getPath());
          progress.addText("" + compilationResult);
          if (!compilationResult.isOk()) {
            reloadClasses=false;
          }
        }
      }
      progress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);
      checkMonitorCanceled(progress);
    }
    if (reloadClasses) {
      progress.addText("reloading MPS classes...");
      progress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);
      ReloadUtils.reloadAll(false);
      progress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);
      checkMonitorCanceled(progress);
    }
    GenerationStatus status=null;
    IGenerationSession generationSession=new GenerationSession(invocationContext,isSaveTransientModels(),progress,messages);
    try {
      Logger.addLoggingHandler(generationSession.getLoggingHandler());
      TypeChecker.getInstance().setIncrementalMode(false);
      TypeChecker.getInstance().setGenerationMode(true);
      for (      SModelDescriptor sourceModelDescriptor : sourceModels) {
        progress.addText("");
        if (myCheckBeforeCompilation) {
          progress.addText("Checking model \"" + sourceModelDescriptor.getModelUID() + "\"... ");
          ModelCheckResult result=new ModelChecker(invocationContext).checkModel(sourceModelDescriptor);
          if (result.hasErrors()) {
            if (JOptionPane.showConfirmDialog(invocationContext.getMainFrame(),"Model " + sourceModelDescriptor.getModelUID() + " has errors. Are you sure that you want to generate it?") != JOptionPane.YES_OPTION) {
              continue;
            }
          }
        }
        String taskName=ModelsProgressUtil.generationModelTaskName(sourceModelDescriptor);
        progress.startLeafTask(taskName,ModelsProgressUtil.TASK_KIND_GENERATION);
        status=generationSession.generateModel(sourceModelDescriptor,targetLanguage,script);
        if (isDumpStatistics()) {
          Statistics.dumpAll();
        }
        checkMonitorCanceled(progress);
        if (status.getOutputModel() != null) {
          boolean generateText=true;
          if (!status.isOk() && generationType instanceof GenerateFilesGenerationType) {
            int result=JOptionPane.showConfirmDialog(invocationContext.getMainFrame(),"Generation finished with errors. Do you want to have text files generated?");
            if (result != JOptionPane.YES_OPTION) {
              generateText=false;
            }
          }
          if (generateText) {
            generationType.handleOutput(invocationContext,status,progress,outputFolder);
          }
        }
        generationSession.discardTransients();
        progress.finishTask(taskName);
      }
      if (isSaveTransientModels()) {
        File solutionDescriptorFile=generationSession.saveTransientModels();
        progress.addText("update output models solution");
        messages.handle(new Message(MessageKind.INFORMATION,"update output models solution"));
        Solution outputModels=project.findSolution("outputModels");
        if (outputModels != null) {
          outputModels.reloadFromDisk();
        }
 else {
          project.addProjectSolution(solutionDescriptorFile);
        }
      }
    }
  finally {
      generationSession.discardTransients();
      Logger.removeLoggingHandler(generationSession.getLoggingHandler());
      TypeChecker.getInstance().setIncrementalMode(true);
      TypeChecker.getInstance().setGenerationMode(false);
    }
    updateLanguagesGenerationRequiredStatus(invocationContext);
    checkMonitorCanceled(progress);
    progress.addText("");
    if (status.isOk()) {
      if (!myCompileOnGeneration || !ideaPresent || !generationType.requiresCompilationInIDEAfterGeneration()) {
        progress.addText("compilation in IntelliJ IDEA after generation is turned off or not needed");
      }
 else {
        progress.addText("compiling in IntelliJ IDEA...");
        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);
        projectHandler.refreshFS();
        progress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);
        checkMonitorCanceled(progress);
        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);
        CompilationResult compilationResult=projectHandler.buildModule(outputFolder);
        progress.addText("" + compilationResult);
        progress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);
        checkMonitorCanceled(progress);
        if (compilationResult.isOk()) {
          progress.addText("reloading MPS classes...");
          progress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);
          ReloadUtils.reloadAll(false);
          progress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);
          checkMonitorCanceled(progress);
        }
      }
      if (generationType.forceReload()) {
        ReloadUtils.reloadAll(true,true,true,new HashSet<SModelDescriptor>(),invocationContext.getModule(),new Runnable(){
          public void run(){
          }
        }
);
      }
      progress.addText("generation completed successfully");
      messages.handle(new Message(MessageKind.INFORMATION,"generation completed successfully"));
      progress.finishSomehow();
    }
 else     if (status.isError()) {
      progress.addText("generation finished with errors");
      messages.handle(new Message(MessageKind.WARNING,"generation finished with errors"));
      progress.finishSomehow();
    }
    if (generationType instanceof GenerateFilesGenerationType && ideaPresent && !generationType.requiresCompilationInIDEAfterGeneration()) {
      projectHandler.refreshFS();
    }
  }
 catch (  GenerationCanceledException gce) {
    progress.addText("generation canceled");
    messages.handle(new Message(MessageKind.WARNING,"generation canceled"));
    progress.finishAnyway();
    showMessageView(project);
  }
catch (  Throwable t) {
    LOG.error(t);
    final String text=t.toString();
    progress.addText(text);
    messages.handle(new Message(MessageKind.ERROR,text));
    progress.finishSomehow();
  }
 finally {
    TypeChecker.getInstance().clearForReload();
    NodeTypesComponentsRepository.getInstance().clear();
    if (myCompileOnGeneration && ideaPresent && generationType.requiresCompilationInIDEAfterGeneration()) {
      progress.addText("Invalidate caches");
      ReloadUtils.invalidateCaches();
      progress.addText("Resfresh models");
      SModelRepository.getInstance().refreshModels();
      System.gc();
    }
  }
}
