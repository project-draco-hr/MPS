{
  showMessageView();
  invocationContext.getProject().saveModels();
  List<SModelDescriptor> sourceModels=new ArrayList<SModelDescriptor>();
  for (  SModel model : _sourceModels) {
    sourceModels.add(model.getModelDescriptor());
  }
  clearMessages();
  addMessage(MessageKind.INFORMATION,generationType.getStartText());
  addMessage(MessageKind.INFORMATION,"    target language: \"" + targetLanguage.getNamespace() + "\"");
  String outputFolder=invocationContext.getModule().getGeneratorOutputPath();
  if (!new File(outputFolder).exists()) {
    new File(outputFolder).mkdirs();
    try {
      myProject.getProjectHandler().addSourceRoot(outputFolder);
    }
 catch (    Exception e) {
      addMessage(MessageKind.WARNING,"Can't add output folder to IDEA as sources");
    }
  }
  addMessage(MessageKind.INFORMATION,"    target root folder: \"" + outputFolder + "\"");
  boolean ideaPresent=myProject.getProjectHandler() != null;
  boolean compile=myCompileOnGeneration && ideaPresent && generationType.requiresCompilationInIDEAfterGeneration();
  long totalJob=ModelsProgressUtil.estimateTotalGenerationJobMillis(compile,sourceModels);
  progress.startTaskAnyway("generating",null,totalJob);
  try {
    boolean reloadClasses=true;
    if (!myCompileOnGeneration || !generationType.requiresCompilationInIDEABeforeGeneration()) {
      progress.addText("compilation in IntelliJ IDEA on generation is turned off or not needed");
      reloadClasses=false;
    }
 else     if (!ideaPresent) {
      progress.addText("IntelliJ IDEA with installed MPS is not present");
    }
 else {
      checkMonitorCanceled(progress);
      progress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);
      myProject.getProjectHandler().refreshFS();
      progress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);
      checkMonitorCanceled(progress);
      progress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);
      progress.addText("compiling output module...");
      CompilationResult compilationResult=myProject.getProjectHandler().buildModule(outputFolder);
      progress.addText("" + compilationResult);
      if (!compilationResult.isOk()) {
        reloadClasses=false;
      }
      boolean needCompileSourceLanguageModules=false;
      if (invocationContext instanceof ModuleContext) {
        ModuleContext ctx=(ModuleContext)invocationContext;
        if (ctx.getModule() instanceof Solution) {
          needCompileSourceLanguageModules=true;
        }
      }
      if (myCompileSourceLanguageModules && needCompileSourceLanguageModules) {
        for (        Language l : getPossibleSourceLanguages(_sourceModels,invocationContext.getScope())) {
          progress.addText("compiling " + l + "'s  module...");
          compilationResult=myProject.getProjectHandler().buildModule(l.getSourceDir().getPath());
          progress.addText("" + compilationResult);
          if (!compilationResult.isOk()) {
            reloadClasses=false;
          }
        }
      }
      progress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);
      checkMonitorCanceled(progress);
    }
    if (reloadClasses) {
      progress.addText("reloading MPS classes...");
      progress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);
      ReloadUtils.reloadAll(false);
      progress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);
      checkMonitorCanceled(progress);
    }
    GenerationSession generationSession=new GenerationSession(targetLanguage,invocationContext,isSaveTransientModels(),progress);
    GenerationStatus status=null;
    for (    SModelDescriptor sourceModelDescriptor : sourceModels) {
      progress.addText("");
      String taskName=ModelsProgressUtil.generationModelTaskName(sourceModelDescriptor);
      progress.startLeafTask(taskName,ModelsProgressUtil.TASK_KIND_GENERATION);
      status=generationSession.generateModel(sourceModelDescriptor);
      checkMonitorCanceled(progress);
      if (status.getOutputModel() != null) {
        generationType.handleOutput(invocationContext,status,progress,outputFolder);
      }
      generationSession.discardTransients();
      progress.finishTask(taskName);
      if (!status.isOk()) {
        break;
      }
    }
    if (isSaveTransientModels()) {
      File solutionDescriptorFile=generationSession.saveTransientModels();
      addProgressMessage(MessageKind.INFORMATION,"update output models solution",progress);
      Solution outputModels=myProject.findSolution("outputModels");
      if (outputModels != null) {
        outputModels.reloadFromDisk();
      }
 else {
        myProject.addProjectSolution(solutionDescriptorFile);
      }
    }
    updateLanguagesGenerationRequiredStatus(invocationContext);
    checkMonitorCanceled(progress);
    progress.addText("");
    if (status.isOk()) {
      if (compile) {
        progress.addText("compiling in IntelliJ IDEA...");
        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);
        myProject.getProjectHandler().refreshFS();
        progress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);
        checkMonitorCanceled(progress);
        progress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);
        CompilationResult compilationResult=myProject.getProjectHandler().buildModule(outputFolder);
        progress.addText("" + compilationResult);
        progress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);
        checkMonitorCanceled(progress);
        if (compilationResult.isOk()) {
          progress.addText("reloading MPS classes...");
          progress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);
          ReloadUtils.reloadAll(false);
          progress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);
          checkMonitorCanceled(progress);
        }
      }
      addProgressMessage(MessageKind.INFORMATION,"generation completed successfully",progress);
      progress.finishSomehow();
    }
 else     if (status.isError()) {
      addProgressMessage(MessageKind.WARNING,"generation finished with errors",progress);
      progress.finishSomehow();
    }
  }
 catch (  GenerationCanceledException gce) {
    addProgressMessage(MessageKind.WARNING,"generation canceled",progress);
    progress.finishAnyway();
    showMessageView();
  }
catch (  Throwable t) {
    LOG.error(t);
    addProgressMessage(MessageKind.ERROR,t.toString(),progress);
    progress.finishSomehow();
  }
 finally {
    System.gc();
  }
}
