{
  clearMessages();
  addMessage(MessageKind.INFORMATION,"Generating " + (generateText ? "text" : "files") + " from model \""+ sourceModel+ "\"");
  addMessage(MessageKind.INFORMATION,"target language: \"" + targetLanguage.getNamespace() + "\"");
  String targetFolder=invocationContext.getModule().getGeneratorOutputPath();
  if (!generateText) {
    addMessage(MessageKind.INFORMATION,"target folder  : " + targetFolder);
  }
  String defaultGeneratorClassName=null;
  TargetOfGenerator targetOfGenerator=targetLanguage.getLanguageDescriptor().getTargetOfGenerator();
  if (targetOfGenerator != null) {
    defaultGeneratorClassName=targetOfGenerator.getGeneratorClass();
  }
  addMessage(MessageKind.INFORMATION,"default generator class: " + (defaultGeneratorClassName != null ? defaultGeneratorClassName : "<n/a>"));
  List<Generator> generators=new LinkedList<Generator>();
  List<Language> sourceLanguages=sourceModel.getLanguages(invocationContext.getScope());
  for (  Language sourceLanguage : sourceLanguages) {
    List<Generator> sourceLanguageGenerators=sourceLanguage.getGenerators();
    for (    Generator sourceLanguageGenerator : sourceLanguageGenerators) {
      if (targetLanguage.getNamespace().equals(sourceLanguageGenerator.getTargetLanguageName())) {
        generators.add(sourceLanguageGenerator);
      }
    }
  }
  if (generators.isEmpty()) {
    addMessage(MessageKind.ERROR,"No generator modules found");
    return;
  }
  String actualGeneratorClassName=null;
  for (  Generator generator : generators) {
    String generatorClassName=generator.getGeneratorClass();
    addMessage(MessageKind.INFORMATION,"generator module found: " + generator.getModuleUID() + " generator class: "+ (generatorClassName != null ? generatorClassName : "<default>"));
    if (actualGeneratorClassName == null) {
      actualGeneratorClassName=generatorClassName;
    }
 else     if (generatorClassName != null && !generatorClassName.equals(actualGeneratorClassName)) {
      addMessage(MessageKind.ERROR,"couldn't choose geneartor class");
      return;
    }
  }
  if (actualGeneratorClassName == null) {
    actualGeneratorClassName=defaultGeneratorClassName;
  }
  invocationContext.getComponent(ProjectPane.class).disableRebuild();
  IProgressMonitor progress=new ProgressWindowProgressMonitor(invocationContext.getComponent(ProjectFrame.class),false);
  try {
    boolean isIdeaPresent=MPSPlugin.getInstance().isIDEAPresent();
    int ideaCompilations=0;
    if (isIdeaPresent && myCompileOnGeneration) {
      if (generateText) {
        ideaCompilations=1;
      }
 else {
        ideaCompilations=2;
      }
    }
    progress.start("Generating",AMOUNT_PER_MODEL + ideaCompilations * AMOUNT_PER_COMPILATION);
    if (!myCompileOnGeneration) {
      progress.addText("Compilation in IntelliJ IDEA on generation is turned off");
    }
 else     if (!isIdeaPresent) {
      progress.addText("IntelliJ IDEA with installed MPS is not present");
    }
 else {
      progress.addText("Compiling in IntelliJ IDEA...");
      compileAndReload();
      progress.advance(AMOUNT_PER_COMPILATION);
    }
    boolean generationFailed=true;
    boolean generationCancelled=false;
    GeneratorSessionContext generatorContext=new GeneratorSessionContext(targetLanguage,generators,invocationContext);
    try {
      generationFailed=!generate_new_internal(sourceModel,targetFolder,actualGeneratorClassName,generatorContext,generateText,progress);
      addMessage(new Message(generationFailed ? MessageKind.WARNING : MessageKind.INFORMATION,sourceModel.getUID() + " generated " + (generationFailed ? "with errors" : "successfully")));
    }
 catch (    GenerationCanceledException gce) {
      progress.addText("generation canceled");
      generationCancelled=true;
    }
catch (    GenerationFailedException gfe) {
      LOG.error(sourceModel.getUID() + " : generation failed",gfe);
      progress.addText(gfe.toString());
      GenerationFailueInfo failueInfo=gfe.getFailueInfo();
      if (failueInfo != null) {
        for (        Message message : failueInfo.createMessages()) {
          addMessage(message);
        }
      }
      addMessage(new Message(MessageKind.ERROR,sourceModel.getUID() + " : " + gfe));
    }
catch (    Exception e) {
      LOG.error(sourceModel.getUID() + " : generation failed",e);
      progress.addText(e.toString());
      addMessage(new Message(MessageKind.ERROR,sourceModel.getUID() + " : " + e));
    }
    if (mySaveTransientModels) {
      saveTransientModels(generatorContext);
    }
 else {
      if (!generationFailed) {
        generatorContext.getModule().dispose();
      }
    }
    if (myCompileOnGeneration) {
      if (isIdeaPresent && !(generateText || generationFailed || generationCancelled)) {
        LOG.debug("Compiling in IDE after generation");
        progress.addText("Compiling in IntelliJ IDEA...");
        compileAndReload();
      }
      progress.advance(AMOUNT_PER_MODEL);
    }
    MessageKind messageKind=(generationCancelled || generationFailed) ? MessageKind.WARNING : MessageKind.INFORMATION;
    String messageText="Generation complated successfully";
    if (generationFailed)     messageText="Generation finished with errors";
    if (generationCancelled)     messageText="Generation cancelled";
    progress.addText(messageText);
    addMessage(new Message(messageKind,messageText));
    if (!generateText) {
      showMessageView();
    }
  }
  finally {
    progress.finish();
    ReflectionClassifierFinder.generationFinished();
    invocationContext.getComponent(ProjectPane.class).enableRebuild();
  }
}
