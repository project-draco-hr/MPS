{
  String defaultGeneratorClassName=null;
  TargetOfGenerator targetOfGenerator=targetLanguage.getLanguageDescriptor().getTargetOfGenerator();
  if (targetOfGenerator != null) {
    defaultGeneratorClassName=targetOfGenerator.getGeneratorClass();
  }
  addMessage(MessageKind.INFORMATION,"Default generator class: " + (defaultGeneratorClassName != null ? defaultGeneratorClassName : "<none>"));
  List<Generator> generators=new LinkedList<Generator>();
  List<Language> sourceLanguages=sourceModel.getLanguages(invocationContext.getScope());
  for (  Language sourceLanguage : sourceLanguages) {
    List<Generator> sourceLanguageGenerators=sourceLanguage.getGenerators();
    for (    Generator sourceLanguageGenerator : sourceLanguageGenerators) {
      if (targetLanguage.getNamespace().equals(sourceLanguageGenerator.getTargetLanguageName())) {
        generators.add(sourceLanguageGenerator);
      }
    }
  }
  if (generators.isEmpty()) {
    addMessage(MessageKind.ERROR,"No generator modules found");
    return new GenerationStatus.ERROR();
  }
  String actualGeneratorClassName=null;
  for (  Generator generator : generators) {
    String generatorClassName=generator.getGeneratorClass();
    addMessage(MessageKind.INFORMATION,"Generator module found: " + generator.getModuleUID() + " generator class: "+ (generatorClassName != null ? generatorClassName : "<default>"));
    if (actualGeneratorClassName == null) {
      actualGeneratorClassName=generatorClassName;
    }
 else     if (generatorClassName != null && !generatorClassName.equals(actualGeneratorClassName)) {
      addMessage(MessageKind.ERROR,"Couldn't choose geneartor class");
      return new GenerationStatus.ERROR();
    }
  }
  if (actualGeneratorClassName == null) {
    actualGeneratorClassName=defaultGeneratorClassName;
  }
  if (compileBefore) {
    progress.addText("Compiling in IntelliJ IDEA...");
    compileAndReload();
    progress.advance(AMOUNT_PER_COMPILATION);
  }
  GenerationStatus status=null;
  GeneratorSessionContext generatorContext=new GeneratorSessionContext(targetLanguage,generators,invocationContext);
  try {
    status=generate_new_internal(sourceModel,actualGeneratorClassName,generatorContext,progress);
    addMessage(new Message(status.isError() ? MessageKind.WARNING : MessageKind.INFORMATION,sourceModel.getUID() + " generated " + (status.isError() ? "with errors" : "successfully")));
  }
 catch (  GenerationCanceledException gce) {
    progress.addText("generation canceled");
    status=new GenerationStatus.CANCELED();
  }
catch (  GenerationFailedException gfe) {
    LOG.error(sourceModel.getUID() + " : generation failed",gfe);
    progress.addText(gfe.toString());
    GenerationFailueInfo failueInfo=gfe.getFailueInfo();
    if (failueInfo != null) {
      for (      Message message : failueInfo.createMessages()) {
        addMessage(message);
      }
    }
    addMessage(new Message(MessageKind.ERROR,sourceModel.getUID() + " : " + gfe));
    status=new GenerationStatus.ERROR();
  }
catch (  Exception e) {
    LOG.error(sourceModel.getUID() + " : generation failed",e);
    progress.addText(e.toString());
    addMessage(new Message(MessageKind.ERROR,sourceModel.getUID() + " : " + e));
    status=new GenerationStatus.ERROR();
  }
  if (mySaveTransientModels) {
    saveTransientModels(generatorContext);
  }
 else {
    if (!status.isOk()) {
      generatorContext.getModule().dispose();
    }
  }
  if (myCompileOnGeneration) {
    if (status.isOk() && compileAfter) {
      progress.addText("Compiling and reloading classes...");
      compileAndReload();
    }
    progress.advance(AMOUNT_PER_MODEL);
  }
  return status;
}
