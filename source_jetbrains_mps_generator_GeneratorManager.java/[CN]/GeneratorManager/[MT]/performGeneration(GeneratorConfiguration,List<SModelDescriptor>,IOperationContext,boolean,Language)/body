{
  invocationContext.getComponent(ProjectPane.class).disableRebuild();
  IProgressMonitor progress=new ProgressWindowProgressMonitor(invocationContext.getComponent(ProjectFrame.class),false);
  boolean isIdeaPresent=MPSPlugin.getInstance().isIDEAPresent();
  try {
    int modelCount=0;
    for (    GeneratorConfigurationCommand cmd : CollectionUtil.iteratorAsIterable(configuration.commands())) {
      modelCount+=findModelsWithLanguage(modelDescriptors,cmd.getSourceLanguage().getName()).size();
    }
    int ideaCompilations=0;
    if (isIdeaPresent && myCompileOnGeneration) {
      if (generateText) {
        ideaCompilations=1;
      }
 else {
        ideaCompilations=2;
      }
    }
    progress.start("Generating",(modelCount + ideaCompilations) * AMOUNT_PER_MODEL);
    if (myCompileOnGeneration && ideaCompilations == 0) {
      progress.addText("IntelliJ IDEA with installed MPS is not present");
    }
    if (!myCompileOnGeneration) {
      progress.addText("Compilation in IDEA on generation is turned off");
    }
    clearMessages();
    addMessage(new Message(MessageKind.INFORMATION,null,"Generating configuration " + configuration.getName()));
    if (isIdeaPresent && myCompileOnGeneration) {
      progress.addText("Compiling in IntelliJ IDEA...");
      LOG.debug("Compiling in IDE before generation ");
      compileAndReload();
      progress.advance(AMOUNT_PER_MODEL);
    }
    boolean generationFailed=false;
    boolean generationCancelled=false;
    for (    GeneratorConfigurationCommand cmd : CollectionUtil.iteratorAsIterable(configuration.commands())) {
      LOG.debug("Executing command : " + cmd.getSourceLanguage().getName() + " -> "+ cmd.getTargetLanguage().getName());
      Set<SModelDescriptor> modelsWithLanguage=findModelsWithLanguage(modelDescriptors,cmd.getSourceLanguage().getName());
      Generator generator=findGenerator(cmd.getSourceLanguage().getName(),cmd.getTargetLanguage().getName(),invocationContext);
      GeneratorSessionContext generatorContext=new GeneratorSessionContext(generator,invocationContext);
      String generatorClass=findGeneratorClass(generator);
      if (generatorClass == null)       generatorClass=DefaultTemplateGenerator.class.getName();
      boolean generationByCommandFailed=false;
      SModelDescriptor templatesModel=loadTemplatesModel(generator,generatorContext);
      for (      SModelDescriptor model : modelsWithLanguage) {
        try {
          boolean genOK=generate_internal(model,templatesModel,generatorContext,generatorClass,configuration.getOutputPath(),progress,generateText);
          generationByCommandFailed=generationByCommandFailed || !genOK;
          addMessage(new Message(MessageKind.INFORMATION,model.getModelUID() + " generated " + (genOK ? "successfully" : "with errors")));
        }
 catch (        GenerationCanceledException gce) {
          progress.addText("generation canceled");
          generationCancelled=true;
          break;
        }
catch (        GenerationFailedException gfe) {
          LOG.error(model.getModelUID() + " : generation failed",gfe);
          progress.addText(gfe.toString());
          GenerationFailueInfo failueInfo=gfe.getFailueInfo();
          if (failueInfo != null) {
            for (            Message message : failueInfo.createMessages()) {
              addMessage(message);
            }
          }
          addMessage(new Message(MessageKind.ERROR,model.getModelUID() + " : " + gfe));
          generationByCommandFailed=true;
          break;
        }
catch (        Exception e) {
          LOG.error(model.getModelUID() + " : generation failed",e);
          progress.addText(e.toString());
          addMessage(new Message(MessageKind.ERROR,model.getModelUID() + " : " + e));
          generationByCommandFailed=true;
          break;
        }
      }
      if (mySaveTransientModels) {
        saveTransientModels(generatorContext);
      }
 else {
        if (!generationByCommandFailed) {
          generatorContext.getModule().dispose();
        }
      }
      generationFailed=generationFailed || generationByCommandFailed;
      if (generationCancelled)       break;
    }
    if (myCompileOnGeneration) {
      if (isIdeaPresent && !(generateText || generationFailed || generationCancelled)) {
        LOG.debug("Compiling in IDE after generation");
        progress.addText("Compiling in IntelliJ IDEA...");
        compileAndReload();
      }
      progress.advance(AMOUNT_PER_MODEL);
    }
    MessageKind messageKind=(generationCancelled || generationFailed) ? MessageKind.WARNING : MessageKind.INFORMATION;
    String messageText="Generation complated successfully";
    if (generationFailed)     messageText="Generation finished with errors";
    if (generationCancelled)     messageText="Generation cancelled";
    addMessage(new Message(messageKind,messageText));
    if (!generateText) {
      showMessageView();
    }
    progress.addText("Finished");
  }
  finally {
    progress.finish();
    ReflectionClassifierFinder.generationFinished();
    if (language != null)     language.updateLastGenerationTime();
    invocationContext.getComponent(ProjectPane.class).enableRebuild();
  }
}
