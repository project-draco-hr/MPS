{
  GraphLayout layout=new GraphLayout(graph);
  for (  Node node : ListSequence.fromList(graph.getNodes())) {
    Rectangle rect=MapSequence.fromMap(representation).get(node);
    if (!(node.isDummy())) {
      int width=MapSequence.fromMap(nodeSizes).get(node).width - myEdgeDistance;
      int meanEdgeX=0;
      List<Edge> edges=node.getEdges();
      for (      Edge edge : ListSequence.fromList(edges)) {
        meanEdgeX+=MapSequence.fromMap(representation).get(edge).x;
      }
      meanEdgeX/=ListSequence.fromList(edges).count();
      int nodeX=meanEdgeX - width / 2;
      if (nodeX < rect.x) {
        nodeX=rect.x;
      }
      if (nodeX + width > rect.x + rect.width) {
        nodeX=rect.x + rect.width - width;
      }
      layout.setLayoutFor(node,new Rectangle(nodeX,rect.y,width,MapSequence.fromMap(nodeSizes).get(node).height));
    }
 else {
      layout.setLayoutFor(node,rect);
    }
  }
  for (  Edge edge : ListSequence.fromList(graph.getEdges())) {
    Rectangle edgeRect=MapSequence.fromMap(representation).get(edge);
    if (SetSequence.fromSet(hasLabels).contains(edge)) {
      Dimension labelSize=MapSequence.fromMap(edgeSizes).get(edge);
      int mid=edgeRect.y + edgeRect.height / 2;
      int height=labelSize.height - myEdgeDistance;
      Rectangle labelRectangle=new Rectangle(edgeRect.x,mid - height / 2,labelSize.width - myEdgeDistance,height);
      layout.setLabelLayout(edge,labelRectangle);
    }
    List<Point> path=ListSequence.fromList(new ArrayList<Point>());
    Rectangle sourceRect=layout.getNodeLayout(edge.getSource());
    int sourceMinX=sourceRect.x;
    int sourceMaxX=sourceRect.x + sourceRect.width;
    int edgeX=edgeRect.x;
    boolean hasHorLines=false;
    if (sourceMaxX < edgeX) {
      ListSequence.fromList(path).addElement(new Point(sourceMaxX,sourceRect.y + sourceRect.height / 2));
      hasHorLines=true;
    }
    if (edgeX < sourceMinX) {
      ListSequence.fromList(path).addElement(new Point(sourceMinX,sourceRect.y + sourceRect.height / 2));
      hasHorLines=true;
    }
    if (hasHorLines) {
      ListSequence.fromList(path).addElement(new Point(edgeX,sourceRect.y + sourceRect.height / 2));
    }
 else {
      ListSequence.fromList(path).addElement(new Point(edgeX,sourceRect.y + sourceRect.height));
    }
    Rectangle targetRect=layout.getNodeLayout(edge.getTarget());
    int targetMinX=targetRect.x;
    int targetMaxX=targetRect.x + targetRect.width;
    hasHorLines=false;
    Point end=null;
    if (targetMaxX < edgeX) {
      end=new Point(targetMaxX,targetRect.y + targetRect.height / 2);
      hasHorLines=true;
    }
    if (edgeX < targetMinX) {
      end=new Point(targetMinX,targetRect.y + targetRect.height / 2);
      hasHorLines=true;
    }
    if (hasHorLines) {
      ListSequence.fromList(path).addElement(new Point(edgeX,targetRect.y + targetRect.height / 2));
      ListSequence.fromList(path).addElement(end);
    }
 else {
      ListSequence.fromList(path).addElement(new Point(edgeX,targetRect.y));
    }
    layout.setLayoutFor(edge,path);
  }
  layout=LayoutTransform.shift(layout,20,20);
  correctEdgesLayout(layout);
  return layout;
}
