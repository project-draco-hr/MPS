{
  myId=id;
  myName=name;
  final List<String> directProperties=new ArrayList<String>();
  final List<String> directReferences=new ArrayList<String>();
  final Map<SPropertyId,PropertyDescriptor> directPropertiesByIds=new HashMap<SPropertyId,PropertyDescriptor>();
  final Map<SReferenceLinkId,ReferenceDescriptor> directReferencesByIds=new HashMap<SReferenceLinkId,ReferenceDescriptor>();
  final Map<SContainmentLinkId,LinkDescriptor> directLinksByIds=new HashMap<SContainmentLinkId,LinkDescriptor>();
  final Map<String,PropertyDescriptor> directPropertiesByName=new HashMap<String,PropertyDescriptor>();
  final Map<String,ReferenceDescriptor> directReferencesByName=new HashMap<String,ReferenceDescriptor>();
  final Map<String,LinkDescriptor> directLinksByName=new HashMap<String,LinkDescriptor>();
  NodeReadAccessCasterInEditor.runReadTransparentAction(new Runnable(){
    @Override public void run(){
      SNode declaration=SModelUtil.findConceptDeclaration(myName);
      if (declaration == null || !SNodeUtil.isInstanceOfAbstractConceptDeclaration(declaration)) {
        isLegal=false;
        return;
      }
 else {
        isLegal=true;
      }
      isInterface=SNodeUtil.isInstanceOfInterfaceConceptDeclaration(declaration);
      isFinal=SPropertyOperations.getBoolean(declaration,"isFinal");
      isAbstract=SPropertyOperations.getBoolean(declaration,"isAbstract");
      helpURL=SPropertyOperations.getString(declaration,"helpUrl");
      conceptAlias=SNodeUtil.getConceptAlias(declaration);
      shortDescription=SNodeUtil.getConceptShortDescription(declaration);
      String scopeVal=SPropertyOperations.getString(declaration,"staticScope");
      staticScope="none".equals(scopeVal) ? StaticScope.NONE : ("root".equals(scopeVal) ? StaticScope.ROOT : StaticScope.GLOBAL);
      if (SNodeUtil.isInstanceOfConceptDeclaration(declaration)) {
        SNode superConceptNode=SNodeUtil.getConceptDeclaration_Extends(declaration);
        if (superConceptNode == null && !SNodeUtil.concept_BaseConcept.equals(myName)) {
          superConcept=SNodeUtil.concept_BaseConcept;
          superConceptId=SNodeUtil.conceptId_BaseConcept;
        }
 else {
          superConcept=NameUtil.nodeFQName(superConceptNode);
          superConceptId=superConceptNode == null ? null : MetaIdByDeclaration.getConceptId(((jetbrains.mps.smodel.SNode)superConceptNode));
        }
      }
      Set<String> parentsSet=new LinkedHashSet<String>();
      Set<SConceptId> parentsIdsSet=new LinkedHashSet<SConceptId>();
      if (SNodeUtil.isInstanceOfConceptDeclaration(declaration)) {
        parentsSet.add(superConcept);
        parentsIdsSet.add(superConceptId);
        for (        SNode interfaceConcept : SNodeUtil.getConceptDeclaration_Implements(declaration)) {
          parentsSet.add(NameUtil.nodeFQName(interfaceConcept));
          parentsIdsSet.add(MetaIdByDeclaration.getConceptId(((jetbrains.mps.smodel.SNode)interfaceConcept)));
        }
      }
 else       if (SNodeUtil.isInstanceOfInterfaceConceptDeclaration(declaration)) {
        for (        SNode interfaceConcept : SNodeUtil.getInterfaceConceptDeclaration_Extends(declaration)) {
          parentsSet.add(NameUtil.nodeFQName(interfaceConcept));
          parentsIdsSet.add(MetaIdByDeclaration.getConceptId(((jetbrains.mps.smodel.SNode)interfaceConcept)));
        }
      }
      parentsSet.remove(null);
      if (superConcept == null && !SNodeUtil.concept_BaseConcept.equals(myName)) {
        parentsSet.add(SNodeUtil.concept_BaseConcept);
        parentsIdsSet.add(SNodeUtil.conceptId_BaseConcept);
      }
      parents=new ArrayList<String>(parentsSet);
      parentsIds=new ArrayList<SConceptId>(parentsIdsSet);
      for (      SNode property : SNodeUtil.getConcept_PropertyDeclarations(declaration)) {
        String name=property.getName();
        if (name != null) {
          directProperties.add(name);
          SPropertyId propId=MetaIdByDeclaration.getPropId(((jetbrains.mps.smodel.SNode)property));
          BasePropertyDescriptor pd=new BasePropertyDescriptor(propId,name);
          directPropertiesByIds.put(propId,pd);
          directPropertiesByName.put(name,pd);
        }
      }
      unorderedChildren=new HashSet<String>();
      for (      SNode link : SNodeUtil.getConcept_LinkDeclarations(declaration)) {
        String role=SModelUtil.getLinkDeclarationRole(link);
        if (role != null) {
          boolean unordered=SNodeUtil.getLinkDeclaration_IsUnordered(link);
          if (unordered) {
            unorderedChildren.add(role);
          }
          if (SNodeUtil.getLinkDeclaration_IsReference(link)) {
            directReferences.add(role);
            SReferenceLinkId refId=MetaIdByDeclaration.getRefRoleId(((jetbrains.mps.smodel.SNode)link));
            BaseReferenceDescriptor pd=new BaseReferenceDescriptor(refId,role,MetaIdByDeclaration.getConceptId(((jetbrains.mps.smodel.SNode)SNodeUtil.getLinkTarget(link))),SNodeUtil.getLinkDeclaration_IsExactlyOneMultiplicity(link));
            directReferencesByIds.put(refId,pd);
            directReferencesByName.put(role,pd);
          }
 else {
            childrenMap.put(role,!SNodeUtil.getLinkDeclaration_IsSingular(link));
            SContainmentLinkId linkId=MetaIdByDeclaration.getLinkId(((jetbrains.mps.smodel.SNode)link));
            BaseLinkDescriptor pd=new BaseLinkDescriptor(linkId,role,MetaIdByDeclaration.getConceptId(((jetbrains.mps.smodel.SNode)SNodeUtil.getLinkTarget(link))),SNodeUtil.getLinkDeclaration_IsExactlyOneMultiplicity(link),SNodeUtil.getLinkDeclaration_IsSingular(link),unordered);
            directLinksByIds.put(linkId,pd);
            directLinksByName.put(role,pd);
          }
        }
      }
    }
  }
);
  if (isLegal) {
    List<ConceptDescriptor> parentDescriptors=new ArrayList<ConceptDescriptor>(parents.size());
    for (    String parent : parents) {
      ConceptDescriptor descriptor=ConceptRegistry.getInstance().getConceptDescriptor(parent);
      if (!(descriptor instanceof IllegalConceptDescriptor)) {
        parentDescriptors.add(descriptor);
      }
    }
    ancestors=new HashSet<String>(parents);
    ancestors.add(myName);
    for (    ConceptDescriptor parentDescriptor : parentDescriptors) {
      ancestors.addAll(parentDescriptor.getAncestorsNames());
    }
    LinkedHashSet<String> properties=new LinkedHashSet<String>();
    Map<SPropertyId,PropertyDescriptor> propertiesByIds=new HashMap<SPropertyId,PropertyDescriptor>();
    Map<String,PropertyDescriptor> propertiesByName=new HashMap<String,PropertyDescriptor>();
    properties.addAll(directProperties);
    propertiesByIds.putAll(directPropertiesByIds);
    propertiesByName.putAll(directPropertiesByName);
    for (    ConceptDescriptor parentDescriptor : parentDescriptors) {
      properties.addAll(parentDescriptor.getPropertyNames());
      for (      SPropertyId pid : parentDescriptor.getPropertyIds()) {
        propertiesByIds.put(pid,parentDescriptor.getPropertyDescriptor(pid));
      }
      for (      String pname : parentDescriptor.getPropertyNames()) {
        propertiesByName.put(pname,parentDescriptor.getPropertyDescriptor(pname));
      }
    }
    propertyNames=Collections.unmodifiableSet(properties);
    myProperties=Collections.unmodifiableMap(propertiesByIds);
    myPropertiesByName=Collections.unmodifiableMap(propertiesByName);
    LinkedHashSet<String> references=new LinkedHashSet<String>();
    Map<SReferenceLinkId,ReferenceDescriptor> referencesByIds=new HashMap<SReferenceLinkId,ReferenceDescriptor>();
    Map<String,ReferenceDescriptor> referencesByName=new HashMap<String,ReferenceDescriptor>();
    references.addAll(directReferences);
    referencesByIds.putAll(directReferencesByIds);
    referencesByName.putAll(directReferencesByName);
    for (    ConceptDescriptor parentDescriptor : parentDescriptors) {
      references.addAll(parentDescriptor.getReferenceNames());
      for (      SReferenceLinkId rid : parentDescriptor.getReferenceIds()) {
        referencesByIds.put(rid,parentDescriptor.getRefDescriptor(rid));
      }
      for (      String rname : parentDescriptor.getReferenceNames()) {
        referencesByName.put(rname,parentDescriptor.getRefDescriptor(rname));
      }
    }
    referenceNames=Collections.unmodifiableSet(references);
    myReferences=Collections.unmodifiableMap(referencesByIds);
    myReferencesByName=Collections.unmodifiableMap(referencesByName);
    Map<SContainmentLinkId,LinkDescriptor> linksByIds=new HashMap<SContainmentLinkId,LinkDescriptor>();
    Map<String,LinkDescriptor> linksByName=new HashMap<String,LinkDescriptor>();
    linksByIds.putAll(directLinksByIds);
    linksByName.putAll(directLinksByName);
    for (    ConceptDescriptor parentDescriptor : parentDescriptors) {
      for (      String child : parentDescriptor.getChildrenNames()) {
        childrenMap.put(child,parentDescriptor.isMultipleChild(child));
      }
      unorderedChildren.addAll(parentDescriptor.getUnorderedChildrenNames());
      for (      SContainmentLinkId lid : parentDescriptor.getLinkIds()) {
        linksByIds.put(lid,parentDescriptor.getLinkDescriptor(lid));
      }
      for (      String lname : parentDescriptor.getChildrenNames()) {
        linksByName.put(lname,parentDescriptor.getLinkDescriptor(lname));
      }
    }
    unorderedChildren=Collections.unmodifiableSet(unorderedChildren);
    childrenNames=Collections.unmodifiableSet(childrenMap.keySet());
    myLinks=Collections.unmodifiableMap(linksByIds);
    myLinksByName=Collections.unmodifiableMap(linksByName);
  }
}
