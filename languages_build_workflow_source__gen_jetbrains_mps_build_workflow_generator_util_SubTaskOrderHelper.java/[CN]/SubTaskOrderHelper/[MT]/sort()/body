{
  int count=0;
  SubTaskOrderHelper.SubTask[] subtasks=new SubTaskOrderHelper.SubTask[ListSequence.fromList(list).count()];
  for (  SNode st : list) {
    SubTaskOrderHelper.SubTask wrapper=new SubTaskOrderHelper.SubTask(st,count);
    map.put(st,wrapper);
    subtasks[count++]=wrapper;
  }
  for (  SubTaskOrderHelper.SubTask st : subtasks) {
    for (    SNode dep : SLinkOperations.getTargets(st.getTask(),"after",true)) {
      SubTaskOrderHelper.SubTask afterTask=map.get(SLinkOperations.getTarget(dep,"target",false));
      if (afterTask == null) {
        genContext.showErrorMessage(dep,"dependency on non-existing subtask");
        continue;
      }
      st.targets.add(afterTask.getIndex());
    }
    for (    SNode dep : SLinkOperations.getTargets(st.getTask(),"before",true)) {
      SubTaskOrderHelper.SubTask beforeTask=map.get(SLinkOperations.getTarget(dep,"target",false));
      if (beforeTask == null) {
        genContext.showErrorMessage(dep,"dependency on non-existing subtask");
        continue;
      }
      beforeTask.targets.add(st.getIndex());
    }
  }
  int[][] graph=new int[count][];
  for (  SubTaskOrderHelper.SubTask st : subtasks) {
    graph[st.getIndex()]=st.getTargets();
  }
  int[][] partitions=GraphUtil.tarjan(graph);
  ListSequence.fromList(list).clear();
  for (  int[] cycle : partitions) {
    if (cycle.length > 1) {
      StringBuilder sb=new StringBuilder();
      sb.append("subtasks cycle detected: ");
      for (int i=0; i < 5 && i < cycle.length; i++) {
        if (i > 0) {
          sb.append(", ");
        }
        sb.append(SPropertyOperations.getString(subtasks[cycle[i]].getTask(),"name"));
      }
      if (cycle.length > 5) {
        sb.append(" ...");
      }
      genContext.showErrorMessage(subtasks[cycle[0]].getTask(),sb.toString());
      continue;
    }
    ListSequence.fromList(list).addElement(subtasks[cycle[0]].getTask());
  }
}
