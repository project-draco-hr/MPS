{
  myProgress.setIndeterminate(false);
  myProgress.setFraction(0);
  if (!myProgress.isRunning()) {
    myProgress.start();
  }
  long totalJob=estimateGenerationTime();
  long startJobTime=System.currentTimeMillis();
  showMessageView();
  clearMessageVew();
  myMesssages.handle(new Message(MessageKind.INFORMATION,myGenerationType.getStartText()));
  try {
    boolean generationOK=true;
    for (    Pair<IModule,List<SModelDescriptor>> moduleAndDescriptors : myModuleSequence) {
      generationOK=generationOK && generateModelsInModule(moduleAndDescriptors.o1,moduleAndDescriptors.o2,totalJob,startJobTime);
    }
    if (generationOK) {
      boolean compiledSuccessfully=true;
      boolean needToReload=false;
      for (      Pair<IModule,List<SModelDescriptor>> moduleListPair : myModuleSequence) {
        IModule module=moduleListPair.o1;
        if (module != null && module.reloadClassesAfterGeneration()) {
          needToReload=true;
        }
        compiledSuccessfully=compiledSuccessfully && compileModule(module,totalJob,startJobTime);
      }
      for (      SModelDescriptor sm : myModelsToContexts.keySet()) {
        ModelGenerationStatusManager.getInstance().invalidateData(sm);
      }
      if (compiledSuccessfully && needToReload) {
        reloadClasses(totalJob,startJobTime);
      }
      if (generationOK) {
        info("generation completed successfully");
      }
 else {
        info("generation completed with errors");
      }
    }
 else     if (!generationOK) {
      info("generation finished with errors");
    }
    if (isIDEAPresent() && !myGenerationType.requiresCompilationInIDEAfterGeneration()) {
      getProjectHandler().refreshFS();
    }
    fireModelsGenerated(generationOK);
  }
 catch (  GenerationCanceledException gce) {
    warning("generation canceled");
    myProgress.stop();
    showMessageView();
    return false;
  }
catch (  Throwable t) {
    LOG.error(t);
    final String text=t.toString();
    myMesssages.handle(new Message(MessageKind.ERROR,text));
  }
 finally {
    if (myProgress.isRunning()) {
      myProgress.stop();
    }
  }
  return true;
}
