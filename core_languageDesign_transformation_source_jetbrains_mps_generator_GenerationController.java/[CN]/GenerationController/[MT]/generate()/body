{
  myProgress.start("generating",estimateGenerationTime());
  MPSModuleRepository.getInstance().removeTransientModules();
  showMessageView();
  getProject().saveModels();
  clearMessageVew();
  myMesssages.handle(new Message(MessageKind.INFORMATION,myGenerationType.getStartText()));
  boolean ideaPresent=getProjectHandler() != null;
  try {
    boolean generationOK=true;
    for (    Pair<IModule,List<SModelDescriptor>> moduleAndDescriptors : myModuleSequence) {
      generationOK=generationOK && generateModulesInModule(moduleAndDescriptors.o1,moduleAndDescriptors.o2);
    }
    if (generationOK) {
      boolean generatedAndCompiledSuccessfully=true;
      boolean needToReload=false;
      for (      Pair<IModule,List<SModelDescriptor>> moduleListPair : myModuleSequence) {
        IModule module=moduleListPair.o1;
        if (module != null && module.reloadClassesAfterGeneration()) {
          needToReload=true;
        }
        if (module != null && (!ideaPresent && !module.isCompileInMPS()) || !myGenerationType.requiresCompilationInIDEAfterGeneration()) {
          generatedAndCompiledSuccessfully=false;
        }
 else {
          checkMonitorCanceled(myProgress);
          myProgress.startTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);
          CompilationResult compilationResult;
          if (!module.isCompileInMPS()) {
            myProgress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);
            getProjectHandler().refreshFS();
            myProgress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);
            myProgress.addText("compiling in IntelliJ IDEA...");
            myProgress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_IN_IDEA);
            compilationResult=getProjectHandler().buildModule(module.getGeneratorOutputPath());
            myProgress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_IN_IDEA);
          }
 else {
            myProgress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_IN_MPS);
            myProgress.addText("compiling in JetBrains MPS...");
            compilationResult=new ModuleMaker().make(CollectionUtil.asSet(module),new MessagesOnlyAdaptiveProgressMonitorWrapper(myProgress));
            myProgress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_IN_MPS);
          }
          if (compilationResult.getErrors() > 0) {
            generatedAndCompiledSuccessfully=false;
          }
          myProgress.addText("" + compilationResult);
          myProgress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);
          checkMonitorCanceled(myProgress);
        }
      }
      for (      SModelDescriptor sm : myModelsToContexts.keySet()) {
        ModelGenerationStatusManager.getInstance().invalidateData(sm);
      }
      if (generatedAndCompiledSuccessfully && needToReload) {
        myProgress.addText("");
        myProgress.addText("reloading MPS classes...");
        myProgress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);
        ClassLoaderManager.getInstance().reloadAll();
        myProgress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);
      }
      if (generationOK) {
        myProgress.addText("generation completed successfully");
        myMesssages.handle(new Message(MessageKind.INFORMATION,"generation completed successfully"));
      }
 else {
        myProgress.addText("generation completed with errors");
        myMesssages.handle(new Message(MessageKind.INFORMATION,"generation completed with errors"));
      }
    }
 else     if (!generationOK) {
      myProgress.addText("generation finished with errors");
      myMesssages.handle(new Message(MessageKind.WARNING,"generation finished with errors"));
    }
    if (myGenerationType instanceof GenerateFilesGenerationType && ideaPresent && !myGenerationType.requiresCompilationInIDEAfterGeneration()) {
      getProjectHandler().refreshFS();
    }
  }
 catch (  GenerationCanceledException gce) {
    myProgress.addText("generation canceled");
    myMesssages.handle(new Message(MessageKind.WARNING,"generation canceled"));
    myProgress.finishAnyway();
    showMessageView();
    return false;
  }
catch (  Throwable t) {
    LOG.error(t);
    final String text=t.toString();
    myProgress.addText(text);
    myMesssages.handle(new Message(MessageKind.ERROR,text));
  }
 finally {
    myProgress.finishAnyway();
  }
  return true;
}
