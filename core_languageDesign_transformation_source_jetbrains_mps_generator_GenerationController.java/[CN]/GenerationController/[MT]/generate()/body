{
  boolean compile=(myGenerationType.requiresCompilationInIDEAfterGeneration() || myGenerationType.requiresCompilationInIDEABeforeGeneration());
  long totalJob=0;
  for (  Pair<IModule,List<SModelDescriptor>> pair : myModuleSequence) {
    IModule module=pair.o1;
    if (module != null) {
      long jobTime=ModelsProgressUtil.estimateTotalGenerationJobMillis(compile,module != null && !module.isCompileInMPS(),pair.o2);
      totalJob+=jobTime;
    }
  }
  if (totalJob == 0) {
    totalJob=1000;
  }
  myProgress.start("generating",totalJob);
  MPSModuleRepository.getInstance().removeTransientModules();
  MPSProject project=getFirstContext().getProject();
  IProjectHandler projectHandler=project.getProjectHandler();
  showMessageView(project);
  project.saveModels();
  clearMessageVew(project);
  myMesssages.handle(new Message(MessageKind.INFORMATION,myGenerationType.getStartText()));
  boolean ideaPresent=projectHandler != null;
  Map<IModule,String> outputFolders=new HashMap<IModule,String>();
  try {
    boolean generationOK=true;
    boolean generationERROR=false;
    for (    Pair<IModule,List<SModelDescriptor>> moduleAndDescriptors : myModuleSequence) {
      IModule currentModule=moduleAndDescriptors.o1;
      IOperationContext invocationContext=myModulesToContexts.get(currentModule);
      myProgress.startTask("generating in module " + currentModule);
      String outputFolder=currentModule != null ? currentModule.getGeneratorOutputPath() : null;
      if (outputFolder != null && !new File(outputFolder).exists()) {
        new File(outputFolder).mkdirs();
        try {
          projectHandler.addSourceRoot(outputFolder);
        }
 catch (        Exception e) {
          myMesssages.handle(new Message(MessageKind.WARNING,"Can't add output folder to IDEA as sources"));
        }
      }
      myMesssages.handle(new Message(MessageKind.INFORMATION,"    target root folder: \"" + outputFolder + "\""));
      outputFolders.put(currentModule,outputFolder);
      Statistics.setEnabled(Statistics.TPL,myManager.isDumpStatistics());
      String wasLoggingThreshold=null;
      IGenerationSession generationSession=new GenerationSession(invocationContext,mySaveTransientModels,myProgress,myMesssages);
      try {
        if (myManager.isShowErrorsOnly()) {
          wasLoggingThreshold=Logger.setThreshold("ERROR");
        }
        Logger.addLoggingHandler(generationSession.getLoggingHandler());
        TypeChecker.getInstance().setIncrementalMode(false);
        TypeChecker.getInstance().setTypeCheckingMode(TypeCheckingMode.GENERATION);
        for (        SModelDescriptor inputModel : moduleAndDescriptors.o2) {
          myProgress.addText("");
          String taskName=ModelsProgressUtil.generationModelTaskName(inputModel);
          myProgress.startLeafTask(taskName,ModelsProgressUtil.TASK_KIND_GENERATION);
          GenerationStatus status=generationSession.generateModel(inputModel);
          generationOK=generationOK && status.isOk();
          generationERROR=generationERROR || status.isError();
          if (myManager.isDumpStatistics()) {
            Statistics.dumpAll();
          }
          myProgress.addText("handling output...");
          checkMonitorCanceled(myProgress);
          if (status.getOutputModel() != null) {
            boolean result=myGenerationType.handleOutput(status,outputFolder,invocationContext,myProgress,myMesssages);
            if (!result) {
              myProgress.addText("there were errors.");
              generationOK=false;
            }
          }
 else           if (!(status.isCanceled() || status.isError())) {
            myGenerationType.handleEmptyOutput(status,outputFolder,invocationContext,myProgress,myMesssages);
          }
          generationSession.discardTransients();
          myProgress.finishTask(taskName);
        }
      }
  finally {
        if (wasLoggingThreshold != null) {
          Logger.setThreshold(wasLoggingThreshold);
        }
        generationSession.discardTransients();
        Logger.removeLoggingHandler(generationSession.getLoggingHandler());
        TypeChecker.getInstance().setIncrementalMode(true);
        TypeChecker.getInstance().resetTypeCheckingMode();
        tryToReloadModelsFromDisk();
      }
      checkMonitorCanceled(myProgress);
      myProgress.addText("");
      myProgress.finishTask("generating in module " + currentModule);
    }
    if (generationOK) {
      boolean generatedAndCompiledSuccessfully=true;
      boolean needToReload=false;
      for (      Pair<IModule,List<SModelDescriptor>> moduleListPair : myModuleSequence) {
        IModule module=moduleListPair.o1;
        if (module != null && module.reloadClassesAfterGeneration()) {
          needToReload=true;
        }
        if (module != null && (!ideaPresent && !module.isCompileInMPS()) || !myGenerationType.requiresCompilationInIDEAfterGeneration()) {
          generatedAndCompiledSuccessfully=false;
        }
 else {
          checkMonitorCanceled(myProgress);
          myProgress.startTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);
          CompilationResult compilationResult;
          if (!module.isCompileInMPS()) {
            myProgress.startLeafTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);
            projectHandler.refreshFS();
            myProgress.finishTask(ModelsProgressUtil.TASK_NAME_REFRESH_FS);
            myProgress.addText("compiling in IntelliJ IDEA...");
            myProgress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_IN_IDEA);
            compilationResult=projectHandler.buildModule(outputFolders.get(module));
            myProgress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_IN_IDEA);
          }
 else {
            myProgress.startLeafTask(ModelsProgressUtil.TASK_NAME_COMPILE_IN_MPS);
            myProgress.addText("compiling in JetBrains MPS...");
            if (!ModuleMaker.isMakeTurnedOff()) {
              compilationResult=new ModuleMaker().make(CollectionUtil.asSet(module),new MessagesOnlyAdaptiveProgressMonitorWrapper(myProgress));
            }
 else {
              compilationResult=new CompilationResult(0,0,false);
            }
            myProgress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_IN_MPS);
          }
          if (compilationResult.getErrors() > 0) {
            generatedAndCompiledSuccessfully=false;
          }
          myProgress.addText("" + compilationResult);
          myProgress.finishTask(ModelsProgressUtil.TASK_NAME_COMPILE_ON_GENERATION);
          checkMonitorCanceled(myProgress);
        }
      }
      for (      SModelDescriptor sm : myModelsToContexts.keySet()) {
        ModelGenerationStatusManager.getInstance().invalidateData(sm);
      }
      if (generatedAndCompiledSuccessfully && needToReload) {
        myProgress.addText("");
        myProgress.addText("reloading MPS classes...");
        myProgress.startLeafTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);
        ClassLoaderManager.getInstance().reloadAll();
        myProgress.finishTask(ModelsProgressUtil.TASK_NAME_RELOAD_ALL);
      }
      if (generationOK) {
        myProgress.addText("generation completed successfully");
        myMesssages.handle(new Message(MessageKind.INFORMATION,"generation completed successfully"));
      }
 else {
        myProgress.addText("generation completed with errors");
        myMesssages.handle(new Message(MessageKind.INFORMATION,"generation completed with errors"));
      }
    }
 else     if (generationERROR) {
      myProgress.addText("generation finished with errors");
      myMesssages.handle(new Message(MessageKind.WARNING,"generation finished with errors"));
    }
    if (myGenerationType instanceof GenerateFilesGenerationType && ideaPresent && !myGenerationType.requiresCompilationInIDEAfterGeneration()) {
      projectHandler.refreshFS();
    }
  }
 catch (  GenerationCanceledException gce) {
    myProgress.addText("generation canceled");
    myMesssages.handle(new Message(MessageKind.WARNING,"generation canceled"));
    myProgress.finishAnyway();
    showMessageView(project);
    return false;
  }
catch (  Throwable t) {
    LOG.error(t);
    final String text=t.toString();
    myProgress.addText(text);
    myMesssages.handle(new Message(MessageKind.ERROR,text));
  }
 finally {
    myProgress.finishAnyway();
  }
  return true;
}
