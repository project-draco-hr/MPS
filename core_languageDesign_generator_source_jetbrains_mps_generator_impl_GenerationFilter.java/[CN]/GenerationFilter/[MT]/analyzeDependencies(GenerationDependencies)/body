{
  GenerationRootDependencies commonDeps=dependencies.getDependenciesFor(ModelDigestUtil.HEADER);
  if (commonDeps == null) {
    return;
  }
{
    String oldHash=commonDeps.getHash();
    String newHash=myGenerationHashes.get(ModelDigestUtil.HEADER);
    if (oldHash == null || newHash == null || !newHash.equals(oldHash)) {
      return;
    }
  }
  List<SNode> rootsList=myModel.getSModel().getRoots();
  Map<String,SNode> rootById=new HashMap<String,SNode>();
  myUnchangedRoots=new HashSet<SNode>();
  for (  SNode root : rootsList) {
    String id=root.getId();
    GenerationRootDependencies rd=dependencies.getDependenciesFor(id);
    String oldHash;
    if (rd == null || (oldHash=rd.getHash()) == null) {
      continue;
    }
    String newHash=myGenerationHashes.get(id);
    if (newHash == null || !newHash.equals(oldHash)) {
      continue;
    }
    myUnchangedRoots.add(root);
  }
  if (myUnchangedRoots.isEmpty()) {
    return;
  }
  for (  SNode root : rootsList) {
    rootById.put(root.getId(),root);
  }
  myConditionalsUnchanged=true;
  Map<String,Set<String>> dep=getDependenciesWithoutOrientation(dependencies,myUnchangedRoots);
  boolean changed=true;
  while (changed) {
    changed=false;
    Iterator<SNode> it=myUnchangedRoots.iterator();
    while (it.hasNext()) {
      SNode root=it.next();
      Set<String> rootDeps=dep.get(root.getId());
      boolean dirty=false;
      for (      String localRootId : rootDeps) {
        if (!dep.containsKey(localRootId)) {
          dirty=true;
          break;
        }
      }
      if (dirty) {
        it.remove();
        dep.remove(root.getId());
        changed=true;
      }
    }
    if (myConditionalsUnchanged) {
      Set<String> conditionalsDeps=dep.get(CONDITIONALS_ID);
      for (      String localRootId : conditionalsDeps) {
        if (!dep.containsKey(localRootId)) {
          dep.remove(CONDITIONALS_ID);
          myConditionalsUnchanged=false;
          changed=true;
          break;
        }
      }
    }
  }
  if (myUnchangedRoots.isEmpty()) {
    return;
  }
  ConnectedComponentPartitioner partitioner=new ConnectedComponentPartitioner(rootsList);
  List<SNode[]> components=partitioner.partition();
  for (  SNode[] component : components) {
    boolean hasUnchanged=false;
    boolean hasChanged=false;
    for (    SNode n : component) {
      if (myUnchangedRoots.contains(n)) {
        hasUnchanged=true;
      }
 else {
        hasChanged=true;
      }
    }
    if (hasUnchanged && hasChanged) {
      for (      SNode n : component) {
        myUnchangedRoots.remove(n);
      }
    }
  }
}
