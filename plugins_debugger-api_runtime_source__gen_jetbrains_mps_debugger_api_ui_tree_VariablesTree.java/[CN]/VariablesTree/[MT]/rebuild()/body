{
  List<IWatchable> watchables=myUiState.getWatchables();
  if (watchables.isEmpty()) {
    return createEmptyTree();
  }
  MPSTreeNode rootTreeNode=new TextTreeNode("Local Variables");
  rootTreeNode.setTree(this);
  Map<WatchablesCategory,List<IWatchable>> orphanesByCategory=MapSequence.fromMap(new HashMap<WatchablesCategory,List<IWatchable>>());
  Map<WatchablesCategory,Map<SNode,List<IWatchable>>> nodeToVarsMapByCategory=MapSequence.fromMap(new HashMap<WatchablesCategory,Map<SNode,List<IWatchable>>>());
  for (  IWatchable watchable : watchables) {
    WatchablesCategory category=watchable.getCategory();
    SNode node=watchable.getNode();
    if (node == null) {
      List<IWatchable> orphanes=MapSequence.fromMap(orphanesByCategory).get(category);
      if (orphanes == null) {
        orphanes=new ArrayList<IWatchable>();
        MapSequence.fromMap(orphanesByCategory).put(category,orphanes);
      }
      orphanes.add(watchable);
    }
 else {
      Map<SNode,List<IWatchable>> nodeToVarsMap=MapSequence.fromMap(nodeToVarsMapByCategory).get(category);
      if (nodeToVarsMap == null) {
        nodeToVarsMap=MapSequence.fromMap(new LinkedHashMap<SNode,List<IWatchable>>(16,(float)0.75,false));
        MapSequence.fromMap(nodeToVarsMapByCategory).put(category,nodeToVarsMap);
      }
      List<IWatchable> watchableList=MapSequence.fromMap(nodeToVarsMap).get(node);
      if (watchableList == null) {
        watchableList=ListSequence.fromList(new ArrayList<IWatchable>());
        MapSequence.fromMap(nodeToVarsMap).put(node,watchableList);
      }
      watchableList.add(watchable);
    }
  }
  SortedSet<WatchablesCategory> keys=SortedSetSequence.fromSetWithValues(new TreeSet<WatchablesCategory>(),SetSequence.fromSet(MapSequence.fromMap(orphanesByCategory).keySet()).union(SetSequence.fromSet(MapSequence.fromMap(nodeToVarsMapByCategory).keySet())));
  for (  WatchablesCategory category : keys) {
    List<IWatchable> orphanes=MapSequence.fromMap(orphanesByCategory).get(category);
    Map<SNode,List<IWatchable>> nodeToVarsMap=MapSequence.fromMap(nodeToVarsMapByCategory).get(category);
    if (orphanes == null) {
      orphanes=ListSequence.fromList(new ArrayList<IWatchable>());
    }
    if (nodeToVarsMap == null) {
      nodeToVarsMap=MapSequence.fromMap(new HashMap<SNode,List<IWatchable>>());
    }
    List<SNode> nodes=ListSequence.fromList(new ArrayList<SNode>());
    nodes.addAll(MapSequence.fromMap(nodeToVarsMap).keySet());
    Collections.sort(nodes,new ToStringComparator());
    Collections.sort(orphanes,new Comparator<IWatchable>(){
      @Override public int compare(      IWatchable o1,      IWatchable o2){
        return o1.getName().compareTo(o2.getName());
      }
    }
);
    for (    SNode snode : MapSequence.fromMap(nodeToVarsMap).keySet()) {
      List<IWatchable> watchablesWithNodes=MapSequence.fromMap(nodeToVarsMap).get(snode);
      if (watchablesWithNodes.size() == 1) {
        rootTreeNode.add(new WatchableNode(myContext,ListSequence.fromList(watchablesWithNodes).first()));
      }
 else {
        NodeTreeNode nodeTreeNode=new NodeTreeNode(myContext,snode);
        for (        IWatchable watchable : watchablesWithNodes) {
          nodeTreeNode.add(new WatchableNode(myContext,watchable));
        }
        rootTreeNode.add(nodeTreeNode);
      }
    }
    for (    IWatchable watchable : orphanes) {
      rootTreeNode.add(new WatchableNode(myContext,watchable));
    }
  }
  return rootTreeNode;
}
