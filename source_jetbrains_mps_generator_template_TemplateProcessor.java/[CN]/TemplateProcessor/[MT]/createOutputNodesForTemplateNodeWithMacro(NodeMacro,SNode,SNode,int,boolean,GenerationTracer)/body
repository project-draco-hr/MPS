{
  List<SNode> outputNodes=new ArrayList<SNode>();
  String mappingName_=null;
  if (nodeMacro.getMappingId() != null) {
    mappingName_=nodeMacro.getMappingId();
  }
  if (nodeMacro.getMappingLabel() != null) {
    mappingName_=nodeMacro.getMappingLabel().getName();
  }
  if (nodeMacro instanceof LoopMacro) {
    List<SNode> newInputNodes=MacroUtil.getNewInputNodes(inputNode,templateNode,nodeMacrosToSkip,myGenerator);
    for (    SNode newInputNode : newInputNodes) {
      generationTracer.pushInputNode(newInputNode);
      boolean inputChanged=(newInputNode != inputNode);
      if (inputChanged) {
        pushInputHistory(inputNode,mappingName_);
      }
      List<SNode> _outputNodes=createOutputNodesForTemplateNode(mappingName_,templateNode,newInputNode,nodeMacrosToSkip + 1,inputChanged);
      if (_outputNodes != null)       outputNodes.addAll(_outputNodes);
      if (inputChanged) {
        popInputHistory();
      }
 else       if (registerTopOutput) {
        myGenerator.addTopOutputNodesByInputNode(inputNode,_outputNodes);
      }
    }
    return outputNodes;
  }
 else   if (nodeMacro instanceof CopySrcNodeMacro || nodeMacro instanceof CopySrcListMacro) {
    List<SNode> newInputNodes=MacroUtil.getNewInputNodes(inputNode,templateNode,nodeMacrosToSkip,myGenerator);
    for (    SNode newInputNode : newInputNodes) {
      generationTracer.pushInputNode(newInputNode);
      List<SNode> _outputNodes=copyNodeFromInputNode(mappingName_,templateNode,newInputNode);
      if (_outputNodes != null)       outputNodes.addAll(_outputNodes);
    }
    return outputNodes;
  }
 else   if (nodeMacro instanceof IfMacro) {
    generationTracer.pushInputNode(inputNode);
    List<SNode> _outputNodes=null;
    if (MacroUtil.checkConditionForIfMacro(inputNode,(IfMacro)nodeMacro,myGenerator)) {
      _outputNodes=createOutputNodesForTemplateNode(mappingName_,templateNode,inputNode,nodeMacrosToSkip + 1,false);
    }
 else {
      RuleConsequence altConsequence=((IfMacro)nodeMacro).getAlternativeConsequence();
      if (altConsequence != null) {
        Pair<SNode,String> nodeAndMappingName=GeneratorUtil.getTemplateNodeFromRuleConsequence(altConsequence,inputNode,nodeMacro.getNode(),myGenerator);
        if (nodeAndMappingName == null) {
          myGenerator.showErrorMessage(inputNode,null,nodeMacro.getNode(),"error processing $IF$/alternative");
          return null;
        }
        SNode altTemplateNode=nodeAndMappingName.o1;
        if (nodeAndMappingName.o2 != null) {
          mappingName_=nodeAndMappingName.o2;
        }
        generationTracer.pushRuleConsequence(altConsequence.getNode());
        _outputNodes=createOutputNodesForExternalTemplateNode(mappingName_,altTemplateNode,inputNode,false);
      }
    }
    if (_outputNodes != null)     outputNodes.addAll(_outputNodes);
    if (registerTopOutput) {
      myGenerator.addTopOutputNodesByInputNode(inputNode,_outputNodes);
    }
    return outputNodes;
  }
 else   if (nodeMacro instanceof MapSrcNodeMacro || nodeMacro instanceof MapSrcListMacro) {
    MapSrcMacro_MapperFunction macro_mapperFunction;
    String mapperId;
    if (nodeMacro instanceof MapSrcNodeMacro) {
      macro_mapperFunction=((MapSrcNodeMacro)nodeMacro).getMapperFunction();
      mapperId=((MapSrcNodeMacro)nodeMacro).getSourceNodeMapperId();
    }
 else {
      macro_mapperFunction=((MapSrcListMacro)nodeMacro).getMapperFunction();
      mapperId=((MapSrcListMacro)nodeMacro).getSourceNodeMapperId();
    }
    List<SNode> newInputNodes=MacroUtil.getNewInputNodes(inputNode,templateNode,nodeMacrosToSkip,myGenerator);
    for (    SNode newInputNode : newInputNodes) {
      generationTracer.pushInputNode(newInputNode);
      if (mapperId != null || macro_mapperFunction != null) {
        SNode childToReplaceLater=SModelUtil_new.instantiateConceptDeclaration(templateNode.getConceptFqName(),myOutputModel,myGenerator.getScope(),false);
        generationTracer.pushOutputNodeToReplaceLater(childToReplaceLater);
        outputNodes.add(childToReplaceLater);
        myGenerator.getDelayedChanges().addExecuteMapSrcNodeMacroChange(nodeMacro,childToReplaceLater,newInputNode,myGenerator);
      }
 else {
        boolean inputChanged=(newInputNode != inputNode);
        if (inputChanged) {
          pushInputHistory(inputNode,mappingName_);
        }
        List<SNode> _outputNodes=createOutputNodesForTemplateNode(mappingName_,templateNode,newInputNode,nodeMacrosToSkip + 1,inputChanged);
        if (_outputNodes != null)         outputNodes.addAll(_outputNodes);
        if (inputChanged) {
          popInputHistory();
        }
 else         if (registerTopOutput) {
          myGenerator.addTopOutputNodesByInputNode(inputNode,_outputNodes);
        }
      }
    }
    return outputNodes;
  }
 else   if (nodeMacro instanceof SwitchMacro) {
    TemplateSwitch templateSwitch=((SwitchMacro)nodeMacro).getTemplateSwitch();
    List<SNode> newInputNodes=MacroUtil.getNewInputNodes(inputNode,templateNode,nodeMacrosToSkip,myGenerator);
    for (    SNode newInputNode : newInputNodes) {
      generationTracer.pushInputNode(newInputNode);
      RuleConsequence consequenceForCase=(RuleConsequence)myGenerator.getConsequenceForSwitchCase(newInputNode,templateSwitch);
      SNode templateNodeForCase=null;
      if (consequenceForCase != null) {
        generationTracer.pushRuleConsequence(consequenceForCase.getNode());
        Pair<SNode,String> nodeAndMappingName=GeneratorUtil.getTemplateNodeFromRuleConsequence(consequenceForCase,newInputNode,nodeMacro.getNode(),myGenerator);
        if (nodeAndMappingName == null) {
          myGenerator.showErrorMessage(newInputNode,nodeMacro.getNode(),consequenceForCase.getNode(),"error processing $SWITCH$");
          return null;
        }
        templateNodeForCase=nodeAndMappingName.o1;
        if (nodeAndMappingName.o2 != null) {
          mappingName_=nodeAndMappingName.o2;
        }
      }
 else {
        generationTracer.pushRule(templateSwitch.getNode());
        TemplateDeclaration templateForSwitchCase=myGenerator.getTemplateForSwitchCase_deprecated(newInputNode,templateSwitch);
        if (templateForSwitchCase != null) {
          TemplateFragment fragment=GeneratorUtil.getFragmentFromTemplate(templateForSwitchCase,newInputNode,nodeMacro.getNode(),myGenerator);
          if (fragment != null) {
            templateNodeForCase=fragment.getParent().getNode();
            if (fragment.getName() != null) {
              mappingName_=fragment.getName();
            }
            if (fragment.getLabelDeclaration() != null) {
              mappingName_=fragment.getLabelDeclaration().getName();
            }
          }
        }
      }
      boolean inputChanged=(newInputNode != inputNode);
      if (inputChanged) {
        pushInputHistory(inputNode,mappingName_);
      }
      List<SNode> _outputNodes;
      if (templateNodeForCase != null) {
        _outputNodes=createOutputNodesForExternalTemplateNode(mappingName_,templateNodeForCase,newInputNode,inputChanged);
      }
 else {
        _outputNodes=createOutputNodesForTemplateNode(mappingName_,templateNode,newInputNode,nodeMacrosToSkip + 1,inputChanged);
      }
      if (_outputNodes != null)       outputNodes.addAll(_outputNodes);
      if (inputChanged) {
        popInputHistory();
      }
 else       if (registerTopOutput) {
        myGenerator.addTopOutputNodesByInputNode(inputNode,_outputNodes);
      }
    }
    return outputNodes;
  }
 else   if (nodeMacro instanceof IncludeMacro) {
    IncludeMacro includeMacro=(IncludeMacro)nodeMacro;
    List<SNode> newInputNodes=MacroUtil.getNewInputNodes(inputNode,templateNode,nodeMacrosToSkip,myGenerator);
    for (    SNode newInputNode : newInputNodes) {
      generationTracer.pushInputNode(newInputNode);
      TemplateDeclaration includeTemplate=includeMacro.getIncludeTemplate();
      if (includeTemplate == null) {
        myGenerator.showErrorMessage(newInputNode,null,nodeMacro.getNode(),"error processing $INCLIDE$ : no 'include template'");
        return null;
      }
      TemplateFragment fragment=GeneratorUtil.getFragmentFromTemplate(includeTemplate,newInputNode,nodeMacro.getNode(),myGenerator);
      if (fragment == null) {
        myGenerator.showErrorMessage(newInputNode,null,nodeMacro.getNode(),"error processing $INCLIDE$");
        return null;
      }
      SNode templateForInclude=fragment.getParent().getNode();
      if (fragment.getName() != null) {
        mappingName_=fragment.getName();
      }
      if (fragment.getLabelDeclaration() != null) {
        mappingName_=fragment.getLabelDeclaration().getName();
      }
      boolean inputChanged=(newInputNode != inputNode);
      if (inputChanged) {
        pushInputHistory(inputNode,mappingName_);
      }
      generationTracer.pushRule(nodeMacro.getNode());
      List<SNode> _outputNodes=createOutputNodesForExternalTemplateNode(mappingName_,templateForInclude,newInputNode,inputChanged);
      if (_outputNodes != null)       outputNodes.addAll(_outputNodes);
      if (inputChanged) {
        popInputHistory();
      }
 else       if (registerTopOutput) {
        myGenerator.addTopOutputNodesByInputNode(inputNode,_outputNodes);
      }
    }
    return outputNodes;
  }
 else {
    List<SNode> newInputNodes=MacroUtil.getNewInputNodes(inputNode,templateNode,nodeMacrosToSkip,myGenerator);
    for (    SNode newInputNode : newInputNodes) {
      generationTracer.pushInputNode(newInputNode);
      boolean inputChanged=(newInputNode != inputNode);
      if (inputChanged) {
        pushInputHistory(inputNode,mappingName_);
      }
      List<SNode> _outputNodes=createOutputNodesForTemplateNode(mappingName_,templateNode,newInputNode,nodeMacrosToSkip + 1,inputChanged);
      if (_outputNodes != null)       outputNodes.addAll(_outputNodes);
      if (inputChanged) {
        popInputHistory();
      }
 else       if (registerTopOutput) {
        myGenerator.addTopOutputNodesByInputNode(inputNode,outputNodes);
      }
    }
    return outputNodes;
  }
}
