{
  int macroCount=0;
  List<SNode> outputNodes=new ArrayList<SNode>();
  for (  INodeAdapter templateChildNode : templateNode.getAdapter().getChildren()) {
    if (!(templateChildNode instanceof NodeMacro))     continue;
    macroCount++;
    if (macroCount <= nodeMacrosToSkip)     continue;
    NodeMacro nodeMacro=(NodeMacro)templateChildNode;
    String mappingName_=nodeMacro.getMappingId() != null ? nodeMacro.getMappingId() : mappingName;
    if (nodeMacro instanceof LoopMacro) {
      List<SNode> newInputNodes=MacroUtil.getNewInputNodes(inputNode,templateNode,nodeMacrosToSkip,myGenerator);
      for (      SNode newInputNode : newInputNodes) {
        boolean inputChanged=(newInputNode != inputNode);
        List<SNode> _outputNodes=createOutputNodesForTemplateNode(mappingName_,templateNode,newInputNode,nodeMacrosToSkip + 1,inputChanged);
        outputNodes.addAll(_outputNodes);
        if (registerTopOutput && !inputChanged) {
          myGenerator.addTopOutputNodesByInputNode(inputNode,_outputNodes);
        }
      }
      return outputNodes;
    }
 else     if (nodeMacro instanceof CopySrcNodeMacro || nodeMacro instanceof CopySrcListMacro) {
      List<SNode> newInputNodes=MacroUtil.getNewInputNodes(inputNode,templateNode,nodeMacrosToSkip,myGenerator);
      for (      SNode newInputNode : newInputNodes) {
        List<SNode> _outputNodes=copyNodeFromInputNode(mappingName_,templateNode,newInputNode);
        outputNodes.addAll(_outputNodes);
      }
      return outputNodes;
    }
 else     if (nodeMacro instanceof IfMacro) {
      List<SNode> _outputNodes=null;
      if (MacroUtil.checkConditionForIfMacro(inputNode,(IfMacro)nodeMacro,myGenerator)) {
        _outputNodes=createOutputNodesForTemplateNode(mappingName_,templateNode,inputNode,nodeMacrosToSkip + 1,false);
      }
 else {
        RuleConsequence altConsequence=((IfMacro)nodeMacro).getAlternativeConsequence();
        if (altConsequence != null) {
          Pair<SNode,String> nodeAndMappingName=GeneratorUtil.getTemplateNodeFromRuleConsequence(altConsequence,inputNode,nodeMacro.getNode(),myGenerator);
          if (nodeAndMappingName == null) {
            myGenerator.showErrorMessage(inputNode,null,nodeMacro.getNode(),"error processing $IF$/alternative");
            throw new TemplateProcessingFailureException();
          }
          SNode altTemplateNode=nodeAndMappingName.o1;
          if (nodeAndMappingName.o2 != null) {
            mappingName_=nodeAndMappingName.o2;
          }
          _outputNodes=createOutputNodesForTemplateNode(mappingName_,altTemplateNode,inputNode,0,false);
        }
      }
      if (_outputNodes != null) {
        outputNodes.addAll(_outputNodes);
        if (registerTopOutput) {
          myGenerator.addTopOutputNodesByInputNode(inputNode,_outputNodes);
        }
      }
      return outputNodes;
    }
 else     if (nodeMacro instanceof MapSrcNodeMacro || nodeMacro instanceof MapSrcListMacro) {
      MapSrcMacro_MapperFunction macro_mapperFunction;
      String mapperId;
      if (nodeMacro instanceof MapSrcNodeMacro) {
        macro_mapperFunction=((MapSrcNodeMacro)nodeMacro).getMapperFunction();
        mapperId=((MapSrcNodeMacro)nodeMacro).getSourceNodeMapperId();
      }
 else {
        macro_mapperFunction=((MapSrcListMacro)nodeMacro).getMapperFunction();
        mapperId=((MapSrcListMacro)nodeMacro).getSourceNodeMapperId();
      }
      List<SNode> newInputNodes=MacroUtil.getNewInputNodes(inputNode,templateNode,nodeMacrosToSkip,myGenerator);
      for (      SNode newInputNode : newInputNodes) {
        boolean inputChanged=(newInputNode != inputNode);
        if (mapperId != null || macro_mapperFunction != null) {
          SNode childToReplaceLater=SModelUtil_new.instantiateConceptDeclaration(templateNode.getConceptFqName(),myOutputModel,myGenerator.getScope(),false);
          outputNodes.add(childToReplaceLater);
          myGenerator.getDelayedChanges().addExecuteMapSrcNodeMacroChange(nodeMacro,childToReplaceLater,newInputNode,myGenerator);
        }
 else {
          List<SNode> _outputNodes=createOutputNodesForTemplateNode(mappingName_,templateNode,newInputNode,nodeMacrosToSkip + 1,inputChanged);
          outputNodes.addAll(_outputNodes);
          if (registerTopOutput && !inputChanged) {
            myGenerator.addTopOutputNodesByInputNode(inputNode,_outputNodes);
          }
        }
      }
      return outputNodes;
    }
 else     if (nodeMacro instanceof SwitchMacro) {
      TemplateSwitch templateSwitch=((SwitchMacro)nodeMacro).getTemplateSwitch();
      List<SNode> newInputNodes=MacroUtil.getNewInputNodes(inputNode,templateNode,macroCount - 1,myGenerator);
      for (      SNode newInputNode : newInputNodes) {
        boolean inputChanged=(newInputNode != inputNode);
        RuleConsequence consequenceForCase=(RuleConsequence)myGenerator.getConsequenceForSwitchCase(newInputNode,templateSwitch);
        SNode templateNodeForCase=null;
        if (consequenceForCase != null) {
          Pair<SNode,String> nodeAndMappingName=GeneratorUtil.getTemplateNodeFromRuleConsequence(consequenceForCase,newInputNode,nodeMacro.getNode(),myGenerator);
          if (nodeAndMappingName == null) {
            myGenerator.showErrorMessage(newInputNode,nodeMacro.getNode(),consequenceForCase.getNode(),"error processing $SWITCH$");
            throw new TemplateProcessingFailureException();
          }
          templateNodeForCase=nodeAndMappingName.o1;
        }
 else {
          TemplateDeclaration templateForSwitchCase=myGenerator.getTemplateForSwitchCase_deprecated(newInputNode,templateSwitch);
          if (templateForSwitchCase != null) {
            TemplateFragment fragment=GeneratorUtil.getFragmentFromTemplate(templateForSwitchCase,newInputNode,nodeMacro.getNode(),myGenerator);
            if (fragment != null) {
              templateNodeForCase=fragment.getParent().getNode();
            }
          }
        }
        List<SNode> _outputNodes;
        if (templateNodeForCase != null) {
          _outputNodes=createOutputNodesForTemplateNode(mappingName_,templateNodeForCase,newInputNode,0,inputChanged);
        }
 else {
          _outputNodes=createOutputNodesForTemplateNode(mappingName_,templateNode,newInputNode,nodeMacrosToSkip + 1,inputChanged);
        }
        outputNodes.addAll(_outputNodes);
        if (registerTopOutput && !inputChanged) {
          myGenerator.addTopOutputNodesByInputNode(inputNode,_outputNodes);
        }
      }
      return outputNodes;
    }
 else     if (nodeMacro instanceof IncludeMacro) {
      IncludeMacro includeMacro=(IncludeMacro)nodeMacro;
      List<SNode> newInputNodes=MacroUtil.getNewInputNodes(inputNode,templateNode,macroCount - 1,myGenerator);
      for (      SNode newInputNode : newInputNodes) {
        boolean inputChanged=(newInputNode != inputNode);
        TemplateDeclaration includeTemplate=includeMacro.getIncludeTemplate();
        if (includeTemplate == null) {
          myGenerator.showErrorMessage(newInputNode,null,nodeMacro.getNode(),"error processing $INCLIDE$ : no 'include template'");
          throw new TemplateProcessingFailureException();
        }
        TemplateFragment fragment=GeneratorUtil.getFragmentFromTemplate(includeTemplate,newInputNode,nodeMacro.getNode(),myGenerator);
        if (fragment == null) {
          myGenerator.showErrorMessage(newInputNode,null,nodeMacro.getNode(),"error processing $INCLIDE$");
          throw new TemplateProcessingFailureException();
        }
        SNode templateForInclude=fragment.getParent().getNode();
        if (fragment.getName() != null) {
          mappingName_=fragment.getName();
        }
        List<SNode> _outputNodes=createOutputNodesForTemplateNode(mappingName_,templateForInclude,newInputNode,0,inputChanged);
        outputNodes.addAll(_outputNodes);
        if (registerTopOutput && !inputChanged) {
          myGenerator.addTopOutputNodesByInputNode(inputNode,_outputNodes);
        }
      }
      return outputNodes;
    }
 else {
      List<SNode> newInputNodes=MacroUtil.getNewInputNodes(inputNode,templateNode,nodeMacrosToSkip,myGenerator);
      for (      SNode newInputNode : newInputNodes) {
        boolean inputChanged=(newInputNode != inputNode);
        List<SNode> _outputNodes=createOutputNodesForTemplateNode(mappingName_,templateNode,newInputNode,nodeMacrosToSkip + 1,inputChanged);
        outputNodes.addAll(_outputNodes);
        if (registerTopOutput && !inputChanged) {
          myGenerator.addTopOutputNodesByInputNode(inputNode,outputNodes);
        }
      }
      return outputNodes;
    }
  }
  SNode outputNode=SModelUtil_new.instantiateConceptDeclaration(templateNode.getConceptFqName(),myOutputModel,myGenerator.getScope(),false);
  if (outputNode == null) {
    myGenerator.showErrorMessage(null,templateNode,"'createOutputNodesForTemplateNode' cannot create output node");
    throw new TemplateProcessingFailureException();
  }
  outputNodes.add(outputNode);
  if (registerTopOutput) {
    myGenerator.addTopOutputNodeByInputNode(inputNode,outputNode);
  }
  myGenerator.addOutputNodeByInputAndTemplateNode(inputNode,templateNode,outputNode);
  myGenerator.addOutputNodeByInputNodeAndMappingName(inputNode,mappingName,outputNode);
  myGenerator.addTemplateNodeByOutputNode(outputNode,templateNode);
  myGenerator.addOutputNodeByTemplateNode(templateNode,outputNode);
  outputNode.putProperties(templateNode);
  SModel templateModel=templateNode.getModel();
  for (  SReference reference : templateNode.getReferences()) {
    if (templateNode.getLinkAttribute("referenceMacro",reference.getRole()) != null) {
      continue;
    }
    SNode templateReferentNode=reference.getTargetNode();
    if (templateReferentNode == null) {
      myGenerator.showErrorMessage(null,templateNode,"'createOutputNodesForTemplateNode()' referent '" + reference.getRole() + "' is null in template model");
      continue;
    }
    if (templateReferentNode.getModel().equals(templateModel)) {
      ReferenceInfo_TemplateNode refInfo=new ReferenceInfo_TemplateNode(outputNode,reference,inputNode);
      PostponedReference postponedReference=new PostponedReference(refInfo,myGenerator);
      outputNode.addReference(postponedReference);
    }
 else {
      outputNode.setReferent(reference.getRole(),templateReferentNode);
    }
  }
  List<INodeAdapter> templateChildNodes=new ArrayList<INodeAdapter>();
  for (  INodeAdapter templateChildNode : templateNode.getAdapter().getChildren()) {
    if (templateChildNode instanceof PropertyMacro) {
      MacroUtil.expandPropertyMacro(myGenerator,(PropertyMacro)templateChildNode,inputNode,templateNode,outputNode);
    }
 else     if (templateChildNode instanceof ReferenceMacro) {
      ReferenceInfo_Macro refInfo=new ReferenceInfo_Macro(outputNode,(ReferenceMacro)templateChildNode,inputNode,templateNode);
      PostponedReference postponedReference=new PostponedReference(refInfo,myGenerator);
      outputNode.addReference(postponedReference);
    }
 else     if (!GeneratorUtil.isTemplateLanguageElement(templateChildNode)) {
      templateChildNodes.add(templateChildNode);
    }
  }
  for (  INodeAdapter templateChildNode : templateChildNodes) {
    List<SNode> outputChildNodes=createOutputNodesForTemplateNode(null,templateChildNode.getNode(),inputNode,0,false);
    if (outputChildNodes != null) {
      String role=templateChildNode.getRole_();
      for (      SNode outputChildNode : outputChildNodes) {
        outputNode.addChild(role,outputChildNode);
      }
    }
  }
  return outputNodes;
}
