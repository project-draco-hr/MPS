{
  final Map<RefactoringParticipant,Map<T,RefactoringParticipant.ParticipantState<?,?,T,S>>> changes=MapSequence.fromMap(new HashMap<RefactoringParticipant,Map<T,RefactoringParticipant.ParticipantState<?,?,T,S>>>());
  final Wrappers._T<List<RefactoringParticipant.Option>> options=new Wrappers._T<List<RefactoringParticipant.Option>>();
  project.getRepository().getModelAccess().runReadAction(new Runnable(){
    public void run(){
      for (      RefactoringParticipant<?,?,T,S> participant : Sequence.fromIterable(participants)) {
        Map<T,RefactoringParticipant.ParticipantState<?,?,T,S>> participantStates=MapSequence.fromMap(new HashMap<T,RefactoringParticipant.ParticipantState<?,?,T,S>>());
        MapSequence.fromMap(changes).put(participant,participantStates);
        for (        T node : Sequence.fromIterable(nodes)) {
          MapSequence.fromMap(participantStates).put(node,RefactoringParticipant.ParticipantState.create(participant,node));
        }
      }
      options.value=MapSequence.fromMap(changes).translate(new ITranslator2<IMapping<RefactoringParticipant,Map<T,RefactoringParticipant.ParticipantState<?,?,T,S>>>,RefactoringParticipant.Option>(){
        public Iterable<RefactoringParticipant.Option> translate(        IMapping<RefactoringParticipant,Map<T,RefactoringParticipant.ParticipantState<?,?,T,S>>> it){
          return MapSequence.fromMap(it.value()).translate(new ITranslator2<IMapping<T,RefactoringParticipant.ParticipantState<?,?,T,S>>,RefactoringParticipant.Option>(){
            public Iterable<RefactoringParticipant.Option> translate(            IMapping<T,RefactoringParticipant.ParticipantState<?,?,T,S>> it){
              return it.value().getAvaliableOptions(project.getRepository());
            }
          }
);
        }
      }
).distinct().sort(new ISelector<RefactoringParticipant.Option,String>(){
        public String select(        RefactoringParticipant.Option it){
          return it.getDescription();
        }
      }
,true).toListSequence();
    }
  }
);
  List<Integer> selectedOptionIndices;
  if (ListSequence.fromList(options.value).isNotEmpty()) {
    selectedOptionIndices=SelectOptionsDialog.selectOptions(ProjectHelper.toIdeaProject(project),ListSequence.fromList(options.value).select(new ISelector<RefactoringParticipant.Option,String>(){
      public String select(      RefactoringParticipant.Option it){
        return it.getDescription();
      }
    }
).toListSequence(),"Refactoring Options");
  }
 else {
    selectedOptionIndices=ListSequence.fromList(new ArrayList<Integer>());
  }
  if (selectedOptionIndices == null) {
    return null;
  }
  final List<RefactoringParticipant.Option> selectedOptions=ListSequence.fromList(selectedOptionIndices).select(new ISelector<Integer,RefactoringParticipant.Option>(){
    public RefactoringParticipant.Option select(    Integer i){
      return ListSequence.fromList(options.value).getElement(i);
    }
  }
).toListSequence();
  final Wrappers._boolean cancelled=new Wrappers._boolean(false);
  ProgressManager.getInstance().run(new Task.Modal(project.getProject(),"Refactoring",true){
    public void run(    @NotNull ProgressIndicator progressIndicator){
      final ProgressMonitorAdapter progressMonitor=new ProgressMonitorAdapter(progressIndicator);
      project.getRepository().getModelAccess().runReadAction(new Runnable(){
        public void run(){
          int steps=MapSequence.fromMap(changes).select(new ISelector<IMapping<RefactoringParticipant,Map<SNodeReference,RefactoringParticipant.ParticipantState<?,?,SNode,SNode>>>,Integer>(){
            public Integer select(            IMapping<RefactoringParticipant,Map<SNodeReference,RefactoringParticipant.ParticipantState<?,?,SNode,SNode>>> pss){
              return MapSequence.fromMap(pss.value()).count();
            }
          }
).foldLeft(0,new ILeftCombinator<Integer,Integer>(){
            public Integer combine(            Integer s,            Integer it){
              return it + s;
            }
          }
);
          progressMonitor.start("Searching for usages",steps);
          outer:           for (          IMapping<RefactoringParticipant,Map<SNodeReference,RefactoringParticipant.ParticipantState<?,?,SNode,SNode>>> participantStates : MapSequence.fromMap(changes)) {
            for (            IMapping<SNodeReference,RefactoringParticipant.ParticipantState<?,?,SNode,SNode>> participantState : MapSequence.fromMap(participantStates.value())) {
              if (progressMonitor.isCanceled()) {
                cancelled.value=true;
                break outer;
              }
              participantState.value().findChanges(project.getRepository(),selectedOptions,project.getScope(),progressMonitor.subTask(1,SubProgressKind.AS_COMMENT));
            }
          }
          progressMonitor.done();
        }
      }
);
    }
  }
);
  SearchResults searchResults=new SearchResults();
  for (  IMapping<RefactoringParticipant,Map<T,RefactoringParticipant.ParticipantState<?,?,T,S>>> participantChanges : MapSequence.fromMap(changes)) {
    for (    IMapping<T,RefactoringParticipant.ParticipantState<?,?,T,S>> nodeChanges : MapSequence.fromMap(participantChanges.value())) {
      for (      RefactoringParticipant.Change<?,?> change : ListSequence.fromList(nodeChanges.value().getChanges())) {
        searchResults.addAll(change.getSearchResults());
      }
    }
  }
  RefactoringAccessEx.getInstance().showRefactoringView(project.getProject(),new RefactoringViewAction(){
    public void performAction(    RefactoringViewItem refactoringViewItem){
      project.getRepository().getModelAccess().executeCommand(new Runnable(){
        public void run(){
          RefactoringSessionImpl refactoringSession=new RefactoringSessionImpl();
          _FunctionTypes._return_P1_E0<? extends S,? super T> getFinalObject=doRefactor.invoke(changes,refactoringSession);
          for (          IMapping<RefactoringParticipant,Map<T,RefactoringParticipant.ParticipantState<?,?,T,S>>> participantChanges : MapSequence.fromMap(changes)) {
            for (            IMapping<T,RefactoringParticipant.ParticipantState<?,?,T,S>> nodeChanges : MapSequence.fromMap(participantChanges.value())) {
              nodeChanges.value().confirm(getFinalObject.invoke(nodeChanges.key()),project.getRepository(),refactoringSession);
            }
          }
          try {
            refactoringSession.commit();
          }
 catch (          RuntimeException exception) {
            if (LOG.isEnabledFor(Level.ERROR)) {
              LOG.error("Exception during refactoring: ",exception);
            }
          }
        }
      }
);
      refactoringViewItem.close();
    }
  }
,searchResults,false,"Move nodes");
}
