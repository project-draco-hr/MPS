{
  project.getRepository().getModelAccess().runReadAction(new Runnable(){
    public void run(){
      for (      IMapping<SNodeReference,MoveNodesDefault.NodeProcessor> moving : MapSequence.fromMap(moveMap)) {
        SNode node=resolveNode(moving.key(),project);
        if (!(moving.value().isValid(node))) {
          throw new IllegalArgumentException();
        }
      }
    }
  }
);
  final Map<RefactoringParticipant,RefactoringParticipant.ParticipantState<?,?,SNode,SNode>> changes=MapSequence.fromMap(new HashMap<RefactoringParticipant,RefactoringParticipant.ParticipantState<?,?,SNode,SNode>>());
  final Map<SNodeReference,SNodeReference> nodeRoots=MapSequence.fromMap(new HashMap<SNodeReference,SNodeReference>());
  final Wrappers._T<List<SNodeReference>> allNodes=new Wrappers._T<List<SNodeReference>>();
  final Wrappers._T<List<RefactoringParticipant.Option>> options=new Wrappers._T<List<RefactoringParticipant.Option>>();
  project.getRepository().getModelAccess().runReadAction(new Runnable(){
    public void run(){
      for (      SNodeReference nodeToMove : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {
        for (        SNodeReference descendant : ListSequence.fromList(SNodeOperations.getNodeDescendants(resolveNode(nodeToMove,project),null,true,new SAbstractConcept[]{})).select(new ISelector<SNode,SNodeReference>(){
          public SNodeReference select(          SNode it){
            return it.getReference();
          }
        }
)) {
          MapSequence.fromMap(nodeRoots).put(descendant,nodeToMove);
        }
      }
      allNodes.value=SetSequence.fromSet(MapSequence.fromMap(nodeRoots).keySet()).toListSequence();
      for (      MoveNodeRefactoringParticipant<?,?> participant : Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?,?>>("jetbrains.mps.ide.platform.MoveNodeParticipantEP").getObjects()).toListSequence()) {
        RefactoringParticipant.ParticipantState<?,?,SNode,SNode> participantState;
        MapSequence.fromMap(changes).put(participant,RefactoringParticipant.ParticipantState.create(participant,ListSequence.fromList(allNodes.value).select(new ISelector<SNodeReference,SNode>(){
          public SNode select(          SNodeReference it){
            return resolveNode(it,project);
          }
        }
).toListSequence()));
      }
      options.value=MapSequence.fromMap(changes).translate(new ITranslator2<IMapping<RefactoringParticipant,RefactoringParticipant.ParticipantState<?,?,SNode,SNode>>,RefactoringParticipant.Option>(){
        public Iterable<RefactoringParticipant.Option> translate(        IMapping<RefactoringParticipant,RefactoringParticipant.ParticipantState<?,?,SNode,SNode>> it){
          return it.value().getAvaliableOptions(project.getRepository());
        }
      }
).distinct().sort(new ISelector<RefactoringParticipant.Option,String>(){
        public String select(        RefactoringParticipant.Option it){
          return it.getDescription();
        }
      }
,true).toListSequence();
    }
  }
);
  List<Integer> selectedOptionIndices;
  if (ListSequence.fromList(options.value).isNotEmpty()) {
    selectedOptionIndices=SelectOptionsDialog.selectOptions(ProjectHelper.toIdeaProject(project),ListSequence.fromList(options.value).select(new ISelector<RefactoringParticipant.Option,String>(){
      public String select(      RefactoringParticipant.Option it){
        return it.getDescription();
      }
    }
).toListSequence(),"Refactoring Options");
  }
 else {
    selectedOptionIndices=ListSequence.fromList(new ArrayList<Integer>());
  }
  if (selectedOptionIndices == null) {
    return;
  }
  final List<RefactoringParticipant.Option> selectedOptions=ListSequence.fromList(selectedOptionIndices).select(new ISelector<Integer,RefactoringParticipant.Option>(){
    public RefactoringParticipant.Option select(    Integer i){
      return ListSequence.fromList(options.value).getElement(i);
    }
  }
).toListSequence();
  final Wrappers._boolean cancelled=new Wrappers._boolean(false);
  ProgressManager.getInstance().run(new Task.Modal(project.getProject(),"Refactoring",true){
    public void run(    @NotNull ProgressIndicator progressIndicator){
      final ProgressMonitorAdapter progressMonitor=new ProgressMonitorAdapter(progressIndicator);
      project.getRepository().getModelAccess().runReadAction(new Runnable(){
        public void run(){
          int steps=MapSequence.fromMap(changes).count();
          progressMonitor.start("Searching for usages",steps);
          for (          IMapping<RefactoringParticipant,RefactoringParticipant.ParticipantState<?,?,SNode,SNode>> participantState : MapSequence.fromMap(changes)) {
            participantState.value().findChanges(project.getRepository(),selectedOptions,project.getScope(),progressMonitor.subTask(1,SubProgressKind.AS_COMMENT));
            if (progressMonitor.isCanceled()) {
              cancelled.value=true;
              break;
            }
          }
          progressMonitor.done();
        }
      }
);
    }
  }
);
  if (cancelled.value) {
    return;
  }
  SearchResults searchResults=new SearchResults();
  final Map<SNodeReference,Boolean> shouldKeep=MapSequence.fromMap(new HashMap<SNodeReference,Boolean>());
  for (  SNodeReference node : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {
    MapSequence.fromMap(shouldKeep).put(node,false);
  }
  for (  IMapping<RefactoringParticipant,RefactoringParticipant.ParticipantState<?,?,SNode,SNode>> participantState : MapSequence.fromMap(changes)) {
    List<? extends List<? extends RefactoringParticipant.Change<?,?>>> nodesChanges=participantState.value().getChanges();
    for (int i=0; i < ListSequence.fromList(allNodes.value).count(); i++) {
      for (      RefactoringParticipant.Change<?,?> change : ListSequence.fromList(ListSequence.fromList(nodesChanges).getElement(i))) {
        MapSequence.fromMap(shouldKeep).putValue(MapSequence.fromMap(nodeRoots).get(ListSequence.fromList(allNodes.value).getElement(i)),MapSequence.fromMap(shouldKeep).get(MapSequence.fromMap(nodeRoots).get(ListSequence.fromList(allNodes.value).getElement(i))) || (change.needsToPreserveOldNode()));
        searchResults.addAll(change.getSearchResults());
      }
    }
  }
  RefactoringAccessEx.getInstance().showRefactoringView(project.getProject(),new RefactoringViewAction(){
    public void performAction(    RefactoringViewItem refactoringViewItem){
      project.getRepository().getModelAccess().executeCommand(new Runnable(){
        public void run(){
          RefactoringSessionImpl refactoringSession=new RefactoringSessionImpl();
          if (initRefactoringSession != null) {
            initRefactoringSession.invoke(refactoringSession);
          }
          final Map<SNode,SNode> copyMap=MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).getCopyMap();
          final Map<SNodeReference,SNode> resolveMap=MapSequence.fromMap(new HashMap<SNodeReference,SNode>());
          List<SNodeReference> nodesToMove=ListSequence.fromList(new ArrayList<SNodeReference>());
          for (          SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(nodeRoots).keySet())) {
            MapSequence.fromMap(resolveMap).put(nodeRef,resolveNode(nodeRef,project));
          }
          for (          SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {
            ListSequence.fromList(nodesToMove).addElement(nodeRef);
          }
          final Map<MoveNodesDefault.NodeProcessor,List<SNode>> nodeProcessors=MapSequence.fromMap(new HashMap<MoveNodesDefault.NodeProcessor,List<SNode>>());
          ListSequence.fromList(nodesToMove).visitAll(new IVisitor<SNodeReference>(){
            public void visit(            SNodeReference it){
              MoveNodesDefault.NodeProcessor processor=MapSequence.fromMap(moveMap).get(it);
              if (!(MapSequence.fromMap(nodeProcessors).containsKey(processor))) {
                MapSequence.fromMap(nodeProcessors).put(processor,ListSequence.fromList(new ArrayList<SNode>()));
              }
              ListSequence.fromList(MapSequence.fromMap(nodeProcessors).get(processor)).addElement(MapSequence.fromMap(resolveMap).get(it));
            }
          }
);
          for (          IMapping<MoveNodesDefault.NodeProcessor,List<SNode>> mapping : MapSequence.fromMap(nodeProcessors)) {
            mapping.key().process(mapping.value(),ListSequence.fromList(mapping.value()).where(new IWhereFilter<SNode>(){
              public boolean accept(              SNode it){
                return !(MapSequence.fromMap(shouldKeep).get(it.getReference()));
              }
            }
).toListSequence(),refactoringSession);
          }
          for (          IMapping<RefactoringParticipant,RefactoringParticipant.ParticipantState<?,?,SNode,SNode>> participantState : MapSequence.fromMap(changes)) {
            participantState.value().doRefactor(ListSequence.fromList(allNodes.value).select(new ISelector<SNodeReference,SNode>(){
              public SNode select(              SNodeReference it){
                return MapSequence.fromMap(copyMap).get(MapSequence.fromMap(resolveMap).get(it));
              }
            }
).toListSequence(),project.getRepository(),refactoringSession);
          }
          try {
            refactoringSession.commit();
          }
 catch (          RuntimeException exception) {
            if (LOG.isEnabledFor(Level.ERROR)) {
              LOG.error("Exception during refactoring: ",exception);
            }
          }
        }
      }
);
      refactoringViewItem.close();
    }
  }
,searchResults,false,"Move nodes");
}
