{
  project.getRepository().getModelAccess().runReadAction(new Runnable(){
    public void run(){
      for (      IMapping<SNodeReference,NodeLocation> moving : MapSequence.fromMap(moveMap)) {
        SNode node=resolveNode(moving.key(),project);
        if (!(moving.value().canInsert(project.getRepository(),node))) {
          throw new IllegalArgumentException();
        }
      }
    }
  }
);
  final Map<MoveNodeRefactoringParticipant,Map<SNodeReference,MoveNodeRefactoringParticipant.MoveNodeParticipantState<?,?>>> changes=MapSequence.fromMap(new HashMap<MoveNodeRefactoringParticipant,Map<SNodeReference,MoveNodeRefactoringParticipant.MoveNodeParticipantState<?,?>>>());
  final Map<SNodeReference,SNodeReference> nodeRoots=MapSequence.fromMap(new HashMap<SNodeReference,SNodeReference>());
  project.getRepository().getModelAccess().runReadAction(new Runnable(){
    public void run(){
      for (      SNodeReference nodeToMove : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {
        for (        SNodeReference descendant : ListSequence.fromList(SNodeOperations.getNodeDescendants(resolveNode(nodeToMove,project),null,true,new SAbstractConcept[]{})).select(new ISelector<SNode,SNodeReference>(){
          public SNodeReference select(          SNode it){
            return it.getReference();
          }
        }
)) {
          MapSequence.fromMap(nodeRoots).put(descendant,nodeToMove);
        }
      }
      for (      MoveNodeRefactoringParticipant<?,?> participant : Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?,?>>("jetbrains.mps.ide.platform.MoveNodeParticipantEP").getObjects()).toListSequence()) {
        Map<SNodeReference,MoveNodeRefactoringParticipant.MoveNodeParticipantState<?,?>> participantChanges=MapSequence.fromMap(new HashMap<SNodeReference,MoveNodeRefactoringParticipant.MoveNodeParticipantState<?,?>>());
        MapSequence.fromMap(changes).put(participant,participantChanges);
        for (        SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(nodeRoots).keySet())) {
          MapSequence.fromMap(participantChanges).put(nodeRef,MoveNodeRefactoringParticipant.MoveNodeParticipantState.create(participant,resolveNode(nodeRef,project),project.getRepository(),project.getScope()));
        }
      }
    }
  }
);
  List<IMapping<MoveNodeRefactoringParticipant,Map<SNodeReference,MoveNodeRefactoringParticipant.MoveNodeParticipantState<?,?>>>> changesAsList=MapSequence.fromMap(changes).where(new IWhereFilter<IMapping<MoveNodeRefactoringParticipant,Map<SNodeReference,MoveNodeRefactoringParticipant.MoveNodeParticipantState<?,?>>>>(){
    public boolean accept(    IMapping<MoveNodeRefactoringParticipant,Map<SNodeReference,MoveNodeRefactoringParticipant.MoveNodeParticipantState<?,?>>> it){
      return MapSequence.fromMap(it.value()).isNotEmpty();
    }
  }
).toListSequence();
  List<Integer> selectedOptions=SelectOptionsDialog.selectOptions(ProjectHelper.toIdeaProject(project),ListSequence.fromList(changesAsList).select(new ISelector<IMapping<MoveNodeRefactoringParticipant,Map<SNodeReference,MoveNodeRefactoringParticipant.MoveNodeParticipantState<?,?>>>,String>(){
    public String select(    IMapping<MoveNodeRefactoringParticipant,Map<SNodeReference,MoveNodeRefactoringParticipant.MoveNodeParticipantState<?,?>>> it){
      return it.key().getDescription();
    }
  }
).toListSequence(),"Select Participants");
  if (selectedOptions == null) {
    return;
  }
  final Map<MoveNodeRefactoringParticipant,Map<SNodeReference,MoveNodeRefactoringParticipant.MoveNodeParticipantState<?,?>>> selectedChanges=MapSequence.fromMap(new HashMap<MoveNodeRefactoringParticipant,Map<SNodeReference,MoveNodeRefactoringParticipant.MoveNodeParticipantState<?,?>>>());
  for (  int i : selectedOptions) {
    IMapping<MoveNodeRefactoringParticipant,Map<SNodeReference,MoveNodeRefactoringParticipant.MoveNodeParticipantState<?,?>>> mapping=ListSequence.fromList(changesAsList).getElement(i);
    MapSequence.fromMap(selectedChanges).put(mapping.key(),mapping.value());
  }
  SearchResults searchResults=new SearchResults();
  final Map<SNodeReference,Boolean> shouldKeep=MapSequence.fromMap(new HashMap<SNodeReference,Boolean>());
  for (  SNodeReference node : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {
    MapSequence.fromMap(shouldKeep).put(node,false);
  }
  for (  IMapping<MoveNodeRefactoringParticipant,Map<SNodeReference,MoveNodeRefactoringParticipant.MoveNodeParticipantState<?,?>>> participantChanges : MapSequence.fromMap(selectedChanges)) {
    for (    IMapping<SNodeReference,MoveNodeRefactoringParticipant.MoveNodeParticipantState<?,?>> nodeChanges : MapSequence.fromMap(participantChanges.value())) {
      for (      RefactoringParticipant.Change<?,?> change : ListSequence.fromList(nodeChanges.value().getChanges())) {
        MapSequence.fromMap(shouldKeep).putValue(MapSequence.fromMap(nodeRoots).get(nodeChanges.key()),MapSequence.fromMap(shouldKeep).get(MapSequence.fromMap(nodeRoots).get(nodeChanges.key())) || (change.needsToPreserveOldNode()));
        searchResults.addAll(change.getSearchResults());
      }
    }
  }
  RefactoringAccessEx.getInstance().showRefactoringView(project.getProject(),new RefactoringViewAction(){
    public void performAction(    RefactoringViewItem refactoringViewItem){
      project.getRepository().getModelAccess().executeCommand(new Runnable(){
        public void run(){
          if (callBack != null) {
            callBack.run();
          }
          RefactoringSessionImpl refactoringSession=new RefactoringSessionImpl();
          Map<SNode,SNode> copyMap=MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).getCopyMap();
          final Map<SNodeReference,SNode> resolveMap=MapSequence.fromMap(new HashMap<SNodeReference,SNode>());
          List<SNodeReference> nodesToMove=ListSequence.fromList(new ArrayList<SNodeReference>());
          for (          SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(nodeRoots).keySet())) {
            MapSequence.fromMap(resolveMap).put(nodeRef,resolveNode(nodeRef,project));
          }
          for (          SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(moveMap).keySet())) {
            ListSequence.fromList(nodesToMove).addElement(nodeRef);
          }
          MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).copy(ListSequence.fromList(nodesToMove).select(new ISelector<SNodeReference,SNode>(){
            public SNode select(            SNodeReference it){
              return MapSequence.fromMap(resolveMap).get(it);
            }
          }
).toListSequence(),ListSequence.fromList(nodesToMove).select(new ISelector<SNodeReference,Boolean>(){
            public Boolean select(            SNodeReference it){
              return MapSequence.fromMap(shouldKeep).get(it);
            }
          }
).toListSequence());
{
            Iterator<SNodeReference> oldNode_it=ListSequence.fromList(nodesToMove).iterator();
            SNodeReference oldNode_var;
            while (oldNode_it.hasNext()) {
              oldNode_var=oldNode_it.next();
              MapSequence.fromMap(moveMap).get(oldNode_var).insertNode(project.getRepository(),MapSequence.fromMap(copyMap).get(MapSequence.fromMap(resolveMap).get(oldNode_var)));
            }
          }
          for (          IMapping<MoveNodeRefactoringParticipant,Map<SNodeReference,MoveNodeRefactoringParticipant.MoveNodeParticipantState<?,?>>> participantChanges : MapSequence.fromMap(selectedChanges)) {
            for (            IMapping<SNodeReference,MoveNodeRefactoringParticipant.MoveNodeParticipantState<?,?>> nodeChanges : MapSequence.fromMap(participantChanges.value())) {
              nodeChanges.value().confirm(MapSequence.fromMap(copyMap).get(MapSequence.fromMap(resolveMap).get(nodeChanges.key())),project.getRepository(),refactoringSession);
            }
          }
          try {
            refactoringSession.commit();
          }
 catch (          RuntimeException exception) {
            if (LOG.isEnabledFor(Level.ERROR)) {
              LOG.error("Exception during refactoring: ",exception);
            }
          }
        }
      }
);
      refactoringViewItem.close();
    }
  }
,searchResults,false,"Move nodes");
}
