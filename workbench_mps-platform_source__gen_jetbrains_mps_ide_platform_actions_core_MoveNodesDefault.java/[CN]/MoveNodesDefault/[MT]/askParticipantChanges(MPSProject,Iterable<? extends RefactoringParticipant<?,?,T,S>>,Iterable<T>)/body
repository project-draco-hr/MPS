{
  final Map<RefactoringParticipant,Map<T,RefactoringParticipant.ParticipantState<?,?,T,S>>> changes=MapSequence.fromMap(new HashMap<RefactoringParticipant,Map<T,RefactoringParticipant.ParticipantState<?,?,T,S>>>());
  final Wrappers._T<List<RefactoringParticipant.Option>> options=new Wrappers._T<List<RefactoringParticipant.Option>>();
  project.getRepository().getModelAccess().runReadAction(new Runnable(){
    public void run(){
      for (      RefactoringParticipant<?,?,T,S> participant : Sequence.fromIterable(participants)) {
        Map<T,RefactoringParticipant.ParticipantState<?,?,T,S>> participantStates=MapSequence.fromMap(new HashMap<T,RefactoringParticipant.ParticipantState<?,?,T,S>>());
        MapSequence.fromMap(changes).put(participant,participantStates);
        for (        T node : Sequence.fromIterable(nodes)) {
          MapSequence.fromMap(participantStates).put(node,RefactoringParticipant.ParticipantState.create(participant,node));
        }
      }
      options.value=MapSequence.fromMap(changes).translate(new ITranslator2<IMapping<RefactoringParticipant,Map<T,RefactoringParticipant.ParticipantState<?,?,T,S>>>,RefactoringParticipant.Option>(){
        public Iterable<RefactoringParticipant.Option> translate(        IMapping<RefactoringParticipant,Map<T,RefactoringParticipant.ParticipantState<?,?,T,S>>> it){
          return MapSequence.fromMap(it.value()).translate(new ITranslator2<IMapping<T,RefactoringParticipant.ParticipantState<?,?,T,S>>,RefactoringParticipant.Option>(){
            public Iterable<RefactoringParticipant.Option> translate(            IMapping<T,RefactoringParticipant.ParticipantState<?,?,T,S>> it){
              return it.value().getAvaliableOptions(project.getRepository());
            }
          }
);
        }
      }
).distinct().sort(new ISelector<RefactoringParticipant.Option,String>(){
        public String select(        RefactoringParticipant.Option it){
          return it.getDescription();
        }
      }
,true).toListSequence();
    }
  }
);
  List<Integer> selectedOptionIndices;
  if (ListSequence.fromList(options.value).isNotEmpty()) {
    selectedOptionIndices=SelectOptionsDialog.selectOptions(ProjectHelper.toIdeaProject(project),ListSequence.fromList(options.value).select(new ISelector<RefactoringParticipant.Option,String>(){
      public String select(      RefactoringParticipant.Option it){
        return it.getDescription();
      }
    }
).toListSequence(),"Refactoring Options","Select participants to execute");
  }
 else {
    selectedOptionIndices=ListSequence.fromList(new ArrayList<Integer>());
  }
  if (selectedOptionIndices == null) {
    return null;
  }
  final List<RefactoringParticipant.Option> selectedOptions=ListSequence.fromList(selectedOptionIndices).select(new ISelector<Integer,RefactoringParticipant.Option>(){
    public RefactoringParticipant.Option select(    Integer i){
      return ListSequence.fromList(options.value).getElement(i);
    }
  }
).toListSequence();
  final Wrappers._boolean cancelled=new Wrappers._boolean(false);
  ProgressManager.getInstance().run(new Task.Modal(project.getProject(),"Refactoring",true){
    public void run(    @NotNull ProgressIndicator progressIndicator){
      final ProgressMonitorAdapter progressMonitor=new ProgressMonitorAdapter(progressIndicator);
      project.getRepository().getModelAccess().runReadAction(new Runnable(){
        public void run(){
          int steps=MapSequence.fromMap(changes).select(new ISelector<IMapping<RefactoringParticipant,Map<T,RefactoringParticipant.ParticipantState<?,?,T,S>>>,Integer>(){
            public Integer select(            IMapping<RefactoringParticipant,Map<T,RefactoringParticipant.ParticipantState<?,?,T,S>>> pss){
              return MapSequence.fromMap(pss.value()).count();
            }
          }
).foldLeft(0,new ILeftCombinator<Integer,Integer>(){
            public Integer combine(            Integer s,            Integer it){
              return it + s;
            }
          }
);
          progressMonitor.start("Searching for usages",steps);
          outer:           for (          IMapping<RefactoringParticipant,Map<T,RefactoringParticipant.ParticipantState<?,?,T,S>>> participantStates : MapSequence.fromMap(changes)) {
            for (            IMapping<T,RefactoringParticipant.ParticipantState<?,?,T,S>> participantState : MapSequence.fromMap(participantStates.value())) {
              if (progressMonitor.isCanceled()) {
                cancelled.value=true;
                break outer;
              }
              participantState.value().findChanges(project.getRepository(),selectedOptions,project.getScope(),progressMonitor.subTask(1,SubProgressKind.AS_COMMENT));
            }
          }
          progressMonitor.done();
        }
      }
);
    }
  }
);
  if (cancelled.value) {
    return null;
  }
  return changes;
}
