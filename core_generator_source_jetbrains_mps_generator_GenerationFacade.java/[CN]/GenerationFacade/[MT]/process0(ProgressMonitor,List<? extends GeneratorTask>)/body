{
  final boolean[] result=new boolean[1];
  myTransientModelsProvider.startGeneration(myGenerationOptions.getNumberOfModelsToKeep());
  final GeneratorLoggerAdapter logger=new GeneratorLoggerAdapter(myMessageHandler,myGenerationOptions.isShowInfo(),myGenerationOptions.isShowWarnings());
  myRepository.getModelAccess().runWriteAction(new Runnable(){
    @Override public void run(){
      for (      GeneratorTask t : tasks) {
        SModel d=t.getModel();
        if (d instanceof EditableSModel && ((EditableSModel)d).needsReloading()) {
          ((EditableSModel)d).reloadFromSource();
          logger.info("Model " + d + " reloaded from disk.");
        }
        myTransientModelsProvider.createModule(d.getModule());
      }
    }
  }
);
  myTransientModelsProvider.initCheckpointModule();
  GenControllerContext ctx=new GenControllerContext(myRepository,myGenerationOptions,myTransientModelsProvider,myStreamProvider);
  GeneratorTaskListener<GeneratorTask> taskListener;
  if (myTaskListener != null) {
    taskListener=myTaskListener;
  }
 else {
    taskListener=new EmptyTaskListener();
  }
  final GenerationController gc=new GenerationController(tasks,ctx,taskListener,logger);
  myRepository.getModelAccess().runReadAction(new Runnable(){
    @Override public void run(){
      result[0]=UndoHelper.getInstance().runNonUndoableAction(new Computable<Boolean>(){
        @Override public Boolean compute(){
          return gc.generate(monitor);
        }
      }
);
    }
  }
);
  myTransientModelsProvider.publishAll();
  CleanupManager.getInstance().cleanup();
  return result[0];
}
