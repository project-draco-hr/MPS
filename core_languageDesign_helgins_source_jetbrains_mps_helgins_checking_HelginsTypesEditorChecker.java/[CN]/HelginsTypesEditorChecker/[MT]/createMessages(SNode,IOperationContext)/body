{
  Set<EditorMessage> messages=new LinkedHashSet<EditorMessage>();
  if (!TypeChecker.getInstance().isCheckedRoot(node.getContainingRoot())) {
    try {
      TypeChecker.getInstance().checkRoot(node.getContainingRoot());
    }
 catch (    Throwable t) {
      LOG.error(t);
      TypeChecker.getInstance().markAsChecked(node.getContainingRoot());
      return messages;
    }
  }
  NodeTypesComponent typesComponent=getNodeTypesComponent(node);
  try {
    TypeChecker.getInstance().checkWithNonTypesystemRules(typesComponent);
  }
 catch (  Throwable t) {
    LOG.error(t);
  }
  for (  Pair<SNode,IErrorReporter> errorNode : typesComponent.getNodesWithErrorStrings()) {
    MessageStatus status=MessageStatus.ERROR;
    Color color=Color.red;
    if (errorNode.o2.isWarning()) {
      status=MessageStatus.WARNING;
      color=Color.YELLOW;
    }
    String errorString=errorNode.o2.reportError();
    DefaultEditorMessage message=new HighlighterMessage(errorNode.o1,status,color,"TYPE ERROR: " + errorString,typesComponent);
    IntentionProvider intentionProvider=errorNode.o2.getIntentionProvider();
    if (intentionProvider != null && intentionProvider.isExecutedImmediately()) {
      final QuickFix_Runtime intention=intentionProvider.getQuickFix();
      if (intention != null) {
        ThreadUtils.runInUIThreadNoWait(new Runnable(){
          public void run(){
            ModelAccess.instance().runWriteActionInCommand(new Runnable(){
              public void run(){
                intention.execute(node);
              }
            }
);
          }
        }
);
      }
    }
 else {
      message.setIntentionProvider(intentionProvider);
    }
    messages.add(message);
  }
  return messages;
}
