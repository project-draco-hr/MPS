{
  Set<IEditorMessage> messages=new LinkedHashSet<IEditorMessage>();
  if (!TypeChecker.getInstance().isCheckedRoot(node.getContainingRoot())) {
    try {
      TypeChecker.getInstance().checkRoot(node.getContainingRoot());
    }
 catch (    Throwable t) {
      LOG.error(t);
      TypeChecker.getInstance().markAsChecked(node.getContainingRoot());
      return messages;
    }
  }
  NodeTypesComponent typesComponent=getNodeTypesComponent(node);
  for (  Pair<SNode,IErrorReporter> errorNode : typesComponent.getNodesWithErrorStrings()) {
    IntentionProvider intentionProvider=errorNode.o2.getIntentionProvider();
    if (intentionProvider != null && intentionProvider.isExecutedImmediately()) {
      final Intention intention=intentionProvider.getIntention();
      ModelAccess.instance().runWriteActionInCommand(new Runnable(){
        public void run(){
          intention.execute(node,null);
        }
      }
);
    }
 else {
      MessageStatus status=MessageStatus.ERROR;
      Color color=Color.red;
      if (errorNode.o2.isWarning()) {
        status=MessageStatus.WARNING;
        color=Color.YELLOW;
      }
      String errorString=errorNode.o2.reportError();
      DefaultEditorMessage message=new HighlighterMessage(errorNode.o1,status,color,"TYPE ERROR: " + errorString,typesComponent);
      message.setIntentionProvider(intentionProvider);
      messages.add(message);
    }
  }
  return messages;
}
