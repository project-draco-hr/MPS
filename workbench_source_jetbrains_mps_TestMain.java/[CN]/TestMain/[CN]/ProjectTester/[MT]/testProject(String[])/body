{
  ClassLoaderManager.getInstance().reloadAll(new EmptyProgressMonitor());
  final List<String> errors=new ArrayList<String>();
  final List<String> warnings=new ArrayList<String>();
  final List<String> compilationResults=new ArrayList<String>();
  final List<TestFailure> failedTests=new ArrayList<TestFailure>();
  final List<String> diffReports=new ArrayList<String>();
  final IMessageHandler handler=new MyIMessageHandler(errors,warnings);
  final ILoggingHandler loggingHandler=new MyILoggingHandler(errors,warnings);
  try {
    Logger.addLoggingHandler(loggingHandler);
    final DiffGenerationHandler generationHandler=new DiffGenerationHandler(true);
    ModelAccess.instance().runWriteAction(new Runnable(){
      public void run(){
        List<BaseTestConfiguration> configurations=new ArrayList<BaseTestConfiguration>(((StandaloneMPSProject)myProject).getProjectDescriptor().getTestConfigurations());
        if (configurations.isEmpty()) {
          throw new RuntimeException("tested project has no test configurations");
        }
        for (        BaseTestConfiguration t : configurations) {
          System.out.println("completed : " + configurations.indexOf(t) + " / "+ configurations.size());
          if (configurationsGiven.length > 0) {
            boolean exists=false;
            for (            String confName : configurationsGiven) {
              if (confName.equals(t.getName())) {
                exists=true;
                break;
              }
            }
            if (!exists) {
              continue;
            }
          }
          GenParameters parms;
          try {
            parms=t.getGenParams(myProject,true);
          }
 catch (          IllegalGeneratorConfigurationException e) {
            errors.add("Can't create a generator configuration : " + e.getMessage());
            return;
          }
          int numErrorsBeforeGeneration=errors.size();
          GenerationFacade.generateModels(myProject.getComponent(MPSProject.class),parms.getModelDescriptors(),new ModuleContext(parms.getModule(),myProject),generationHandler,new EmptyProgressMonitor(),handler,GenerationOptions.getDefaults().create(),myProject.getComponent(TransientModelsComponent.class));
          if (myIsRunnable) {
            diffReports.addAll(generationHandler.createDiffReports(null));
          }
          List<SModel> outputModels=new ArrayList<SModel>();
          outputModels.addAll(generationHandler.getOutputModels());
          if (errors.size() > numErrorsBeforeGeneration) {
            System.out.println("There were generation errors, cancelling compilation");
          }
 else {
            long start=System.currentTimeMillis();
            final List<CompilationResult> compilationResultList=new ArrayList<CompilationResult>();
            CompilationResultAdapter listener=new CompilationResultAdapter(){
              public void onCompilationResult(              CompilationResult r){
                compilationResultList.add(r);
              }
            }
;
            generationHandler.compile(new EmptyProgressMonitor(),listener);
            System.out.println("Compiled " + compilationResultList.size() + " compilation units in "+ (System.currentTimeMillis() - start));
            compilationResults.addAll(createCompilationProblemsList(compilationResultList));
            if (compilationResults.isEmpty()) {
              System.out.println("Compilation ok");
            }
            failedTests.addAll(createTestFailures(generationHandler,outputModels));
          }
          System.out.println("");
          System.out.println("");
          System.out.println("");
        }
      }
    }
);
  }
  finally {
    Logger.removeLoggingHandler(loggingHandler);
  }
  return new TestResult(errors,warnings,compilationResults,failedTests,diffReports);
}
