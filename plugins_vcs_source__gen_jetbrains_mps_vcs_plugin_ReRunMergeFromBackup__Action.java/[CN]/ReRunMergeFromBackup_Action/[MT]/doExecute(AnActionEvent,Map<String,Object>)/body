{
  try {
    for (    File backupFile : Sequence.fromIterable(ReRunMergeFromBackup_Action.this.getBackupFiles(_params))) {
      try {
        String[] modelsAsText=MergeBackupUtil.loadZippedModelsAsText(backupFile,MergeVersion.values());
        String mine=modelsAsText[MergeVersion.MINE.ordinal()];
        String base=modelsAsText[MergeVersion.BASE.ordinal()];
        String repository=modelsAsText[MergeVersion.REPOSITORY.ordinal()];
        String uid=ModelPersistence.loadDescriptor(new InputSource(new StringReader(mine))).getUID();
        if (uid == null || !(SModelReference.fromString(uid).equals(((SModelDescriptor)MapSequence.fromMap(_params).get("model")).getSModelReference()))) {
          continue;
        }
        mine=ReRunMergeFromBackup_Action.this.selectMineModel(ModelPersistence.modelToString(((SModelDescriptor)MapSequence.fromMap(_params).get("model")).getSModel()),mine,_params);
        if (mine == null) {
          return;
        }
        MergeRequest mergeRequest=DiffRequestFactory.getInstance().createMergeRequest(mine,repository,base,VirtualFileUtils.getVirtualFile(ReRunMergeFromBackup_Action.this.getModelFile(_params)),((Project)MapSequence.fromMap(_params).get("project")),null,null);
        mergeRequest.setVersionTitles(new String[]{"Mine","Base version","Repository"});
        DiffManager.getInstance().getDiffTool().show(mergeRequest);
        return;
      }
 catch (      IOException e) {
        if (log.isWarnEnabled()) {
          log.warn("",e);
        }
        continue;
      }
    }
    Messages.showInfoMessage("No suitable backup files for " + ((SModelDescriptor)MapSequence.fromMap(_params).get("model")).getSModelReference().getSModelFqName() + "was not found.","No Backup Files Found");
  }
 catch (  Throwable t) {
    if (log.isErrorEnabled()) {
      log.error("User's action execute method failed. Action:" + "ReRunMergeFromBackup",t);
    }
  }
}
