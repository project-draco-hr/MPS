{
  SNode trg=FunctionTypeUtil.getAdaptableTarget(_context,_context.getNode(),((TemplateQueryContext)_context).getGenerator());
  SNode ntype=FunctionType_Behavior.call_getDeclarationRuntimeType_1230319610063(SNodeOperations.as(TypeChecker.getInstance().getTypeOf(_context.getNode()),"jetbrains.mps.baseLanguage.closures.structure.FunctionType"));
  ntype=(ntype == null ? TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(_context.getNode()),HUtil.createMatchingPatternByConceptFQName("jetbrains.mps.baseLanguage.structure.ClassifierType"),true) : ntype);
  final Map<SNode,SNode> theMap=FunctionTypeUtil.mapAdaptableTargetTVDs(SLinkOperations.getTarget(SNodeOperations.cast(ntype,"jetbrains.mps.baseLanguage.structure.ClassifierType"),"classifier",false),trg);
  final List<SNode> params=SLinkOperations.getTargets(SNodeOperations.cast(ntype,"jetbrains.mps.baseLanguage.structure.ClassifierType"),"parameter",true);
  return ListSequence.fromList(SLinkOperations.getTargets(trg,"typeVariableDeclaration",true)).<SNode>select(new ISelector<SNode,SNode>(){
    public SNode select(    final SNode tvd){
      return ListSequence.fromList(params).getElement(SNodeOperations.getIndexInParent(MapSequence.fromMap(theMap).findFirst(new IWhereFilter<IMapping<SNode,SNode>>(){
        public boolean accept(        IMapping<SNode,SNode> m){
          return m.value() == tvd;
        }
      }
).key()));
    }
  }
);
}
