{
  SNode trg=FunctionTypeUtil.getAdaptableTarget(_context,_context.getNode(),((TemplateQueryContext)_context).getGenerator());
  SNode ntype=(SNodeOperations.isInstanceOf(TypeChecker.getInstance().getTypeOf(_context.getNode()),"jetbrains.mps.baseLanguage.closures.structure.FunctionType") ? ClassifierTypeUtil.getDeclarationClassifierType(TypeChecker.getInstance().getTypeOf(_context.getNode())) : null);
  ntype=(ntype == null ? TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(_context.getNode()),HUtil.createMatchingPatternByConceptFQName("jetbrains.mps.baseLanguage.structure.ClassifierType"),true) : ntype);
  final Map<SNode,SNode> theMap=FunctionTypeUtil.mapAdaptableTargetTVDs(SLinkOperations.getTarget(SNodeOperations.cast(ntype,"jetbrains.mps.baseLanguage.structure.ClassifierType"),"classifier",false),trg);
  final List<SNode> params=SLinkOperations.getTargets(SNodeOperations.cast(ntype,"jetbrains.mps.baseLanguage.structure.ClassifierType"),"parameter",true);
  return ListSequence.fromList(SLinkOperations.getTargets(trg,"typeVariableDeclaration",true)).select(new ISelector<SNode,SNode>(){
    public SNode select(    final SNode tvr){
      return ListSequence.fromList(params).getElement(SNodeOperations.getIndexInParent(MapSequence.fromMap(theMap).findFirst(new IWhereFilter<IMapping<SNode,SNode>>(){
        public boolean accept(        IMapping<SNode,SNode> m){
          return m.value() == tvr;
        }
      }
).key()));
    }
  }
);
}
