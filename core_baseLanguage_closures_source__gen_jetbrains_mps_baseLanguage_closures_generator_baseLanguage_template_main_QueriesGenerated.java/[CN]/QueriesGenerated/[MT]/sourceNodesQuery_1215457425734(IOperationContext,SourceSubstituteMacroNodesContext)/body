{
  List<SNode> paramDecls=SLinkOperations.getTargets(_context.getNode(),"parameter",true);
  SNode literal=_context.getNode();
  SNode ct=(SNode)Values.LITERAL_TARGET.get(_context,literal);
  if (ct != null) {
    List<SNode> imds=SLinkOperations.getTargets(SLinkOperations.getTarget(ct,"classifier",false),"method",true);
    if (ListSequence.<SNode>fromList(imds).count() > 0) {
      SNode imd=ListSequence.<SNode>fromList(imds).getElement(0);
      List<SNode> res=ListSequence.<SNode>fromList(new ArrayList<SNode>());
      int idx=0;
      for (      SNode pd : SLinkOperations.getTargets(imd,"parameter",true)) {
        if (idx >= ListSequence.<SNode>fromList(paramDecls).count()) {
          _context.showErrorMessage(_context.getNode(),"Method parameters count doesn't match closure parameters count: " + SPropertyOperations.getString(imd,"shortDescription"));
          break;
        }
        SNode newpd=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ParameterDeclaration",null);
        SLinkOperations.setTarget(newpd,"type",FunctionTypeUtil.unbound(ClassifierTypeUtil.resolveType(SLinkOperations.getTarget(pd,"type",true),ct)),true);
        SPropertyOperations.set(newpd,"name",SPropertyOperations.getString(ListSequence.<SNode>fromList(paramDecls).getElement(idx),"name"));
        SPropertyOperations.set(newpd,"isFinal","" + (SPropertyOperations.getBoolean(ListSequence.<SNode>fromList(paramDecls).getElement(idx),"isFinal")));
        idx++;
        ListSequence.<SNode>fromList(res).addElement(newpd);
      }
      return res;
    }
  }
  return ListSequence.<SNode>fromList(new ArrayList<SNode>());
}
