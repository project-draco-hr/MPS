{
  List<SearchResult<ModelCheckerIssue>> results=ListSequence.fromList(new ArrayList<SearchResult<ModelCheckerIssue>>());
  if (model == null || model.getModelDescriptor() == null || model.getModelDescriptor().getModule() == null) {
    return results;
  }
  final IScope scope=model.getModelDescriptor().getModule().getScope();
  String title="Checking " + SModelOperations.getModelName(model) + " for unresolved references to method declaration...";
  monitor.start(title,1);
  for (  final SNode node : ListSequence.fromList(SModelOperations.getNodes(model,"jetbrains.mps.baseLanguage.structure.IMethodCall"))) {
    if (monitor.isCanceled()) {
      break;
    }
    for (    SReference ref : Sequence.fromIterable(SNodeOperations.getReferences(node))) {
      if ((AttributeOperations.getAttribute(node,new IAttributeDescriptor.LinkAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.generator.structure.ReferenceMacro"),SLinkOperations.getRole(ref))) != null)) {
        continue;
      }
      if (!("baseMethodDeclaration".equals(SLinkOperations.getRole(ref)))) {
        continue;
      }
      if (ref.getTargetNodeSilently() == null) {
        addIssue(results,node,"Unresolved reference to method declaration: " + SLinkOperations.getResolveInfo(ref),ModelChecker.SEVERITY_ERROR,"unresolved reference to method declaration",new IModelCheckerFix(){
          public boolean doFix(){
            MethodDeclarationsFixer fixer=new MethodDeclarationsFixer();
            final Map<SNode,SNode> reResolvedTargets=new HashMap<SNode,SNode>();
            fixer.testAndFixMethodCall(SNodeOperations.cast(node,"jetbrains.mps.baseLanguage.structure.IMethodCall"),reResolvedTargets);
            for (            SNode methodCall : reResolvedTargets.keySet()) {
              SNode referent=reResolvedTargets.get(methodCall);
              if (referent != null && !(referent.shouldHaveBeenDisposed())) {
                SLinkOperations.setTarget(methodCall,"baseMethodDeclaration",referent,false);
              }
            }
            fixer.clearCaches();
            return true;
          }
        }
);
      }
      final SModelReference uid=ref.getTargetSModelReference();
      if (uid == null) {
        continue;
      }
      SModelDescriptor descriptor=GlobalScope.getInstance().getModelDescriptor(uid);
      if (scope.getModelDescriptor(uid) == null && descriptor != null) {
        addIssue(results,node,"Target module " + descriptor.getModule() + " should be imported",ModelChecker.SEVERITY_ERROR,"target module not imported",new IModelCheckerFix(){
          public boolean doFix(){
            if (scope.getModelDescriptor(uid) == null && GlobalScope.getInstance().getModelDescriptor(uid) != null) {
              SModelDescriptor sm=GlobalScope.getInstance().getModelDescriptor(uid);
              check_lz161n_a1a0a5a0a7a1a6a0(check_lz161n_a0b0a0f0a0h0b0g0a(model.getModelDescriptor()),sm);
              return true;
            }
            return false;
          }
        }
);
      }
    }
  }
  monitor.done();
  return results;
}
