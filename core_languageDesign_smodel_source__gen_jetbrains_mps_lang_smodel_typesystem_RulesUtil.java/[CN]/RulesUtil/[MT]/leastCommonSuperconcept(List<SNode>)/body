{
  Map<SNode,Set<SNode>> subTypesToSuperTypes=MapSequence.<SNode,Set<SNode>>fromMap(new HashMap<SNode,Set<SNode>>());
  Set<SNode> keyset=SetSequence.<SNode>fromSet(new HashSet<SNode>());
  Set<SNode> allTypes=SetSequence.<SNode>fromSet(new HashSet<SNode>());
  Set<SNode> frontier=SetSequence.<SNode>fromSetWithValues(new HashSet<SNode>(),concepts);
  Set<SNode> newFrontier=SetSequence.<SNode>fromSet(new HashSet<SNode>());
  while (!(SetSequence.<SNode>fromSet(frontier).isEmpty())) {
    for (    SNode concept : frontier) {
      if (SetSequence.<SNode>fromSet(keyset).contains(concept)) {
        continue;
      }
      List<SNode> supertypes=AbstractConceptDeclaration_Behavior.call_getImmediateSuperconcepts_1222430305282(concept);
      Set<SNode> set=MapSequence.<SNode,Set<SNode>>fromMap(subTypesToSuperTypes).get(concept);
      if (set == null) {
        set=SetSequence.<SNode>fromSet(new HashSet<SNode>());
        MapSequence.<SNode,Set<SNode>>fromMap(subTypesToSuperTypes).put(concept,set);
      }
      SetSequence.fromSet(set).addSequence(ListSequence.<SNode>fromList(supertypes));
      SetSequence.fromSet(keyset).addElement(concept);
      SetSequence.fromSet(newFrontier).addSequence(ListSequence.<SNode>fromList(supertypes));
      SetSequence.fromSet(allTypes).addSequence(ListSequence.<SNode>fromList(supertypes));
      ListSequence.<SNode>fromList(supertypes).addElement(concept);
    }
    frontier=newFrontier;
    newFrontier=SetSequence.<SNode>fromSet(new HashSet<SNode>());
  }
  for (  SNode node2 : allTypes) {
    for (    SNode node1 : allTypes) {
      for (      SNode node3 : allTypes) {
        Set<SNode> supertypes1=MapSequence.<SNode,Set<SNode>>fromMap(subTypesToSuperTypes).get(node1);
        if (supertypes1 == null) {
          continue;
        }
        Set<SNode> supertypes2=MapSequence.<SNode,Set<SNode>>fromMap(subTypesToSuperTypes).get(node2);
        if (supertypes2 == null) {
          continue;
        }
        if (SetSequence.<SNode>fromSet(supertypes1).contains(node2) && SetSequence.<SNode>fromSet(supertypes2).contains(node3)) {
          SetSequence.fromSet(supertypes1).addElement(node3);
        }
      }
    }
  }
  Set<SNode> result=SetSequence.<SNode>fromSetWithValues(new HashSet<SNode>(),concepts);
  while (SetSequence.<SNode>fromSet(result).count() >= 2) {
    Iterator<SNode> iterator=SetSequence.<SNode>fromSet(result).iterator();
    SNode a=iterator.next();
    SNode b=iterator.next();
    SetSequence.fromSet(result).removeElement(a);
    SetSequence.fromSet(result).removeElement(b);
    SetSequence.fromSet(result).addElement(leastCommonSuperconcept(a,b,subTypesToSuperTypes));
  }
  if (SetSequence.<SNode>fromSet(result).isEmpty()) {
    return SConceptOperations.findConceptDeclaration("jetbrains.mps.lang.core.structure.BaseConcept");
  }
  return SetSequence.<SNode>fromSet(result).first();
}
