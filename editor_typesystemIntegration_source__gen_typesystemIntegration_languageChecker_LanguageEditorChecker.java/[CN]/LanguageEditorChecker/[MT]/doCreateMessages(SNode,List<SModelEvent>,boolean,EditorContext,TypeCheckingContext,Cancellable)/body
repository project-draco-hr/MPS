{
  EditorComponent editorComponent=(EditorComponent)editorContext.getEditorComponent();
  SModel model=editorContext.getModel();
  boolean inspector=editorComponent instanceof InspectorEditorComponent;
  myScopeChecker.setEditorComponent(editorComponent);
  myMessagesChanged=false;
  Set<EditorMessage> result=SetSequence.fromSet(new HashSet<EditorMessage>());
  SNode editedNode=editorComponent.getEditedNode();
  if (editedNode == null) {
    if (LOG.isEnabledFor(Level.ERROR)) {
      LOG.error("edited node is null");
    }
    return result;
  }
  if (node.getModel() == null || SNodeOperations.getModel(editedNode) == null) {
    return result;
  }
  LanguageErrorsComponent errorsComponent=getErrorsComponent(editorComponent);
  if (errorsComponent == null) {
    return result;
  }
  if (!(wasCheckedOnce)) {
    errorsComponent.clear();
  }
  if (inspector) {
    myMessagesChanged=errorsComponent.checkInspector();
  }
 else {
    boolean changed=false;
    try {
      if (typeCheckingContext != null) {
        typeCheckingContext.setIsNonTypesystemComputation();
      }
      changed=errorsComponent.check(SNodeOperations.getContainingRoot(((SNode)node)),myRules,editorContext.getRepository(),cancellable);
    }
  finally {
      if (typeCheckingContext != null) {
        typeCheckingContext.resetIsNonTypesystemComputation();
      }
    }
    myMessagesChanged=changed;
  }
  if (!(myMessagesChanged)) {
    return result;
  }
  boolean runQuickFixes=shouldRunQuickFixs(model,inspector);
  final List<Tuples._2<QuickFix_Runtime,SNode>> quickFixesToExecute=ListSequence.fromList(new ArrayList<Tuples._2<QuickFix_Runtime,SNode>>());
  for (  IErrorReporter errorReporter : errorsComponent.getErrors()) {
    if (!(ErrorReportUtil.shouldReportError(errorReporter.getSNode()))) {
      continue;
    }
    SNode nodeWithError=errorReporter.getSNode();
    if (!(ListSequence.fromList(SNodeOperations.getNodeAncestors(nodeWithError,null,true)).contains(editedNode))) {
      continue;
    }
    MessageStatus status=errorReporter.getMessageStatus();
    String errorString=errorReporter.reportError();
    HighlighterMessage message=HighlightUtil.createHighlighterMessage(nodeWithError,NameUtil.capitalize(status.getPresentation()) + ": " + errorString,errorReporter,LanguageEditorChecker.this);
    List<QuickFixProvider> intentionProviders=message.getIntentionProviders();
    if (runQuickFixes && intentionProviders.size() == 1 && intentionProviders.get(0).isExecutedImmediately()) {
      QuickFix_Runtime quickFix=intentionProviders.get(0).getQuickFix();
      if (quickFix != null) {
        ListSequence.fromList(quickFixesToExecute).addElement(MultiTuple.<QuickFix_Runtime,SNode>from(quickFix,nodeWithError));
      }
    }
    SetSequence.fromSet(result).addElement(message);
  }
  if (inspector) {
    return result;
  }
  final boolean wasForceRunQuickFixes=myForceRunQuickFixes;
  myForceRunQuickFixes=false;
  if (ListSequence.fromList(quickFixesToExecute).isNotEmpty()) {
    ApplicationManager.getApplication().invokeLater(new Runnable(){
      public void run(){
        ModelAccess.instance().runUndoTransparentCommand(new Runnable(){
          public void run(){
            for (            Tuples._2<QuickFix_Runtime,SNode> fix : quickFixesToExecute) {
              if (SNodeOperations.getModel(fix._1()) != null) {
                fix._0().execute(fix._1());
                if (wasForceRunQuickFixes) {
                  myForceRunQuickFixes=true;
                }
              }
            }
          }
        }
);
      }
    }
);
  }
  return result;
}
