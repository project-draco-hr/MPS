{
  this.fqName=fqName;
  final List<String> directProperties=new ArrayList<String>();
  final List<String> directReferences=new ArrayList<String>();
  NodeReadAccessCasterInEditor.runReadTransparentAction(new Runnable(){
    @Override public void run(){
      SNode declaration=SModelUtil.findConceptDeclaration(fqName,GlobalScope.getInstance());
      if (declaration == null || !SNodeUtil.isInstanceOfAbstractConceptDeclaration(declaration)) {
        isLegal=false;
        return;
      }
 else {
        isLegal=true;
      }
      isInterface=SNodeUtil.isInstanceOfInterfaceConceptDeclaration(declaration);
      isFinal=SPropertyOperations.getBoolean(declaration,"isFinal");
      isAbstract=SPropertyOperations.getBoolean(declaration,"isAbstract");
      helpURL=SPropertyOperations.getString(declaration,"helpUrl");
      conceptAlias=SNodeUtil.getConceptAlias(declaration);
      shortDescription=SNodeUtil.getConceptShortDescription(declaration);
      String scopeVal=SPropertyOperations.getString(declaration,"staticScope");
      staticScope="none".equals(scopeVal) ? StaticScope.NONE : ("root".equals(scopeVal) ? StaticScope.ROOT : StaticScope.GLOBAL);
      if (SNodeUtil.isInstanceOfConceptDeclaration(declaration)) {
        SNode superConceptNode=SNodeUtil.getConceptDeclaration_Extends(declaration);
        if (superConceptNode == null && !SNodeUtil.concept_BaseConcept.equals(fqName)) {
          superConcept=SNodeUtil.concept_BaseConcept;
        }
 else {
          superConcept=NameUtil.nodeFQName(superConceptNode);
        }
      }
      Set<String> parentsSet=new LinkedHashSet<String>();
      if (SNodeUtil.isInstanceOfConceptDeclaration(declaration)) {
        parentsSet.add(superConcept);
        for (        SNode interfaceConcept : SNodeUtil.getConceptDeclaration_Implements(declaration)) {
          parentsSet.add(NameUtil.nodeFQName(interfaceConcept));
        }
      }
 else       if (SNodeUtil.isInstanceOfInterfaceConceptDeclaration(declaration)) {
        for (        SNode interfaceConcept : SNodeUtil.getInterfaceConceptDeclaration_Extends(declaration)) {
          parentsSet.add(NameUtil.nodeFQName(interfaceConcept));
        }
      }
      parentsSet.remove(null);
      if (superConcept == null && !SNodeUtil.concept_BaseConcept.equals(fqName) && !isInterface) {
        parentsSet.add(SNodeUtil.concept_BaseConcept);
      }
      parents=new ArrayList<String>(parentsSet);
      for (      SNode property : SNodeUtil.getConcept_PropertyDeclarations(declaration)) {
        String name=property.getName();
        if (name != null) {
          directProperties.add(name);
        }
      }
      unorderedChildren=new HashSet<String>();
      for (      SNode link : SNodeUtil.getConcept_LinkDeclarations(declaration)) {
        String role=SModelUtil.getLinkDeclarationRole(link);
        if (role != null) {
          if (SPropertyOperations.getBoolean(link,"unordered")) {
            unorderedChildren.add(role);
          }
          if (SNodeUtil.getLinkDeclaration_IsReference(link)) {
            directReferences.add(role);
          }
 else {
            childrenMap.put(role,!SNodeUtil.getLinkDeclaration_IsSingular(link));
          }
        }
      }
    }
  }
);
  if (isLegal) {
    List<ConceptDescriptor> parentDescriptors=new ArrayList<ConceptDescriptor>(parents.size());
    for (    String parent : parents) {
      ConceptDescriptor descriptor=getDescriptor(parent);
      if (descriptor != null) {
        parentDescriptors.add(descriptor);
      }
    }
    ancestors=new HashSet<String>(parents);
    ancestors.add(fqName);
    for (    ConceptDescriptor parentDescriptor : parentDescriptors) {
      ancestors.addAll(parentDescriptor.getAncestorsNames());
    }
    LinkedHashSet<String> properties=new LinkedHashSet<String>();
    properties.addAll(directProperties);
    for (    ConceptDescriptor parentDescriptor : parentDescriptors) {
      properties.addAll(parentDescriptor.getPropertyNames());
    }
    propertyNames=Collections.unmodifiableSet(properties);
    LinkedHashSet<String> references=new LinkedHashSet<String>();
    references.addAll(directReferences);
    for (    ConceptDescriptor parentDescriptor : parentDescriptors) {
      references.addAll(parentDescriptor.getReferenceNames());
    }
    referenceNames=Collections.unmodifiableSet(references);
    for (    ConceptDescriptor parentDescriptor : parentDescriptors) {
      for (      String child : parentDescriptor.getChildrenNames()) {
        childrenMap.put(child,parentDescriptor.isMultipleChild(child));
      }
      unorderedChildren.addAll(parentDescriptor.getUnorderedChildrenNames());
    }
    unorderedChildren=Collections.unmodifiableSet(unorderedChildren);
    childrenNames=Collections.unmodifiableSet(childrenMap.keySet());
  }
}
