{
  this.fqName=fqName;
  final List<String> directProperties=new ArrayList<String>();
  final List<String> directReferences=new ArrayList<String>();
  final List<String> directChildren=new ArrayList<String>();
  NodeReadAccessCasterInEditor.runReadTransparentAction(new Runnable(){
    @Override public void run(){
      SNode declaration=SModelUtil.findConceptDeclaration(fqName,GlobalScope.getInstance());
      if (declaration == null || !SNodeUtil.isInstanceOfAbstractConceptDeclaration(declaration)) {
        isLegal=false;
        return;
      }
 else {
        isLegal=true;
      }
      isInterface=SNodeUtil.isInstanceOfInterfaceConceptDeclaration(declaration);
      if (SNodeUtil.isInstanceOfConceptDeclaration(declaration)) {
        SNode superConceptNode=SNodeUtil.getConceptDeclaration_Extends(declaration);
        if (superConceptNode == null && !SNodeUtil.concept_BaseConcept.equals(fqName)) {
          superConcept=SNodeUtil.concept_BaseConcept;
        }
 else {
          superConcept=NameUtil.nodeFQName(superConceptNode);
        }
      }
      Set<String> parentsSet=new LinkedHashSet<String>();
      if (SNodeUtil.isInstanceOfConceptDeclaration(declaration)) {
        parentsSet.add(superConcept);
        for (        SNode interfaceConcept : SNodeUtil.getConceptDeclaration_Implements(declaration)) {
          parentsSet.add(NameUtil.nodeFQName(interfaceConcept));
        }
      }
 else       if (SNodeUtil.isInstanceOfInterfaceConceptDeclaration(declaration)) {
        for (        SNode interfaceConcept : SNodeUtil.getInterfaceConceptDeclaration_Extends(declaration)) {
          parentsSet.add(NameUtil.nodeFQName(interfaceConcept));
        }
      }
      parentsSet.remove(null);
      if (superConcept == null && !SNodeUtil.concept_BaseConcept.equals(fqName) && !isInterface) {
        parentsSet.add(SNodeUtil.concept_BaseConcept);
      }
      parents=new ArrayList<String>(parentsSet);
      for (      SNode property : SNodeUtil.getConcept_PropertyDeclarations(declaration)) {
        String name=property.getName();
        if (name != null) {
          directProperties.add(name);
        }
      }
      for (      SNode link : SNodeUtil.getConcept_LinkDeclarations(declaration)) {
        String role=SModelUtil.getLinkDeclarationRole(link);
        if (role != null) {
          if (SNodeUtil.getLinkDeclaration_IsReference(link)) {
            directReferences.add(role);
          }
 else {
            directChildren.add(role);
          }
        }
      }
    }
  }
);
  if (isLegal) {
    List<ConceptDescriptor> parentDescriptors=new ArrayList<ConceptDescriptor>(parents.size());
    for (    String parent : parents) {
      ConceptDescriptor descriptor=getDescriptor(parent);
      if (descriptor != null) {
        parentDescriptors.add(descriptor);
      }
    }
    ancestors=new HashSet<String>(parents);
    ancestors.add(fqName);
    for (    ConceptDescriptor parentDescriptor : parentDescriptors) {
      ancestors.addAll(parentDescriptor.getAncestorsNames());
    }
    LinkedHashSet<String> properties=new LinkedHashSet<String>();
    properties.addAll(directProperties);
    for (    ConceptDescriptor parentDescriptor : parentDescriptors) {
      properties.addAll(parentDescriptor.getPropertyNames());
    }
    propertyNames=new ArrayList<String>(properties);
    LinkedHashSet<String> references=new LinkedHashSet<String>();
    references.addAll(directReferences);
    for (    ConceptDescriptor parentDescriptor : parentDescriptors) {
      references.addAll(parentDescriptor.getReferenceNames());
    }
    referenceNames=new ArrayList<String>(references);
    LinkedHashSet<String> children=new LinkedHashSet<String>();
    children.addAll(directChildren);
    for (    ConceptDescriptor parentDescriptor : parentDescriptors) {
      children.addAll(parentDescriptor.getChildrenNames());
    }
    childrenNames=new ArrayList<String>(children);
  }
}
