{
  super("Replace dynamic references with static references");
  this.addRefactoring(new AbstractMigrationRefactoring(){
    @Override public String getName(){
      return "dynamic refs";
    }
    @Override public String getAdditionalInfo(){
      return "dynamic refs";
    }
    @Override public SAbstractConcept getApplicableConcept(){
      return MetaAdapterFactory.getConcept(0xceab519525ea4f22L,0x9b92103b95ca8c0cL,0x10802efe25aL,"jetbrains.mps.lang.core.structure.BaseConcept");
    }
    @Override public boolean isApplicableInstanceNode(    SNode node){
      return Sequence.fromIterable(((Iterable<SReference>)node.getReferences())).any(new IWhereFilter<SReference>(){
        public boolean accept(        SReference it){
          return it instanceof DynamicReference;
        }
      }
);
    }
    @Override public void doUpdateInstanceNode(    SNode node){
      Map<String,SNode> roleToTarget=MapSequence.fromMap(new HashMap<String,SNode>());
      for (      SReference ref : Sequence.fromIterable(node.getReferences())) {
        if (!(ref instanceof DynamicReference)) {
          continue;
        }
        MapSequence.fromMap(roleToTarget).put(ref.getRole(),ref.getTargetNode());
      }
      for (      Map.Entry<String,SNode> m : SetSequence.fromSet(roleToTarget.entrySet())) {
        node.setReferenceTarget(m.getKey(),m.getValue());
      }
    }
    @Override public boolean isShowAsIntention(){
      return false;
    }
  }
);
}
