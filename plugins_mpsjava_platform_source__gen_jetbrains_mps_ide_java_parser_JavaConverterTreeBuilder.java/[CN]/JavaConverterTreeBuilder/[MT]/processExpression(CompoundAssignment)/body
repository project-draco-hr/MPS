{
  SNode op;
switch (x.operator) {
case OperatorIds.PLUS:
    op=SModelOperations.createNewNode(myCurrentModel,null,"jetbrains.mps.baseLanguage.structure.PlusAssignmentExpression");
  break;
case OperatorIds.MINUS:
op=SModelOperations.createNewNode(myCurrentModel,null,"jetbrains.mps.baseLanguage.structure.MinusAssignmentExpression");
break;
case OperatorIds.MULTIPLY:
op=SModelOperations.createNewNode(myCurrentModel,null,"jetbrains.mps.baseLanguage.structure.MulAssignmentExpression");
break;
case OperatorIds.DIVIDE:
op=SModelOperations.createNewNode(myCurrentModel,null,"jetbrains.mps.baseLanguage.structure.DivAssignmentExpression");
break;
case OperatorIds.AND:
op=SModelOperations.createNewNode(myCurrentModel,null,"jetbrains.mps.baseLanguage.structure.AndAssignmentExpression");
break;
case OperatorIds.OR:
op=SModelOperations.createNewNode(myCurrentModel,null,"jetbrains.mps.baseLanguage.structure.OrAssignmentExpression");
break;
case OperatorIds.XOR:
op=SModelOperations.createNewNode(myCurrentModel,null,"jetbrains.mps.baseLanguage.structure.XorAssignmentExpression");
break;
case OperatorIds.REMAINDER:
op=SModelOperations.createNewNode(myCurrentModel,null,"jetbrains.mps.baseLanguage.structure.RemAssignmentExpression");
break;
case OperatorIds.LEFT_SHIFT:
op=SModelOperations.createNewNode(myCurrentModel,null,"jetbrains.mps.baseLanguage.structure.LeftShiftAssignmentExpression");
break;
case OperatorIds.RIGHT_SHIFT:
op=SModelOperations.createNewNode(myCurrentModel,null,"jetbrains.mps.baseLanguage.structure.RightShiftAssignmentExpression");
break;
case OperatorIds.UNSIGNED_RIGHT_SHIFT:
op=SModelOperations.createNewNode(myCurrentModel,null,"jetbrains.mps.baseLanguage.structure.UnsignedRightShiftAssignmentExpression");
break;
default :
throw new JavaConverterException("Unsupported operator for CompoundAssignment");
}
SLinkOperations.setTarget(op,"lValue",processExpressionRefl(x.lhs),true);
SLinkOperations.setTarget(op,"rValue",processExpressionRefl(x.expression),true);
return op;
}
