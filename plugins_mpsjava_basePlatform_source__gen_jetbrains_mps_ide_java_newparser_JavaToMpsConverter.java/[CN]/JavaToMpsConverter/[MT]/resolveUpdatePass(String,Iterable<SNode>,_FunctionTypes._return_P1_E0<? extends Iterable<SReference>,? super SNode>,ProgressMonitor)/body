{
  final Map<SNodeReference,List<SReference>> resolveMap=MapSequence.fromMap(new HashMap<SNodeReference,List<SReference>>());
  progress.start(name,Sequence.fromIterable(nodes).count() + 1);
  myModelAccess.runReadAction(new Runnable(){
    public void run(){
      for (      SNode node : Sequence.fromIterable(nodes)) {
        if (SNodeOperations.isInstanceOf(node,MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L,0x9b92103b95ca8c0cL,0x110396eaaa4L,"jetbrains.mps.lang.core.structure.INamedConcept"))) {
          progress.step("class: " + SPropertyOperations.getString(SNodeOperations.cast(node,MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L,0x9b92103b95ca8c0cL,0x110396eaaa4L,"jetbrains.mps.lang.core.structure.INamedConcept")),MetaAdapterFactory.getProperty(0xceab519525ea4f22L,0x9b92103b95ca8c0cL,0x110396eaaa4L,0x110396ec041L,"name")));
        }
        Iterable<SReference> refs=extractor.invoke(node);
        resolveRefs(refs,resolveMap);
        SetSequence.fromSet(myVisitedRefs).addSequence(Sequence.fromIterable(refs));
        progress.advance(1);
      }
    }
  }
);
  progress.step("updating references...");
  runCommand(name,new Runnable(){
    public void run(){
      updateReference(resolveMap);
    }
  }
);
  progress.advance(1);
  progress.done();
}
