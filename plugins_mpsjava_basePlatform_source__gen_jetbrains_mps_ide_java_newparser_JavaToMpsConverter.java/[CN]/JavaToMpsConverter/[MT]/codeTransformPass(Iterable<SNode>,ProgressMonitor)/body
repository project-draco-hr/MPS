{
  progress.start("Code transforms",Sequence.fromIterable(nodes).count() * 5 + 1);
  final TypeChecker typeChecker=TypeChecker.getInstance();
  final List<SNode> toReplaceWithArrayLength=ListSequence.fromList(new ArrayList<SNode>());
  final List<SNode> toReplaceWithArrayClone=ListSequence.fromList(new ArrayList<SNode>());
  final Map<SNode,SNode> enumConstRefs=MapSequence.fromMap(new HashMap<SNode,SNode>());
  final Map<SNode,SNode> staticMethodQualifiers=MapSequence.fromMap(new HashMap<SNode,SNode>());
  final Map<SNode,SNode> staticFieldQualifiers=MapSequence.fromMap(new HashMap<SNode,SNode>());
  myModelAccess.runReadAction(new Runnable(){
    public void run(){
      for (      SNode node : Sequence.fromIterable(nodes)) {
        for (        SNode fieldRefOp : ListSequence.fromList(SNodeOperations.getDescendants(node,"jetbrains.mps.baseLanguage.structure.FieldReferenceOperation",false,new String[]{}))) {
          SReference fieldRef=SNodeOperations.getReference(fieldRefOp,SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.FieldReferenceOperation","fieldDeclaration"));
          if (!(fieldRef instanceof DynamicReference && "length".equals((((DynamicReference)fieldRef).getResolveInfo())))) {
            continue;
          }
          SNode operand=SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(fieldRefOp),"jetbrains.mps.baseLanguage.structure.DotExpression"),"operand",true);
          Iterable<SReference> operandRefs=SNodeOperations.getReferences(operand);
          if (Sequence.fromIterable(operandRefs).any(new IWhereFilter<SReference>(){
            public boolean accept(            SReference it){
              return it instanceof DynamicReference;
            }
          }
)) {
            continue;
          }
          SNode operandType=typeChecker.getTypeOf(operand);
          if (SNodeOperations.isInstanceOf(operandType,"jetbrains.mps.baseLanguage.structure.ArrayType")) {
            ListSequence.fromList(toReplaceWithArrayLength).addElement(fieldRefOp);
          }
        }
        progress.advance(1);
        for (        SNode imco : ListSequence.fromList(SNodeOperations.getDescendants(node,"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation",false,new String[]{}))) {
          SReference fieldRef=SNodeOperations.getReference(imco,SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation","instanceMethodDeclaration"));
          if (!(fieldRef instanceof DynamicReference && "clone".equals((((DynamicReference)fieldRef).getResolveInfo())))) {
            continue;
          }
          SNode operand=SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(imco),"jetbrains.mps.baseLanguage.structure.DotExpression"),"operand",true);
          Iterable<SReference> operandRefs=SNodeOperations.getReferences(operand);
          if (Sequence.fromIterable(operandRefs).any(new IWhereFilter<SReference>(){
            public boolean accept(            SReference it){
              return it instanceof DynamicReference;
            }
          }
)) {
            continue;
          }
          SNode operandType=typeChecker.getTypeOf(operand);
          if (SNodeOperations.isInstanceOf(operandType,"jetbrains.mps.baseLanguage.structure.ArrayType")) {
            ListSequence.fromList(toReplaceWithArrayClone).addElement(imco);
          }
        }
        progress.advance(1);
        for (        SNode localCall : ListSequence.fromList(SNodeOperations.getDescendants(node,"jetbrains.mps.baseLanguage.structure.LocalMethodCall",false,new String[]{}))) {
          SNode smc=transformLocalCall(localCall);
          if ((smc == null)) {
            continue;
          }
          MapSequence.fromMap(staticMethodQualifiers).put(localCall,smc);
        }
        progress.advance(1);
        TypeChecker typeChecker=TypeChecker.getInstance();
        for (        SNode swicthCase : ListSequence.fromList(SNodeOperations.getDescendants(node,"jetbrains.mps.baseLanguage.structure.SwitchCase",false,new String[]{}))) {
          SNode subst=transformUnqualifedEnumUnderSwitch(swicthCase,typeChecker);
          if ((subst == null)) {
            continue;
          }
          MapSequence.fromMap(enumConstRefs).put(SNodeOperations.cast(SLinkOperations.getTarget(swicthCase,"expression",true),"jetbrains.mps.baseLanguage.structure.VariableReference"),subst);
        }
        progress.advance(1);
        for (        SNode varRef : ListSequence.fromList(SNodeOperations.getDescendants(node,"jetbrains.mps.baseLanguage.structure.VariableReference",false,new String[]{}))) {
          SNode exp=transformLocalNameRef(varRef);
          if ((exp != null)) {
            MapSequence.fromMap(staticFieldQualifiers).put(varRef,exp);
            continue;
          }
          SNode subst=transformUnqualifedEnum(varRef);
          if ((subst == null)) {
            continue;
          }
          MapSequence.fromMap(enumConstRefs).put(varRef,subst);
        }
        progress.advance(1);
      }
    }
  }
);
  progress.step("updating models...");
  runCommand("Code transforms",new Runnable(){
    public void run(){
      for (      SNode fieldRefOp : ListSequence.fromList(toReplaceWithArrayLength)) {
        SNodeOperations.replaceWithNewChild(fieldRefOp,"jetbrains.mps.baseLanguage.structure.ArrayLengthOperation");
      }
      for (      SNode imco : ListSequence.fromList(toReplaceWithArrayClone)) {
        SNodeOperations.replaceWithNewChild(imco,"jetbrains.mps.baseLanguage.structure.ArrayCloneOperation");
      }
      for (      IMapping<SNode,SNode> pair : MapSequence.fromMap(enumConstRefs)) {
        SNodeOperations.replaceWithAnother(pair.key(),pair.value());
      }
      for (      IMapping<SNode,SNode> pair : MapSequence.fromMap(staticMethodQualifiers)) {
        SNodeOperations.replaceWithAnother(pair.key(),pair.value());
      }
      for (      IMapping<SNode,SNode> pair : MapSequence.fromMap(staticFieldQualifiers)) {
        SNodeOperations.replaceWithAnother(pair.key(),pair.value());
      }
    }
  }
);
  progress.advance(1);
  progress.done();
}
