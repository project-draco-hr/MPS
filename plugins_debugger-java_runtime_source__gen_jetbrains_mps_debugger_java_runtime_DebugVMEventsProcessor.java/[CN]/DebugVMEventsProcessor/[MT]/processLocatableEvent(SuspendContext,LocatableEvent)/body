{
  ThreadReference thread=event.thread();
  LOG.assertLog(thread.isSuspended());
  DebugVMEventsProcessor.preprocessEvent(suspendContext,thread);
  SuspendContextCommand suspendCommand=new SuspendContextCommand(suspendContext){
    @Override protected void action() throws Exception {
      final SuspendManager suspendManager=mySuspendManager;
      SuspendContext pausedContext=getSuspendManager().getPausedContext();
      if (pausedContext != null && pausedContext.isEvaluating()) {
        suspendManager.voteResume(suspendContext);
        return;
      }
      final LocatableEventRequestor requestor=(LocatableEventRequestor)getRequestManager().findRequestor(event.request());
      boolean resumePreferred=requestor != null && EventRequest.SUSPEND_NONE == requestor.getSuspendPolicy();
      boolean requestHit=false;
      try {
        requestHit=(requestor != null) && requestor.processLocatableEvent(this,event);
      }
 catch (      Throwable t) {
        DebugVMEventsProcessor.LOG.error(t);
      }
      if (requestHit) {
        if (requestor instanceof JavaBreakpoint && ((JavaBreakpoint)requestor).isLogMessage()) {
          myReporter.reportInformation("Breakpoint hit: " + ((JavaBreakpoint)requestor).getPresentation() + " "+ event.location().sourceName()+ ":"+ event.location().lineNumber());
        }
      }
      if (!(requestHit) || resumePreferred) {
        suspendManager.voteResume(suspendContext);
      }
 else {
        suspendManager.voteSuspend(suspendContext);
      }
    }
  }
;
  getManagerThread().schedule(suspendCommand);
}
