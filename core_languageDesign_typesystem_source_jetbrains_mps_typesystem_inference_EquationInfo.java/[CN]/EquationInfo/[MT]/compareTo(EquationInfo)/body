{
  boolean iAmBefore=false;
  boolean iAmAfter=false;
  if (myInequationIdsAfter != null && myInequationIdsAfter.contains(new Pair<String,String>(o.getRuleModel(),o.getRuleId()))) {
    iAmBefore=true;
  }
  if (o.myInequationIdsBefore != null && o.myInequationIdsBefore.contains(new Pair<String,String>(myRuleModel,myRuleId))) {
    iAmBefore=true;
  }
  if (myInequationIdsBefore != null && myInequationIdsBefore.contains(new Pair<String,String>(o.getRuleModel(),o.getRuleId()))) {
    iAmAfter=true;
  }
  if (o.myInequationIdsAfter != null && o.myInequationIdsAfter.contains(new Pair<String,String>(myRuleModel,myRuleId))) {
    iAmAfter=true;
  }
  if (iAmBefore && iAmAfter) {
    throw new RuntimeException("inequations' priorities form a contradictional cycle: " + myRuleId + " and "+ o.getRuleId());
  }
  if (iAmBefore) {
    return -1;
  }
  if (iAmAfter) {
    return 1;
  }
  return myInequationPriority - o.myInequationPriority;
}
