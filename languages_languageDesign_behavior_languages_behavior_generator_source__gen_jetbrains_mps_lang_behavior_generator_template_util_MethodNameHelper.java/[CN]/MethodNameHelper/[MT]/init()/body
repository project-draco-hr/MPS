{
  final Map<SNodeId,Integer> methodToId=new HashMap<SNodeId,Integer>();
  final Map<Integer,SNodeId> idToMethod=new HashMap<Integer,SNodeId>();
  for (  SNode behavior : ListSequence.fromList(BehaviorReflection.invokeNonVirtual((Class<List<SNode>>)((Class)Object.class),myBehavior,"jetbrains.mps.lang.behavior.structure.ConceptBehavior","call_getAllSuperBehaviors_1818770337282950280",new Object[]{}))) {
    for (    SNode method : ListSequence.fromList(SLinkOperations.getChildren(behavior,MetaAdapterFactory.getContainmentLink(0xaf65afd8f0dd4942L,0x87d963a55f2a9db1L,0x11d43447b1aL,0x11d43447b25L,"method")))) {
      int methodGeneratedId=getTrimmedId(method.getNodeId());
      while (methodToId.containsValue(methodGeneratedId)) {
        if (LOG.isEnabledFor(Level.WARN)) {
          LOG.warn("The methods " + method + " and "+ idToMethod.get(methodGeneratedId)+ " are colliding");
        }
        methodGeneratedId=(methodGeneratedId + 1) % MODULE;
      }
      methodToId.put(method.getNodeId(),methodGeneratedId);
      idToMethod.put(methodGeneratedId,method.getNodeId());
    }
  }
  return methodToId;
}
