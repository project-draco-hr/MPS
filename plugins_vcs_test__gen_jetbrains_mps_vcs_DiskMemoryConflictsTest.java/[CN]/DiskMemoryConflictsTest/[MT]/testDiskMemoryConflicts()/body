{
  final DiskMemoryConflictsTest.Action[] startedAction=new DiskMemoryConflictsTest.Action[1];
  final DiskMemoryConflictsTest.DiskModification[] startedDiskModification=new DiskMemoryConflictsTest.DiskModification[1];
  final DiskMemoryConflictsTest.VersionToChoose[] startedVersion=new DiskMemoryConflictsTest.VersionToChoose[1];
  final boolean result=TestMain.testOnProjectCopy(PROJECT_ARCHIVE,DESTINATION_PROJECT_DIR,PROJECT_FILE,new TestMain.ProjectRunnable(){
    @Override public boolean execute(    final Project project){
      final boolean[] resultArr=new boolean[1];
      try {
        myProject=project;
        myModelDescriptor=(BaseEditableSModelDescriptor)SModelRepository.getInstance().getModelDescriptor(DiskMemoryConflictsTest.MODEL_REFERENCE);
        myModule=(Solution)myModelDescriptor.getModule();
        ModelAccess.instance().runReadAction(new Runnable(){
          @Override public void run(){
            myNodeBackup=CopyUtil.copyAndPreserveId(myModelDescriptor.getRootNodes().iterator().next());
          }
        }
);
        checkInitialState();
        for (        DiskMemoryConflictsTest.Action a : DiskMemoryConflictsTest.Action.values()) {
          for (          DiskMemoryConflictsTest.DiskModification dm : DiskMemoryConflictsTest.DiskModification.values()) {
            for (            DiskMemoryConflictsTest.VersionToChoose v : DiskMemoryConflictsTest.VersionToChoose.values()) {
              startedAction[0]=a;
              startedVersion[0]=v;
              startedDiskModification[0]=dm;
              provokeAndCheckConflict(a,dm,v);
              restoreAndCheckOriginalState();
            }
          }
        }
        resultArr[0]=true;
      }
 catch (      Throwable e) {
        e.printStackTrace();
        return false;
      }
      return resultArr[0];
    }
  }
,"jetbrains.mps.vcs");
  if (!(result)) {
    Assert.fail("Last started check action=" + startedAction[0] + ", disk modification="+ startedDiskModification[0]+ ", version="+ startedVersion[0]);
  }
}
