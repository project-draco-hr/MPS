{
  init();
  while (mySet.size() > 0) {
    Node first=mySet.first();
    if (MapSequence.fromMap(myDist).get(first) == ShortestPath.INF) {
      break;
    }
    mySet.remove(first);
    for (    Edge edge : ListSequence.fromList(first.getEdges(direction)).where(new IWhereFilter<Edge>(){
      public boolean accept(      Edge it){
        return filter.invoke(it);
      }
    }
)) {
      if (MapSequence.fromMap(myWeights).get(edge) < 0) {
        throw new RuntimeException("dijkstra with negative weights");
      }
      Node opposite=edge.getOpposite(first);
      if (MapSequence.fromMap(myDist).get(opposite) > MapSequence.fromMap(myDist).get(first) + MapSequence.fromMap(myWeights).get(edge)) {
        mySet.remove(opposite);
        MapSequence.fromMap(myDist).put(opposite,MapSequence.fromMap(myDist).get(first) + MapSequence.fromMap(myWeights).get(edge));
        MapSequence.fromMap(myPrev).put(opposite,edge);
        mySet.add(opposite);
      }
    }
  }
}
