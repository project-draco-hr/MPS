{
  if (DISABLED) {
    return new HashSet<EditorMessage>();
  }
  SModel model=SNodeOperations.getModel(rootNode);
  if (!(model instanceof EditableSModel) || model.getModule() instanceof TransientModelsModule || jetbrains.mps.util.SNodeOperations.isModelDisposed(model)) {
    return new HashSet<EditorMessage>(0);
  }
  final Map<SNode,SNode> reResolvedTargets=new HashMap<SNode,SNode>();
  if (!(wasCheckedOnce) || myCachesCleared) {
    myCachesCleared=false;
    for (    SNode methodCall : SNodeOperations.getDescendants(rootNode,"jetbrains.mps.baseLanguage.structure.IMethodCall",false,new String[]{})) {
      testAndFixMethodCall(methodCall,reResolvedTargets);
    }
  }
 else {
    Set<SNodeReference> expressionsWithChangedTypes;
synchronized (myRecalculatedTypesLock) {
      expressionsWithChangedTypes=new HashSet<SNodeReference>(myCurrentExpressionsWithChangedTypes);
      myCurrentExpressionsWithChangedTypes.clear();
    }
    SModelEventVisitor visitor=new SModelEventVisitorAdapter(){
      @Override public void visitChildEvent(      SModelChildEvent event){
        SNode child=event.getChild();
        if (event.isAdded() && child.getModel() != null) {
          nodeAdded(child,reResolvedTargets);
        }
 else {
          nodeRemoved(child,event.getParent(),event.getModel(),reResolvedTargets);
        }
      }
      @Override public void visitReferenceEvent(      SModelReferenceEvent event){
        SReference reference=event.getReference();
        SNode sourceNode=reference.getSourceNode();
        if (SNodeOperations.isInstanceOf(sourceNode,"jetbrains.mps.baseLanguage.structure.IMethodCall") && "baseMethodDeclaration".equals(reference.getRole())) {
          methodCallDeclarationChanged(SNodeOperations.cast(sourceNode,"jetbrains.mps.baseLanguage.structure.IMethodCall"),reResolvedTargets);
        }
      }
      @Override public void visitPropertyEvent(      SModelPropertyEvent event){
        SNode node=event.getNode();
        SNodeOperations.isInstanceOf(node,"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration");
        if (SNodeOperations.isInstanceOf(node,"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration") && "name".equals(event.getPropertyName())) {
          methodDeclarationNameChanged(node,reResolvedTargets);
          methodDeclarationSignatureChanged(node,reResolvedTargets);
        }
      }
      @Override public void visitReplacedEvent(      SModelReplacedEvent event){
        clearCaches();
      }
    }
;
    for (    SModelEvent event : events) {
      if (event.getAffectedRoot() != rootNode) {
        continue;
      }
      event.accept(visitor);
    }
    for (    SNodeReference expressionWithChangedType : expressionsWithChangedTypes) {
      expressionTypeChanged(((SNodePointer)expressionWithChangedType).resolve(MPSModuleRepository.getInstance()),reResolvedTargets);
    }
  }
  ThreadUtils.runInUIThreadNoWait(new Runnable(){
    public void run(){
      if (reResolvedTargets.isEmpty()) {
        return;
      }
      Project p=(editorContext != null && editorContext.getOperationContext() != null ? editorContext.getOperationContext().getProject() : null);
      if (p == null) {
        return;
      }
      ModelAccess.instance().runUndoTransparentCommand(new Runnable(){
        public void run(){
          for (          SNode methodCall : reResolvedTargets.keySet()) {
            SNode referent=reResolvedTargets.get(methodCall);
            if (referent != null && !(jetbrains.mps.util.SNodeOperations.isDisposed(referent))) {
              SLinkOperations.setTarget(methodCall,"baseMethodDeclaration",referent,false);
            }
          }
        }
      }
,p);
    }
  }
);
  return new HashSet<EditorMessage>();
}
