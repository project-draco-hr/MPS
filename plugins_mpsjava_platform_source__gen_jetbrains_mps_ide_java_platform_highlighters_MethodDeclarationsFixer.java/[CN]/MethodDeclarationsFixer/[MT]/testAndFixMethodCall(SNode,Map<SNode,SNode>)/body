{
  SNode baseMethodDeclaration=SLinkOperations.getTarget(methodCallNode,"baseMethodDeclaration",false);
  String methodName;
  if (baseMethodDeclaration == null) {
    if (SLinkOperations.getTarget(SNodeOperations.as(methodCallNode,"jetbrains.mps.baseLanguage.structure.AnonymousClass"),"classifier",false) != null) {
      methodName=SPropertyOperations.getString(SLinkOperations.getTarget(SNodeOperations.as(methodCallNode,"jetbrains.mps.baseLanguage.structure.AnonymousClass"),"classifier",false),"name");
    }
 else {
      methodName=SLinkOperations.getResolveInfo(SNodeOperations.getReference(methodCallNode,SLinkOperations.findLinkDeclaration("jetbrains.mps.baseLanguage.structure.IMethodCall","baseMethodDeclaration")));
    }
  }
 else {
    methodName=SPropertyOperations.getString(baseMethodDeclaration,"name");
  }
  List<SNode> actualArgs=SLinkOperations.getTargets(methodCallNode,"actualArgument",true);
  List<SNode> candidates=getCandidates(methodCallNode,methodName);
  if (candidates == null || candidates.isEmpty()) {
    return;
  }
  SNode newTarget=null;
  boolean good;
  Map<SNode,SNode> typeByTypeVar=getTypeByTypeVar(methodCallNode);
  jetbrains.mps.util.Pair<List<SNode>,Boolean> parmCountPair=MethodResolveUtil.selectByVisibilityReportNoGoodMethodNode(candidates,methodCallNode);
  List<SNode> methodDeclarationsGoodParams=parmCountPair.o1;
  if (methodDeclarationsGoodParams.size() == 1) {
    newTarget=ListSequence.fromList(methodDeclarationsGoodParams).first();
    good=parmCountPair.o2;
  }
 else {
    parmCountPair=MethodResolveUtil.selectByParmCountReportNoGoodMethodNode(methodDeclarationsGoodParams,actualArgs);
    methodDeclarationsGoodParams=parmCountPair.o1;
    if (methodDeclarationsGoodParams.size() == 1) {
      newTarget=ListSequence.fromList(methodDeclarationsGoodParams).first();
      good=parmCountPair.o2;
    }
 else {
      jetbrains.mps.util.Pair<SNode,Boolean> parmTypesPair=MethodResolveUtil.chooseByParameterTypeReportNoGoodMethodNode(baseMethodDeclaration,methodDeclarationsGoodParams,actualArgs,typeByTypeVar);
      newTarget=parmTypesPair.o1;
      good=parmTypesPair.o2;
    }
  }
  if (newTarget != null) {
    if (baseMethodDeclaration == null || (good && newTarget != baseMethodDeclaration)) {
      reResolvedTargets.put(methodCallNode,newTarget);
    }
    SNodePointer methodCallPointer=new SNodePointer(methodCallNode);
    SNodePointer newTargetPointer=new SNodePointer(newTarget);
    myMethodCallsToSetDecls.put(methodCallPointer,newTargetPointer);
    myCheckedMethodCalls.add(methodCallPointer);
    for (    SNode actualArgument : SLinkOperations.getTargets(methodCallNode,"actualArgument",true)) {
      myParametersToCheckedMethodCalls.put(new SNodePointer(actualArgument),methodCallPointer);
    }
    Set<SNodePointer> nodeSet=myMethodDeclsToCheckedMethodCalls.get(newTargetPointer);
    if (nodeSet == null) {
      nodeSet=new HashSet<SNodePointer>();
      myMethodDeclsToCheckedMethodCalls.put(newTargetPointer,nodeSet);
    }
    nodeSet.add(methodCallPointer);
    Pair<String,String> key=new Pair<String,String>(newTarget.getConceptFqName(),methodName);
    Set<SNodePointer> nodesByNameAndConcept=myMethodConceptsAndNamesToCheckedMethodCalls.get(key);
    if (nodesByNameAndConcept == null) {
      nodesByNameAndConcept=new HashSet<SNodePointer>();
      myMethodConceptsAndNamesToCheckedMethodCalls.put(key,nodesByNameAndConcept);
    }
    nodesByNameAndConcept.add(methodCallPointer);
  }
}
