{
{
    SAbstractConcept cncpt=c;
    Integer preIndex=indices_lpa09p_a0ic.get(cncpt);
    int switchIndex=(preIndex == null ? -1 : preIndex);
switch (switchIndex) {
case 0:
      if (true) {
        return props_AbsExpression;
      }
    break;
case 1:
  if (true) {
    return props_AbstractIndex;
  }
break;
case 2:
if (true) {
return props_ArithmSymbol;
}
break;
case 3:
if (true) {
return props_BigComplexType;
}
break;
case 4:
if (true) {
return props_BigDecimalType;
}
break;
case 5:
if (true) {
return props_BigIntegerType;
}
break;
case 6:
if (true) {
return props_BigMaxExpression;
}
break;
case 7:
if (true) {
return props_BigMinExpression;
}
break;
case 8:
if (true) {
return props_BigProdExpression;
}
break;
case 9:
if (true) {
return props_BigSumExpression;
}
break;
case 10:
if (true) {
return props_ComplexLiteral;
}
break;
case 11:
if (true) {
return props_ComplexType;
}
break;
case 12:
if (true) {
return props_ConjugateOperation;
}
break;
case 13:
if (true) {
return props_CosineExpression;
}
break;
case 14:
if (true) {
return props_DecimalBinaryOperation;
}
break;
case 15:
if (true) {
return props_DecimalDivExpression;
}
break;
case 16:
if (true) {
return props_DecimalMinusExpression;
}
break;
case 17:
if (true) {
return props_DecimalMulExpression;
}
break;
case 18:
if (true) {
return props_DecimalPlusExpression;
}
break;
case 19:
if (true) {
return props_Determinant;
}
break;
case 20:
if (true) {
return props_DivExpressionFraction;
}
break;
case 21:
if (true) {
return props_ExponentExpression;
}
break;
case 22:
if (true) {
return props_ExponentialOperation;
}
break;
case 23:
if (true) {
return props_ExtrSymbol;
}
break;
case 24:
if (true) {
return props_InIntervalExpression;
}
break;
case 25:
if (true) {
return props_IntervalContainsExpression;
}
break;
case 26:
if (true) {
return props_IntervalLiteral;
}
break;
case 27:
if (true) {
return props_IntervalType;
}
break;
case 28:
if (true) {
return props_LinearSolveOperation;
}
break;
case 29:
if (true) {
return props_LiteralI;
}
break;
case 30:
if (true) {
return props_LogExpression;
}
break;
case 31:
if (true) {
return props_MathContext;
}
break;
case 32:
if (true) {
return props_MathFuncExpression;
}
break;
case 33:
if (true) {
return props_MathPrimitiveType;
}
break;
case 34:
if (true) {
return props_MathSymbol;
}
break;
case 35:
if (true) {
return props_MathSymbolFromToIndex;
}
break;
case 36:
if (true) {
return props_MathSymbolIndex;
}
break;
case 37:
if (true) {
return props_MathSymbolIndexReference;
}
break;
case 38:
if (true) {
return props_MathTypeCast;
}
break;
case 39:
if (true) {
return props_MatrixConstructor;
}
break;
case 40:
if (true) {
return props_MatrixElementAccessExpression;
}
break;
case 41:
if (true) {
return props_MatrixExponentialOperation;
}
break;
case 42:
if (true) {
return props_MatrixIndexWildcard;
}
break;
case 43:
if (true) {
return props_MatrixInitializer;
}
break;
case 44:
if (true) {
return props_MatrixInitializerIndex;
}
break;
case 45:
if (true) {
return props_MatrixInitializerIndexReference;
}
break;
case 46:
if (true) {
return props_MatrixInverseOperation;
}
break;
case 47:
if (true) {
return props_MatrixNorm;
}
break;
case 48:
if (true) {
return props_MatrixOrVectorInitializer;
}
break;
case 49:
if (true) {
return props_MatrixOrVectorType;
}
break;
case 50:
if (true) {
return props_MatrixType;
}
break;
case 51:
if (true) {
return props_MatrixUnit;
}
break;
case 52:
if (true) {
return props_MatrixZero;
}
break;
case 53:
if (true) {
return props_PowExpression;
}
break;
case 54:
if (true) {
return props_SineExpression;
}
break;
case 55:
if (true) {
return props_TangentExpression;
}
break;
case 56:
if (true) {
return props_TransposeOperation;
}
break;
case 57:
if (true) {
return props_VectorInitializer;
}
break;
case 58:
if (true) {
return props_VectorType;
}
break;
default :
}
}
throw new IllegalStateException();
}
