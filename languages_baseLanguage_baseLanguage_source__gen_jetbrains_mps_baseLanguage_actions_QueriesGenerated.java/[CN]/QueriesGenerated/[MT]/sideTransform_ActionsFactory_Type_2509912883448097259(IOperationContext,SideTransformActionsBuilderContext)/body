{
  List<SubstituteAction> result=ListSequence.fromList(new ArrayList<SubstituteAction>());
  ListSequence.fromList(result).addElement(new AbstractSideTransformHintSubstituteAction(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.FieldDeclaration"),_context.getSourceNode()){
    public SNode doSubstitute(    @Nullable final EditorContext editorContext,    String pattern){
      SNode field=SNodeOperations.cast(SNodeOperations.getParent(_context.getSourceNode()),"jetbrains.mps.baseLanguage.structure.FieldDeclaration");
      SPropertyOperations.set(field,"isTransient","" + (true));
      return field;
    }
    public String getMatchingText(    String pattern){
      return "transient";
    }
    public String getVisibleMatchingText(    String pattern){
      return getMatchingText(pattern);
    }
    @Override protected boolean isEnabled(){
      SNode sourceNode=getSourceNode();
      SNode parent=SNodeOperations.getParent(sourceNode);
      SNode containingLink=SNodeOperations.getContainingLinkDeclaration(sourceNode);
      return parent == null || containingLink == null || (ModelConstraints.canBeParent(parent,SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.FieldDeclaration"),containingLink,null,null) && ModelConstraints.canBeAncestor(parent,null,SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.FieldDeclaration"),null));
    }
  }
);
  ListSequence.fromList(result).addElement(new AbstractSideTransformHintSubstituteAction(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.FieldDeclaration"),_context.getSourceNode()){
    public SNode doSubstitute(    @Nullable final EditorContext editorContext,    String pattern){
      SNode field=SNodeOperations.cast(SNodeOperations.getParent(_context.getSourceNode()),"jetbrains.mps.baseLanguage.structure.FieldDeclaration");
      SPropertyOperations.set(field,"isVolatile","" + (true));
      return field;
    }
    public String getMatchingText(    String pattern){
      return "volatile";
    }
    public String getVisibleMatchingText(    String pattern){
      return getMatchingText(pattern);
    }
    @Override protected boolean isEnabled(){
      SNode sourceNode=getSourceNode();
      SNode parent=SNodeOperations.getParent(sourceNode);
      SNode containingLink=SNodeOperations.getContainingLinkDeclaration(sourceNode);
      return parent == null || containingLink == null || (ModelConstraints.canBeParent(parent,SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.FieldDeclaration"),containingLink,null,null) && ModelConstraints.canBeAncestor(parent,null,SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.FieldDeclaration"),null));
    }
  }
);
  ListSequence.fromList(result).addElement(new AbstractSideTransformHintSubstituteAction(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.FieldDeclaration"),_context.getSourceNode()){
    public SNode doSubstitute(    @Nullable final EditorContext editorContext,    String pattern){
      SNode field=SNodeOperations.cast(SNodeOperations.getParent(_context.getSourceNode()),"jetbrains.mps.baseLanguage.structure.FieldDeclaration");
      SNode staticField=SNodeFactoryOperations.replaceWithNewChild(field,"jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration");
      SPropertyOperations.set(staticField,"name",SPropertyOperations.getString(field,"name"));
      SLinkOperations.setTarget(staticField,"type",SLinkOperations.getTarget(field,"type",true),true);
      SLinkOperations.setTarget(staticField,"initializer",SLinkOperations.getTarget(field,"initializer",true),true);
      SPropertyOperations.set(staticField,"isVolatile","" + (SPropertyOperations.getBoolean(field,"isVolatile")));
      SPropertyOperations.set(staticField,"isFinal","" + (SPropertyOperations.getBoolean(field,"isFinal")));
      SPropertyOperations.set(staticField,"isTransient","" + (SPropertyOperations.getBoolean(field,"isTransient")));
      ListSequence.fromList(SLinkOperations.getTargets(staticField,"annotation",true)).addSequence(ListSequence.fromList(SLinkOperations.getTargets(field,"annotation",true)));
      SLinkOperations.setTarget(staticField,"visibility",SLinkOperations.getTarget(field,"visibility",true),true);
      SPropertyOperations.set(staticField,"isDeprecated","" + (SPropertyOperations.getBoolean(field,"isDeprecated")));
      AttributeOperations.setAttribute(staticField,new IAttributeDescriptor.NodeAttribute("jetbrains.mps.baseLanguage.javadoc.structure.FieldDocComment"),AttributeOperations.getAttribute(field,new IAttributeDescriptor.NodeAttribute("jetbrains.mps.baseLanguage.javadoc.structure.FieldDocComment")));
      return staticField;
    }
    public String getMatchingText(    String pattern){
      return "static";
    }
    public String getVisibleMatchingText(    String pattern){
      return getMatchingText(pattern);
    }
    @Override protected boolean isEnabled(){
      SNode sourceNode=getSourceNode();
      SNode parent=SNodeOperations.getParent(sourceNode);
      SNode containingLink=SNodeOperations.getContainingLinkDeclaration(sourceNode);
      return parent == null || containingLink == null || (ModelConstraints.canBeParent(parent,SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.FieldDeclaration"),containingLink,null,null) && ModelConstraints.canBeAncestor(parent,null,SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.FieldDeclaration"),null));
    }
  }
);
  return result;
}
