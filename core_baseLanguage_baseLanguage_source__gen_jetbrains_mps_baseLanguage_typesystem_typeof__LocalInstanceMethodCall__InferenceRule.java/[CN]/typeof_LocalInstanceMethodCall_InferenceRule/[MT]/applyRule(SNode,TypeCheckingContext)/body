{
  if (SLinkOperations.getTarget(methodCall,"baseMethodDeclaration",false) == null) {
    return;
  }
  SNode methodDeclaration=SLinkOperations.getTarget(methodCall,"baseMethodDeclaration",false);
  final SNode methodClassifier=SNodeOperations.getAncestor(methodDeclaration,"jetbrains.mps.baseLanguage.structure.Classifier",false,false);
  SNode currentClassifier=SNodeOperations.getAncestor(methodCall,"jetbrains.mps.baseLanguage.structure.Classifier",false,false);
  while (currentClassifier != null && !(ListSequence.fromList(Classifier_Behavior.call_getVisibleMembers_1213877306257(currentClassifier,methodCall,IClassifiersSearchScope.INSTANCE_METHOD)).contains(methodDeclaration))) {
    currentClassifier=SNodeOperations.getAncestor(currentClassifier,"jetbrains.mps.baseLanguage.structure.Classifier",false,false);
  }
  SNode constructedType=new typeof_LocalInstanceMethodCall_InferenceRule.QuotationClass_h4n2qb_a0a6a0().createNode(currentClassifier,typeCheckingContext);
  for (  SNode tvd : SLinkOperations.getTargets(currentClassifier,"typeVariableDeclaration",true)) {
    SNode tvr=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TypeVariableReference",null);
    SLinkOperations.setTarget(tvr,"typeVariableDeclaration",tvd,false);
    ListSequence.fromList(SLinkOperations.getTargets(constructedType,"parameter",true)).addElement(tvr);
  }
  Map<SNode,List<SNode>> mmap=MapSequence.fromMap(new HashMap<SNode,List<SNode>>());
  RulesFunctions_BaseLanguage.inference_equateParametersAndReturnType(typeCheckingContext,methodCall,SLinkOperations.getTarget(SLinkOperations.getTarget(methodCall,"baseMethodDeclaration",false),"returnType",true),mmap);
  RulesFunctions_BaseLanguage.inference_matchConcreteTypesWithMethodTypeVariables(typeCheckingContext,methodCall,mmap);
  RulesFunctions_BaseLanguage.inference_matchConcreteTypesWithTypeVariables(typeCheckingContext,methodClassifier,constructedType,mmap);
  RulesFunctions_BaseLanguage.inference_equateMatchingTypeVariables(typeCheckingContext,mmap);
}
