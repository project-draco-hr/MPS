{
  if (SLinkOperations.getTarget(methodCall,"baseMethodDeclaration",false) == null) {
    return;
  }
  final SNode methodClassifier=SNodeOperations.getAncestor(SLinkOperations.getTarget(methodCall,"baseMethodDeclaration",false),"jetbrains.mps.baseLanguage.structure.ClassConcept",false,false);
  SNode constructedType=new typeof_LocalInstanceMethodCall_InferenceRule.QuotationClass_h4n2qb_a0a3a0().createNode(methodClassifier,typeCheckingContext);
  for (  SNode tvd : SLinkOperations.getTargets(methodClassifier,"typeVariableDeclaration",true)) {
    SNode tvr=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TypeVariableReference",null);
    SLinkOperations.setTarget(tvr,"typeVariableDeclaration",tvd,false);
    ListSequence.fromList(SLinkOperations.getTargets(constructedType,"parameter",true)).addElement(tvr);
  }
  Map<SNode,List<SNode>> mmap=MapSequence.fromMap(new HashMap<SNode,List<SNode>>());
  RulesFunctions_BaseLanguage.inference_equateParametersAndReturnType(typeCheckingContext,methodCall,SLinkOperations.getTarget(SLinkOperations.getTarget(methodCall,"baseMethodDeclaration",false),"returnType",true),mmap);
  RulesFunctions_BaseLanguage.inference_matchConcreteTypesWithMethodTypeVariables(typeCheckingContext,methodCall,mmap);
  RulesFunctions_BaseLanguage.inference_matchConcreteTypesWithTypeVariables(typeCheckingContext,methodClassifier,constructedType,mmap);
  RulesFunctions_BaseLanguage.inference_equateMatchingTypeVariables(typeCheckingContext,mmap);
}
