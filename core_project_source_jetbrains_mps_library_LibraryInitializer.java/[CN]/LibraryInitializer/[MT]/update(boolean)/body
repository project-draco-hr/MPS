{
  ModelAccess.assertLegalWrite();
  final Set<SLibrary> toUnload=new HashSet<SLibrary>(myLibraries);
  final Set<SLibrary> toLoad=new HashSet<SLibrary>();
  myParentLoaders.clear();
  for (  LibraryContributor lc : myContributors) {
    for (    LibDescriptor s : lc.getLibraries()) {
      IFile path=FileSystem.getInstance().getFileByPath(s.path);
      SLibrary lib=new SLibrary(path,s.parentLoader,lc.hiddenLanguages());
      toUnload.remove(lib);
      if (!myLibraries.contains(lib)) {
        myLibraries.add(lib);
        toLoad.add(lib);
      }
      IFile bundlePath=FileSystem.getInstance().isPackaged(path) ? FileSystem.getInstance().getBundleHome(path) : null;
      myParentLoaders.put(bundlePath != null ? bundlePath.getPath() : s.path,s.parentLoader != null ? s.parentLoader : LibraryInitializer.class.getClassLoader());
    }
  }
  myLibraries.removeAll(toUnload);
  if (toUnload.size() + toLoad.size() == 0)   return;
  LOG.info("Updating libraries");
  ModelAccess.instance().runWriteAction(new Runnable(){
    @Override public void run(){
      ArrayList<SLibrary> toUnloadList=new ArrayList<SLibrary>(toUnload);
      ArrayList<SLibrary> toLoadList=new ArrayList<SLibrary>(toLoad);
      Collections.sort(toUnloadList);
      Collections.sort(toLoadList);
      for (      SLibrary unloadLib : toUnloadList) {
        unloadLib.dispose();
      }
      for (      SLibrary loadLib : toLoadList) {
        loadLib.attach(refreshFiles);
      }
    }
  }
);
  CleanupManager.getInstance().cleanup();
}
