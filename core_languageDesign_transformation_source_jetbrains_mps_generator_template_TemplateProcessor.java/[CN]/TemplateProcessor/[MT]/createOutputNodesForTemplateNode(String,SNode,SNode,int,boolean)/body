{
  GenerationTracer generationTracer=myGenerator.getGeneratorSessionContext().getGenerationTracer();
  int macroCount=0;
  List<SNode> outputNodes=new ArrayList<SNode>();
  for (  INodeAdapter templateChildNode : templateNode.getAdapter().getChildren()) {
    if (!(templateChildNode instanceof NodeMacro))     continue;
    macroCount++;
    if (macroCount <= nodeMacrosToSkip)     continue;
    NodeMacro nodeMacro=(NodeMacro)templateChildNode;
    generationTracer.pushMacro(nodeMacro.getNode());
    try {
      return createOutputNodesForTemplateNodeWithMacro(nodeMacro,templateNode,inputNode,nodeMacrosToSkip,registerTopOutput);
    }
  finally {
      generationTracer.closeMacro(nodeMacro.getNode());
    }
  }
  generationTracer.pushTemplateNode(templateNode);
  SNode outputNode=SModelUtil_new.instantiateConceptDeclaration(templateNode.getConceptFqName(),myOutputModel,myGenerator.getScope(),false);
  if (outputNode == null) {
    myGenerator.showErrorMessage(null,templateNode,"'createOutputNodesForTemplateNode' cannot create output node");
    return null;
  }
  outputNodes.add(outputNode);
  if (registerTopOutput) {
    myGenerator.addTopOutputNodeByInputNode(inputNode,outputNode);
  }
  myGenerator.addOutputNodeByInputAndTemplateNode(inputNode,templateNode,outputNode);
  if (!myInputHistory.isEmpty()) {
    for (    Pair<SNode,String> nodeAndMappingName : myInputHistory) {
      myGenerator.addOutputNodeByIndirectInputAndTemplateNode(nodeAndMappingName.o1,templateNode,outputNode);
    }
  }
  myGenerator.addOutputNodeByInputNodeAndMappingName(inputNode,mappingName,outputNode);
  myGenerator.addTemplateNodeByOutputNode(outputNode,templateNode);
  myGenerator.addOutputNodeByTemplateNode(templateNode,outputNode);
  outputNode.putProperties(templateNode);
  SModel templateModel=templateNode.getModel();
  for (  SReference reference : templateNode.getReferences()) {
    if (templateNode.getLinkAttribute("referenceMacro",reference.getRole()) != null) {
      continue;
    }
    SNode templateReferentNode=reference.getTargetNode();
    if (templateReferentNode == null) {
      myGenerator.showErrorMessage(null,templateNode,"'createOutputNodesForTemplateNode()' referent '" + reference.getRole() + "' is null in template model");
      continue;
    }
    if (templateReferentNode.getModel() == templateModel) {
      ReferenceInfo_TemplateNode refInfo=new ReferenceInfo_TemplateNode(outputNode,reference,inputNode,myInputHistory.isEmpty() ? null : new ArrayList<Pair<SNode,String>>(myInputHistory));
      PostponedReference postponedReference=new PostponedReference(refInfo,myGenerator);
      outputNode.addReference(postponedReference);
    }
 else {
      outputNode.setReferent(reference.getRole(),templateReferentNode);
    }
  }
  List<INodeAdapter> templateChildNodes=new ArrayList<INodeAdapter>();
  for (  INodeAdapter templateChildNode : templateNode.getAdapter().getChildren()) {
    if (templateChildNode instanceof PropertyMacro) {
      MacroUtil.expandPropertyMacro(myGenerator,(PropertyMacro)templateChildNode,inputNode,templateNode,outputNode);
    }
 else     if (templateChildNode instanceof ReferenceMacro) {
      ReferenceInfo_Macro refInfo=new ReferenceInfo_Macro(outputNode,(ReferenceMacro)templateChildNode,inputNode,templateNode);
      PostponedReference postponedReference=new PostponedReference(refInfo,myGenerator);
      outputNode.addReference(postponedReference);
    }
 else     if (!GeneratorUtil.isTemplateLanguageElement(templateChildNode)) {
      templateChildNodes.add(templateChildNode);
    }
  }
  try {
    for (    INodeAdapter templateChildNode : templateChildNodes) {
      List<SNode> outputChildNodes=createOutputNodesForTemplateNode(null,templateChildNode.getNode(),inputNode,0,false);
      if (outputChildNodes != null) {
        String role=templateChildNode.getRole_();
        for (        SNode outputChildNode : outputChildNodes) {
          outputNode.addChild(role,outputChildNode);
        }
      }
    }
  }
  finally {
    generationTracer.pushOutputNode(outputNode);
    generationTracer.closeTemplateNode(templateNode);
  }
  return outputNodes;
}
