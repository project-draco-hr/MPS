{
  if (generator.getProgressMonitor().isCanceled()) {
    throw new GenerationCanceledException();
  }
  TemplateProcessor templateProcessor=new TemplateProcessor(generator);
  Map<String,SNode> old=generator.setPreviousInputNodesByMappingName(templateProcessor.myInputNodesByMappingName);
  try {
    List<SNode> outputNodels=templateProcessor.createOutputNodesForTemplateNode(mappingName,templateNode,inputNode,0,true);
    if (outputNodels == null) {
      throw new TemplateProcessingFailureException();
    }
    return outputNodels;
  }
 catch (  StackOverflowError e) {
    LOG.error("generation thread run out of stack space :(");
    if (generator.getGeneratorSessionContext().getGenerationTracer().isTracing()) {
      LOG.error("failed branch was:");
      List<Pair<SNode,String>> pairs=generator.getGeneratorSessionContext().getGenerationTracer().getNodesWithTextFromCurrentBranch();
      StringBuilder indent=new StringBuilder("");
      boolean indentInc=true;
      for (      Pair<SNode,String> pair : pairs) {
        LOG.error(indent + pair.o2 + (pair.o1 != null ? ": " + pair.o1.getDebugText() : ""),pair.o1);
        if (indentInc && indent.length() >= 80) {
          indentInc=false;
        }
 else         if (indent.length() == 0) {
          indentInc=true;
        }
        if (indentInc) {
          indent.append(".");
        }
 else {
          indent.deleteCharAt(indent.length() - 1);
        }
      }
    }
 else {
      LOG.error("try to increase JVM stack size (-Xss option)");
      LOG.error("to get more diagnostic generate model with the 'save transient models' option");
    }
    throw new GenerationFailueException("couldn't process template",inputNode,templateNode,null,e);
  }
 finally {
    generator.setPreviousInputNodesByMappingName(old);
  }
}
