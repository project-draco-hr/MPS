{
  IWrapper subtypeRepresentator=getRepresentatorWrapper(subType);
  IWrapper supertypeRepresentator=getRepresentatorWrapper(supertype);
  if (NodeWrapper.fromWrapper(subtypeRepresentator) == NodeWrapper.fromWrapper(supertypeRepresentator))   return;
  boolean supertypeConcrete=supertypeRepresentator == null || supertypeRepresentator.isConcrete();
  isConcrete(subtypeRepresentator);
  boolean subtypeHasNonConcreteVars=!isConcrete(subtypeRepresentator);
  boolean supertypeHasNonConcreteVars=!isConcrete(supertypeRepresentator);
  if (subtypeRepresentator instanceof HoleWrapper) {
    HoleWrapper subHole=(HoleWrapper)subtypeRepresentator;
    subHole.getInequationSystem().addSupertype(supertypeRepresentator,isWeak);
    return;
  }
  if (supertypeRepresentator instanceof HoleWrapper) {
    HoleWrapper superHole=(HoleWrapper)supertypeRepresentator;
    superHole.getInequationSystem().addSubtype(subtypeRepresentator,isWeak);
    return;
  }
  if (checkOnly && myUsesCheckOnly) {
    if (subtypeHasNonConcreteVars || supertypeHasNonConcreteVars) {
      if (isWeak) {
        addSubtyping(subtypeRepresentator,supertypeRepresentator,equationInfo,true);
      }
 else {
        addStrongSubtyping(subtypeRepresentator,supertypeRepresentator,equationInfo,true);
      }
      return;
    }
  }
  if (subtypeRepresentator instanceof NodeWrapper && supertypeRepresentator instanceof NodeWrapper) {
    SNode node1=subtypeRepresentator.getNode();
    SNode node2=supertypeRepresentator.getNode();
    Set<Pair<InequationReplacementRule_Runtime,IsApplicable2Status>> inequationReplacementRules=myTypeChecker.getRulesManager().getReplacementRules(node1,node2);
    for (    Pair<InequationReplacementRule_Runtime,IsApplicable2Status> inequationReplacementRule : inequationReplacementRules) {
      processInequationWithReplacementRule(inequationReplacementRule.o1,node1,node2,equationInfo,myTypeCheckingContext);
      return;
    }
  }
  if (subtypeHasNonConcreteVars && solveOnlyConcrete || !supertypeConcrete) {
    if (isWeak) {
      addSubtyping(subtypeRepresentator,supertypeRepresentator,equationInfo,false);
    }
 else {
      addStrongSubtyping(subtypeRepresentator,supertypeRepresentator,equationInfo,false);
    }
    return;
  }
  if (subtypeRepresentator instanceof NodeWrapper) {
    NodeWrapper subtypeNodeWrapper=(NodeWrapper)subtypeRepresentator;
    SModel typesModel=myTypeChecker.getRuntimeTypesModel();
    NodeWrapper representatorCopy=NodeWrapper.fromNode(CopyUtil.copy(subtypeNodeWrapper.getNode()),this);
    subtypeRepresentator=expandWrapper(null,representatorCopy,typesModel);
  }
  if (supertypeRepresentator instanceof NodeWrapper) {
    NodeWrapper supertypeNodeWrapper=(NodeWrapper)supertypeRepresentator;
    SModel typesModel=myTypeChecker.getRuntimeTypesModel();
    NodeWrapper representatorCopy=NodeWrapper.fromNode(CopyUtil.copy(supertypeNodeWrapper.getNode()),this);
    supertypeRepresentator=expandWrapper(null,representatorCopy,typesModel);
  }
  if (myTypeChecker.getSubtypingManager().isSubtype(subtypeRepresentator,supertypeRepresentator,this,equationInfo,isWeak)) {
    return;
  }
  IErrorReporter errorReporter;
  String errorString=equationInfo.getErrorString();
  String ruleModel=equationInfo.getRuleModel();
  String ruleId=equationInfo.getRuleId();
  SNode nodeWithError=equationInfo.getNodeWithError();
  if (errorString == null) {
    String strongString=isWeak ? "" : " strong";
    errorReporter=new EquationErrorReporter(nodeWithError,this,"type ",subtypeRepresentator," is not a" + strongString + " subtype of ",supertypeRepresentator,"",ruleModel,ruleId);
  }
 else {
    errorReporter=new SimpleErrorReporter(nodeWithError,errorString,ruleModel,ruleId);
  }
  errorReporter.setIntentionProvider(equationInfo.getIntentionProvider());
  errorReporter.setAdditionalRulesIds(equationInfo.getAdditionalRulesIds());
  myTypeCheckingContext.reportMessage(nodeWithError,errorReporter);
}
