{
  return typeLessThanThis(var,isWeak,new IActionPerformer(){
    public void performAction(    IWrapper type,    Set<IWrapper> concreteSubtypes,    Map<IWrapper,EquationInfo> errorInfoMap,    boolean isWeak,    EquationInfo errorInfo){
      Set<IWrapper> expandedSubtypes=new HashSet<IWrapper>();
      for (      IWrapper subtype : concreteSubtypes) {
        IWrapper expanded=expandWrapper(null,subtype,myTypeChecker.getRuntimeTypesModel());
        expandedSubtypes.add(expanded);
      }
      ISlicer slicer=myTypeCheckingContext.getCurrentSlicer();
      IWrapper otherType=myTypeChecker.getSubtypingManager().leastCommonSupertype(expandedSubtypes,isWeak,EquationManager.this);
      SNode node=otherType == null ? null : otherType.getNode();
      slicer.beforeInequationsSolvedForType(type.getNode(),node,new ArrayList<EquationInfo>(errorInfoMap.values()));
      addEquation(type,otherType,errorInfo);
    }
  }
,priority,minPriority,isShallow,prioritiesSynthesizer);
}
