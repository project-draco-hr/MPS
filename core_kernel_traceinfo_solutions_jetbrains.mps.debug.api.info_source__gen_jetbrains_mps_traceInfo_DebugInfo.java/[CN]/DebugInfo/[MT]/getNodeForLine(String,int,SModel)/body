{
  List<TraceablePositionInfo> resultList=getInfoForPosition(file,line,new _FunctionTypes._return_P1_E0<Set<TraceablePositionInfo>,DebugInfoRoot>(){
    public Set<TraceablePositionInfo> invoke(    DebugInfoRoot root){
      return root.getPositions();
    }
  }
);
  if (ListSequence.fromList(resultList).isEmpty()) {
    return null;
  }
  Iterable<TraceablePositionInfo> sorted=ListSequence.fromList(resultList).sort(new ISelector<TraceablePositionInfo,Comparable<?>>(){
    public Comparable<?> select(    TraceablePositionInfo it){
      return it;
    }
  }
,true);
  final TraceablePositionInfo firstPositionInfo=Sequence.fromIterable(sorted).first();
  String nodeId=firstPositionInfo.getNodeId();
  if (Sequence.fromIterable(sorted).count() > 1 && firstPositionInfo.getStartLine() == line && firstPositionInfo.getLineDistance() > 0) {
    nodeId=ListSequence.fromList(Sequence.fromIterable(sorted).toListSequence()).getElement(1).getNodeId();
  }
  if (Sequence.fromIterable(sorted).count() > 1) {
    Iterable<TraceablePositionInfo> sameSpacePositions=Sequence.fromIterable(sorted).where(new IWhereFilter<TraceablePositionInfo>(){
      public boolean accept(      TraceablePositionInfo it){
        return firstPositionInfo.isOccupyTheSameSpace(it);
      }
    }
);
    if (Sequence.fromIterable(sameSpacePositions).count() > 1) {
      SNode currentNode=model.getNodeById(firstPositionInfo.getNodeId());
      boolean finished=false;
      while (!(finished)) {
        finished=true;
        for (        TraceablePositionInfo otherPos : Sequence.fromIterable(sameSpacePositions)) {
          SNode otherNode=model.getNodeById(otherPos.getNodeId());
          if ((otherNode != null) && otherNode.isDescendantOf(currentNode,false)) {
            currentNode=otherNode;
            finished=false;
            break;
          }
        }
      }
      return currentNode;
    }
  }
  return model.getNodeById(nodeId);
}
