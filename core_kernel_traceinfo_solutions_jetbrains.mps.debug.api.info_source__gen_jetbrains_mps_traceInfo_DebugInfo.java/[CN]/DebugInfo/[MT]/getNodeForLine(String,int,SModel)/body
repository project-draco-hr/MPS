{
  List<TraceablePositionInfo> resultList=ListSequence.fromList(new ArrayList<TraceablePositionInfo>());
  for (  TraceablePositionInfo element : Sequence.fromIterable(MapSequence.fromMap(myRoots).values()).<TraceablePositionInfo>translate(new ITranslator2<DebugInfoRoot,TraceablePositionInfo>(){
    public Iterable<TraceablePositionInfo> translate(    DebugInfoRoot it){
      return it.getPositions();
    }
  }
)) {
    if (eq_exfyrk_a0a0a0b0i(element.getFileName(),file) && element.getStartLine() <= line && line <= element.getEndLine()) {
      ListSequence.fromList(resultList).addElement(element);
    }
  }
  if (ListSequence.fromList(resultList).isEmpty()) {
    return null;
  }
  Iterable<TraceablePositionInfo> sorted=ListSequence.fromList(resultList).sort(new ISelector<TraceablePositionInfo,Comparable<?>>(){
    public Comparable<?> select(    TraceablePositionInfo it){
      return it;
    }
  }
,true);
  final TraceablePositionInfo firstPositionInfo=Sequence.fromIterable(sorted).first();
  String nodeId=firstPositionInfo.getNodeId();
  if (Sequence.fromIterable(sorted).count() > 1 && firstPositionInfo.getStartLine() == line && firstPositionInfo.getLineDistance() > 0) {
    nodeId=ListSequence.fromList(Sequence.fromIterable(sorted).toListSequence()).getElement(1).getNodeId();
  }
  if (Sequence.fromIterable(sorted).count() > 1) {
    Iterable<TraceablePositionInfo> sameSpacePositions=Sequence.fromIterable(sorted).where(new IWhereFilter<TraceablePositionInfo>(){
      public boolean accept(      TraceablePositionInfo it){
        return firstPositionInfo.isOccupyTheSameSpace(it);
      }
    }
);
    if (Sequence.fromIterable(sameSpacePositions).count() > 1) {
      SNode currentNode=model.getNodeById(firstPositionInfo.getNodeId());
      boolean finished=false;
      while (!(finished)) {
        finished=true;
        for (        TraceablePositionInfo otherPos : Sequence.fromIterable(sameSpacePositions)) {
          SNode otherNode=model.getNodeById(otherPos.getNodeId());
          if ((otherNode != null) && otherNode.isDescendantOf(currentNode,false)) {
            currentNode=otherNode;
            finished=false;
            break;
          }
        }
      }
      return currentNode;
    }
  }
  return model.getNodeById(nodeId);
}
