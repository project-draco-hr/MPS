{
  ReferentsCreator referentsCreator=new ReferentsCreator(new HashMap<String,SModel>(myPackageFQNamesToModels));
  referentsCreator.exec(myCompilationUnitDeclarations.toArray(new CompilationUnitDeclaration[myCompilationUnitDeclarations.size()]));
  JavaConverterTreeBuilder treeBuilder=new JavaConverterTreeBuilder();
  List<SNode> result=treeBuilder.exec(referentsCreator,myPackageFQNamesToModels,isolated);
  for (  final CompilationUnitDeclaration cud : ListSequence.fromList(myCompilationUnitDeclarations)) {
    char[] content=cud.compilationResult().getCompilationUnit().getContents();
    int[][] comments=cud.comments;
    int[] lineends=cud.compilationResult().lineSeparatorPositions;
    final Map<SNode,Integer> positions=treeBuilder.myPositions;
    Iterable<Tuples._4<SNode,CompilationUnitDeclaration,Integer,Integer>> blocks=ListSequence.fromList(treeBuilder.myBlocks).where(new IWhereFilter<Tuples._4<SNode,CompilationUnitDeclaration,Integer,Integer>>(){
      public boolean accept(      Tuples._4<SNode,CompilationUnitDeclaration,Integer,Integer> it){
        return it._1() == cud;
      }
    }
).sort(new Comparator<Tuples._4<SNode,CompilationUnitDeclaration,Integer,Integer>>(){
      public int compare(      Tuples._4<SNode,CompilationUnitDeclaration,Integer,Integer> a,      Tuples._4<SNode,CompilationUnitDeclaration,Integer,Integer> b){
        return (int)a._3() - (int)b._3();
      }
    }
,true);
    for (    int[] comment : comments) {
      if (comment[1] > 0) {
        continue;
      }
      final int linestart=Math.abs(comment[0]);
      SNode block=null;
      for (      Tuples._4<SNode,CompilationUnitDeclaration,Integer,Integer> blk : Sequence.fromIterable(blocks)) {
        if ((int)blk._2() <= linestart && linestart <= (int)blk._3()) {
          block=blk._0();
          break;
        }
      }
      if ((block != null)) {
        int pos=ListSequence.fromList(SLinkOperations.getTargets(block,"statement",true)).where(new IWhereFilter<SNode>(){
          public boolean accept(          SNode it){
            return !(MapSequence.fromMap(positions).containsKey(it)) || Math.abs(MapSequence.fromMap(positions).get(it)) <= linestart;
          }
        }
).count();
        for (        String line : ListSequence.fromList(CommentHelper.processComment(CommentHelper.splitString(content,lineends,linestart,Math.abs(comment[1]))))) {
          SNode commentText=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.TextCommentPart",null);
          SPropertyOperations.set(commentText,"text",line);
          SNode commentLine=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.SingleLineComment",null);
          ListSequence.fromList(SLinkOperations.getTargets(commentLine,"commentPart",true)).addElement(commentText);
          ListSequence.fromList(SLinkOperations.getTargets(block,"statement",true)).insertElement(pos++,commentLine);
        }
      }
 else {
        LOG.warning("cannot find a place to import comment from " + new String(cud.getMainTypeName()) + ":\n"+ new String(content,linestart,Math.abs(comment[1]) - linestart));
      }
    }
  }
  return result;
}
