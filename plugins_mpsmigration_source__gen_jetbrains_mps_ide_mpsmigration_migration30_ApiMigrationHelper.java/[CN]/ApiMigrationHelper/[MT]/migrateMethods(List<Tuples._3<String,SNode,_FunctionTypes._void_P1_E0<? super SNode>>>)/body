{
  List<Tuples._2<Set<SNode>,Set<SNode>>> usages=ListSequence.fromList(new ArrayList<Tuples._2<Set<SNode>,Set<SNode>>>());
  for (  Tuples._3<String,SNode,_FunctionTypes._void_P1_E0<? super SNode>> transformation : ListSequence.fromList(transformations)) {
    Set<SNode> method=SetSequence.fromSetAndArray(new HashSet<SNode>(),transformation._1());
    Set<SReference> musages=((Set)FindUsagesManager.getInstance().findUsages(((Set)method),SearchType.USAGES,scope,new EmptyProgressMonitor()));
    Set<SNode> unknown=SetSequence.fromSet(new HashSet<SNode>());
    Set<SNode> known=SetSequence.fromSet(new HashSet<SNode>());
    for (    SReference usage : SetSequence.fromSet(musages)) {
      SNode n=usage.getSourceNode();
      if (!(needMigration(n))) {
        continue;
      }
      boolean isCorrectConcept=SNodeOperations.isInstanceOf(n,"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation") && SConceptOperations.isExactly(SNodeOperations.getConceptDeclaration(SNodeOperations.getParent(n)),"jetbrains.mps.baseLanguage.structure.DotExpression") || SNodeOperations.isInstanceOf(n,"jetbrains.mps.baseLanguage.structure.ClassCreator");
      if (!(isCorrectConcept) || (SNodeOperations.getAncestor(n,"jetbrains.mps.lang.quotation.structure.Quotation",false,false) != null)) {
        SetSequence.fromSet(unknown).addElement(n);
        continue;
      }
      SetSequence.fromSet(known).addElement(n);
    }
    ListSequence.fromList(usages).addElement(MultiTuple.<Set<SNode>,Set<SNode>>from(known,unknown));
  }
  for (int i=0; i < ListSequence.fromList(usages).count(); i++) {
    _FunctionTypes._void_P1_E0<? super SNode> transformer=ListSequence.fromList(transformations).getElement(i)._2();
    for (    SNode known : SetSequence.fromSet(ListSequence.fromList(usages).getElement(i)._0())) {
      if (known.getModel() == null) {
        continue;
      }
      transformer.invoke(known);
    }
  }
}
