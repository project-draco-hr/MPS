{
  List<INodeSubstituteAction> result=new ArrayList<INodeSubstituteAction>();
  final SNode leftNodeConcept;
  final ConceptHierarchyScope hierarhyScope;
{
    Calculable calc=new Calculable(){
      public Object calculate(){
        SNode leftExpression=SLinkOperations.getTarget(parentNode,"leftExpression",true);
        SNode leftNodeType=TypeChecker.getInstance().getRuntimeSupport().coerce(TypeChecker.getInstance().getTypeOf(leftExpression),HUtil.createMatchingPatternByConceptFQName("jetbrains.mps.bootstrap.smodelLanguage.structure.SNodeType"),false);
        if (SLinkOperations.getTarget(leftNodeType,"concept",false) == null) {
          return SConceptOperations.findConceptDeclaration("jetbrains.mps.core.structure.BaseConcept");
        }
        return SLinkOperations.getTarget(leftNodeType,"concept",false);
      }
    }
;
    leftNodeConcept=(SNode)calc.calculate();
  }
{
    Calculable calc=new Calculable(){
      public Object calculate(){
        return new ConceptHierarchyScope(((AbstractConceptDeclaration)SNodeOperations.getAdapter(leftNodeConcept)));
      }
    }
;
    hierarhyScope=(ConceptHierarchyScope)calc.calculate();
  }
{
    ConceptDeclaration concept=SModelUtil_new.findConceptDeclaration("jetbrains.mps.bootstrap.smodelLanguage.structure.SPropertyAccess",operationContext.getScope());
    Calculable calc=new Calculable(){
      public Object calculate(){
        List<PropertyDeclaration> adapters=hierarhyScope.getPropertyDeclarationsExcludingOverridden();
        return (List<SNode>)BaseAdapter.toNodes(adapters);
      }
    }
;
    Iterable<SNode> queryResult=(Iterable)calc.calculate();
    for (    SNode item : queryResult) {
      result.add(new DefaultChildNodeSubstituteAction(item,parentNode,currentTargetNode,childSetter,operationContext.getScope()){
        public SNode createChildNode(        Object parameterObject,        SModel model,        String pattern){
          SNode newNode=SModelOperations.createNewNode(model,"jetbrains.mps.bootstrap.smodelLanguage.structure.SPropertyAccess",null);
          SLinkOperations.setTarget(newNode,"property",((SNode)this.getParameterObject()),false);
          return newNode;
        }
      }
);
    }
  }
{
    ConceptDeclaration concept=SModelUtil_new.findConceptDeclaration("jetbrains.mps.bootstrap.smodelLanguage.structure.SConceptPropertyAccess",operationContext.getScope());
    Calculable calc=new Calculable(){
      public Object calculate(){
        List<ConceptPropertyDeclaration> adapters=hierarhyScope.getAdapters(ConceptPropertyDeclaration.class);
        return (List<SNode>)BaseAdapter.toNodes(adapters);
      }
    }
;
    Iterable<SNode> queryResult=(Iterable)calc.calculate();
    for (    SNode item : queryResult) {
      result.add(new DefaultChildNodeSubstituteAction(item,parentNode,currentTargetNode,childSetter,operationContext.getScope()){
        public SNode createChildNode(        Object parameterObject,        SModel model,        String pattern){
          SNode newNode=SModelOperations.createNewNode(model,"jetbrains.mps.bootstrap.smodelLanguage.structure.SConceptPropertyAccess",null);
          SLinkOperations.setTarget(newNode,"conceptProperty",((SNode)this.getParameterObject()),false);
          return newNode;
        }
      }
);
    }
  }
  return result;
}
