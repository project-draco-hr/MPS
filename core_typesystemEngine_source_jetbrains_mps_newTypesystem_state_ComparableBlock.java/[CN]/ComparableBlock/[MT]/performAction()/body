{
  SNode left=getResolvedInput(myLeftNode);
  SNode right=getResolvedInput(myRightNode);
  if (left == null || right == null || left == right) {
    return;
  }
  SubTyping subTyping=myState.getTypeCheckingContext().getSubTyping();
  boolean isWeak=myRelationKind.isWeak();
  if (subTyping.isComparableByRules(left,right,myEquationInfo,isWeak) || subTyping.isSubTypeByReplacementRules(left,right) || subTyping.isSubTypeByReplacementRules(right,left)|| subTyping.isSubType(left,right,myEquationInfo,isWeak,true)|| subTyping.isSubType(right,left,myEquationInfo,isWeak,true)) {
    myState.executeOperation(new AddRemarkOperation(left + " is comparable with " + right));
    return;
  }
  myState.getNodeMaps().reportComparableError(left,right,myEquationInfo,isWeak);
}
