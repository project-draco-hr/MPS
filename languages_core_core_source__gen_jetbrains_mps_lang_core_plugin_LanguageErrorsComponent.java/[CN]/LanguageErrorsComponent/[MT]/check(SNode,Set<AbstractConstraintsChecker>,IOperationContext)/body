{
  invalidate();
  if (myCheckedRoot && SetSequence.<SNode>fromSet(myInvalidNodes).isEmpty()) {
    return false;
  }
  Set<SNode> frontier=new THashSet<SNode>(1);
  SetSequence.fromSet(frontier).addElement(root);
  Set<SNode> newFrontier=new THashSet<SNode>(1);
  while (!(SetSequence.<SNode>fromSet(frontier).isEmpty())) {
    for (    SNode node : frontier) {
      if (!(myCheckedRoot) || SetSequence.<SNode>fromSet(myInvalidNodes).contains(node)) {
        try {
          myCurrentNode=node;
          addDependency(node);
          for (          AbstractConstraintsChecker checker : checkers) {
            checker.checkNode(node,this,operationContext);
          }
        }
  finally {
          myCurrentNode=null;
          SetSequence.fromSet(myInvalidNodes).removeElement(node);
        }
      }
      SetSequence.fromSet(newFrontier).addSequence(ListSequence.<SNode>fromList(SNodeOperations.getChildren(node)));
    }
    frontier=newFrontier;
    newFrontier=new THashSet<SNode>(1);
  }
  myCheckedRoot=true;
  return true;
}
