{
  if (node == null)   return null;
  if (node instanceof RuntimeTypeVariable) {
    RuntimeTypeVariable var=(RuntimeTypeVariable)node;
    SNode type=EquationManager.getInstance().getRepresentator(node);
    if (type != representator || depth > 0) {
      if (variablesMet.contains(var)) {
        RuntimeErrorType error=new RuntimeErrorType(typesModel);
        error.setErrorText("recursion types not allowed");
        return error;
      }
      variablesMet.add(var);
      node=expandNode(type,type,0,variablesMet,typesModel);
      variablesMet.remove(var);
    }
    return node;
  }
  Map<SNode,SNode> childrenReplacement=new HashMap<SNode,SNode>();
  List<SNode> children=node.getChildren();
  for (  SNode child : children) {
    SNode newChild=expandNode(child,representator,depth + 1,variablesMet,typesModel);
    if (newChild != child) {
      childrenReplacement.put(child,newChild);
    }
  }
  for (  SNode child : children) {
    if (!childrenReplacement.keySet().contains(child))     continue;
    if (child.getParent() == null) {
      System.err.println("debug");
      RuntimeErrorType error=new RuntimeErrorType(typesModel);
      error.setErrorText("recursion types not allowed");
      return error;
    }
    SNode parent=child.getParent();
    String roleInParent=child.getRole_();
    parent.removeChild(child);
    SNode childReplacement=childrenReplacement.get(child);
    childReplacement=CopyUtil.copy(childReplacement,parent.getModel());
    parent.addChild(roleInParent,childReplacement);
  }
  return node;
}
