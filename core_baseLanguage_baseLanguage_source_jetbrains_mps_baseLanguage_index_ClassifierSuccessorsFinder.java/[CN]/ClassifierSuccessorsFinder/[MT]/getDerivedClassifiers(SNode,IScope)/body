{
  Set<VirtualFile> notModifiedModelFiles=new HashSet();
  List<ClassConcept> modifiedClasses=new ArrayList();
  List<Interface> modifiedInterfaces=new ArrayList();
  for (  SModelDescriptor md : scope.getModelDescriptors()) {
    if (!(md instanceof EditableSModelDescriptor))     continue;
    EditableSModelDescriptor emd=(EditableSModelDescriptor)md;
    IFile modelFile=emd.getModelFile();
    if (modelFile == null)     continue;
    if (SModelRepository.getInstance().isChanged(emd)) {
      for (      SNode sNode : md.getSModel().allNodes()) {
        BaseAdapter adapter=sNode.getAdapter();
        if (adapter instanceof ClassConcept) {
          modifiedClasses.add((ClassConcept)adapter);
        }
 else         if (adapter instanceof Interface) {
          modifiedInterfaces.add((Interface)adapter);
        }
      }
    }
 else {
      notModifiedModelFiles.add(modelFile.toVirtualFile());
    }
  }
  List<SNode> result=new ArrayList();
  Queue<SNode> classifiersQueue=new LinkedList();
  classifiersQueue.add(classifier);
  ValueProcessor valueProcessor=new ValueProcessor(result,classifiersQueue);
  ModifiedsuccessorFinder modifiedSuccessorFinder=new ModifiedsuccessorFinder(modifiedClasses,modifiedInterfaces,result,classifiersQueue);
  SearchScope searchScope=new SearchScope(notModifiedModelFiles);
  SNode nextClassifier;
  while ((nextClassifier=classifiersQueue.poll()) != null) {
    FileBasedIndex.getInstance().processValues(ClassifierSuccessorsIndexer.NAME,new SNodeId(nextClassifier),null,valueProcessor,searchScope);
    modifiedSuccessorFinder.process(nextClassifier);
  }
  return result;
}
