{
  Tuples._2<Map<Tuples._2<SNodeId,String>,SetReferenceChange>,Map<Tuples._2<SNodeId,String>,SetReferenceChange>> arranged;
  arranged=this.<Tuples._2<SNodeId,String>,SetReferenceChange>arrangeChanges(new _FunctionTypes._return_P1_E0<Tuples._2<SNodeId,String>,SetReferenceChange>(){
    public Tuples._2<SNodeId,String> invoke(    SetReferenceChange src){
      return MultiTuple.<SNodeId,String>from(src.getAffectedNodeId(),src.getRole());
    }
  }
,SetReferenceChange.class);
  for (  Tuples._2<SNodeId,String> nodeName : SetSequence.fromSet(MapSequence.fromMap(arranged._0()).keySet()).intersect(SetSequence.fromSet(MapSequence.fromMap(arranged._1()).keySet()))) {
    SetReferenceChange mineChange=MapSequence.fromMap(arranged._0()).get(nodeName);
    SetReferenceChange repositoryChange=MapSequence.fromMap(arranged._1()).get(nodeName);
    if (EqualUtil.equals(mineChange.getTargetNodeId(),repositoryChange.getTargetNodeId()) && EqualUtil.equals(mineChange.getTargetModelReference(),repositoryChange.getTargetModelReference()) && EqualUtil.equals(mineChange.getResolveInfo(),repositoryChange.getResolveInfo())) {
      addSymmetric(mineChange,repositoryChange);
    }
 else {
      addConflict(mineChange,repositoryChange);
    }
  }
}
