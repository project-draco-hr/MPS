{
  List<SNode> derivedClassifiers=ClassifierSuccessors.getInstance().getDerivedClassifiers(container,GlobalScope.getInstance());
  if (ListSequence.fromList(derivedClassifiers).isEmpty()) {
    return;
  }
  boolean isInterface=SNodeOperations.isInstanceOf(container,MetaAdapterFactory.getConcept(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0x101edd46144L,"jetbrains.mps.baseLanguage.structure.Interface"));
  StringBuffer superClassifierTooltip=new StringBuffer();
  if (ListSequence.fromList(derivedClassifiers).count() > MAX_MESSAGE_NUMBER) {
    superClassifierTooltip.append((isInterface ? "Has implementations" : "Has subclasses"));
  }
 else {
    superClassifierTooltip.append((isInterface ? "Is implemented by" : "Is subclassed by"));
    for (    SNode subClassifier : ListSequence.fromList(derivedClassifiers)) {
      superClassifierTooltip.append(TOOLTIP_INDENT);
      superClassifierTooltip.append(getClassifierPresentation(subClassifier));
      if (SNodeOperations.isInstanceOf(subClassifier,MetaAdapterFactory.getConcept(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0xfc367070a5L,"jetbrains.mps.baseLanguage.structure.EnumClass"))) {
        for (        SNode enumConstant : ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(subClassifier,MetaAdapterFactory.getConcept(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0xfc367070a5L,"jetbrains.mps.baseLanguage.structure.EnumClass")),MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0xfc367070a5L,0xfc367503acL,"enumConstant")))) {
          superClassifierTooltip.append(TOOLTIP_INDENT);
          superClassifierTooltip.append(getEnumConstantPresentation(enumConstant));
        }
      }
    }
  }
  SetSequence.fromSet(messages).addElement(new SubclassedClassifierEditorMessage(container,this,superClassifierTooltip.toString(),isInterface));
  Map<String,Set<SNode>> nameToMethodsMap=MapSequence.fromMap(new HashMap<String,Set<SNode>>());
  for (  SNode method : Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>)((Class)Object.class),container,"jetbrains.mps.baseLanguage.structure.Classifier","call_methods_5292274854859311639",new Object[]{})).where(new IWhereFilter<SNode>(){
    public boolean accept(    SNode it){
      return OverridingMethodsFinder.canBeOverriden(it);
    }
  }
)) {
    SetSequence.fromSet(OverridingMethodsFinder.safeGet(nameToMethodsMap,SPropertyOperations.getString(method,MetaAdapterFactory.getProperty(0xceab519525ea4f22L,0x9b92103b95ca8c0cL,0x110396eaaa4L,0x110396ec041L,"name")))).addElement(method);
  }
  if (MapSequence.fromMap(nameToMethodsMap).isEmpty()) {
    return;
  }
  Map<SNode,Set<SNode>> overridenToOverridingMethodsMap=createOverridenToOverridingMethodsMap(nameToMethodsMap,derivedClassifiers);
  for (  SNode overridenMethod : SetSequence.fromSet(MapSequence.fromMap(overridenToOverridingMethodsMap).keySet())) {
    if (SPropertyOperations.getBoolean(overridenMethod,MetaAdapterFactory.getProperty(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0xf8cc56b1fcL,0x113294bffd2L,"isFinal"))) {
      continue;
    }
    boolean overriden=!(SPropertyOperations.getBoolean(overridenMethod,MetaAdapterFactory.getProperty(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0xf8cc56b21dL,0x1126a8d157dL,"isAbstract")));
    StringBuffer tooltip=new StringBuffer("Is ");
    tooltip.append((overriden ? "overriden" : "implemented"));
    tooltip.append(" in");
    int messageCounter=0;
    for (Iterator<SNode> it=SetSequence.fromSet(MapSequence.fromMap(overridenToOverridingMethodsMap).get(overridenMethod)).iterator(); it.hasNext(); ) {
      SNode overridingMethod=it.next();
      tooltip.append(TOOLTIP_INDENT);
      tooltip.append(getPresentation(SNodeOperations.getParent(overridingMethod)));
      if (++messageCounter == MAX_MESSAGE_NUMBER && it.hasNext()) {
        tooltip.append(TOOLTIP_INDENT);
        tooltip.append("...");
        break;
      }
    }
    SetSequence.fromSet(messages).addElement(new OverridenMethodEditorMessage(overridenMethod,this,tooltip.toString(),overriden));
  }
}
