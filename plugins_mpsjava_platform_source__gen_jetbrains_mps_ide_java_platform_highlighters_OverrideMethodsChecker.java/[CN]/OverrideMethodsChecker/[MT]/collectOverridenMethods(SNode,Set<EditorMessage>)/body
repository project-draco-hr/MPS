{
  List<SNode> derivedClassifiers=ClassifierSuccessors.getInstance().getDerivedClassifiers(container,GlobalScope.getInstance());
  if (ListSequence.fromList(derivedClassifiers).isEmpty()) {
    return;
  }
  boolean isInterface=SNodeOperations.isInstanceOf(container,"jetbrains.mps.baseLanguage.structure.Interface");
  StringBuffer superClassifierTooltip=new StringBuffer();
  if (ListSequence.fromList(derivedClassifiers).count() > MAX_MESSAGE_NUMBER) {
    superClassifierTooltip.append((isInterface ? "Has implementations" : "Has subclasses"));
  }
 else {
    superClassifierTooltip.append((isInterface ? "Is implemented by" : "Is subclassed by"));
    for (    SNode subClassifier : ListSequence.fromList(derivedClassifiers)) {
      superClassifierTooltip.append(TOOLTIP_INDENT);
      superClassifierTooltip.append(getClassifierPresentation(subClassifier));
      if (SNodeOperations.isInstanceOf(subClassifier,"jetbrains.mps.baseLanguage.structure.EnumClass")) {
        for (        SNode enumConstant : ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(subClassifier,"jetbrains.mps.baseLanguage.structure.EnumClass"),MetaAdapterFactory.getContainmentLink(new UUID(-935030926396207931l,-6610165693999523818l),1083245097125l,1083245396908l,"enumConstant")))) {
          superClassifierTooltip.append(TOOLTIP_INDENT);
          superClassifierTooltip.append(getEnumConstantPresentation(enumConstant));
        }
      }
    }
  }
  SetSequence.fromSet(messages).addElement(new SubclassedClassifierEditorMessage(container,this,superClassifierTooltip.toString(),isInterface));
  Map<String,Set<SNode>> nameToMethodsMap=MapSequence.fromMap(new HashMap<String,Set<SNode>>());
  for (  SNode method : Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>)((Class)Object.class),container,"jetbrains.mps.baseLanguage.structure.Classifier","call_methods_5292274854859311639",new Object[]{})).where(new IWhereFilter<SNode>(){
    public boolean accept(    SNode it){
      return OverridingMethodsFinder.canBeOverriden(it);
    }
  }
)) {
    SetSequence.fromSet(OverridingMethodsFinder.safeGet(nameToMethodsMap,SPropertyOperations.getString(method,MetaAdapterFactory.getProperty(new UUID(-3554657779850784990l,-7236703803128771572l),1169194658468l,1169194664001l,"name")))).addElement(method);
  }
  if (MapSequence.fromMap(nameToMethodsMap).isEmpty()) {
    return;
  }
  Map<SNode,Set<SNode>> overridenToOverridingMethodsMap=createOverridenToOverridingMethodsMap(nameToMethodsMap,derivedClassifiers);
  for (  SNode overridenMethod : SetSequence.fromSet(MapSequence.fromMap(overridenToOverridingMethodsMap).keySet())) {
    if (SPropertyOperations.getBoolean(overridenMethod,MetaAdapterFactory.getProperty(new UUID(-935030926396207931l,-6610165693999523818l),1068580123132l,1181808852946l,"isFinal"))) {
      continue;
    }
    boolean overriden=!(SPropertyOperations.getBoolean(overridenMethod,MetaAdapterFactory.getProperty(new UUID(-935030926396207931l,-6610165693999523818l),1068580123165l,1178608670077l,"isAbstract")));
    StringBuffer tooltip=new StringBuffer("Is ");
    tooltip.append((overriden ? "overriden" : "implemented"));
    tooltip.append(" in");
    int messageCounter=0;
    for (Iterator<SNode> it=SetSequence.fromSet(MapSequence.fromMap(overridenToOverridingMethodsMap).get(overridenMethod)).iterator(); it.hasNext(); ) {
      SNode overridingMethod=it.next();
      tooltip.append(TOOLTIP_INDENT);
      tooltip.append(getPresentation(SNodeOperations.getParent(overridingMethod)));
      if (++messageCounter == MAX_MESSAGE_NUMBER && it.hasNext()) {
        tooltip.append(TOOLTIP_INDENT);
        tooltip.append("...");
        break;
      }
    }
    SetSequence.fromSet(messages).addElement(new OverridenMethodEditorMessage(overridenMethod,this,tooltip.toString(),overriden));
  }
}
