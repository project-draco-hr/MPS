{
  super(mergeModelsDialog,"Merging " + rootName);
  myConflictChecker=new ChangeEditorMessage.ConflictChecker(){
    public boolean isChangeConflicted(    ModelChange ch){
      return Sequence.<ModelChange>fromIterable(myMergeContext.getConflictedWith(ch)).isNotEmpty();
    }
  }
;
  myModelsDialog=mergeModelsDialog;
  myMergeContext=mergeContext;
  myRootId=rootId;
  myStateToRestore=myMergeContext.getCurrentState();
  myMineEditor=addEditor(0,myMergeContext.getMyModel());
  myResultEditor=addEditor(1,myMergeContext.getResultModel());
  myRepositoryEditor=addEditor(2,myMergeContext.getRepositoryModel());
  linkEditors(true,false);
  linkEditors(false,false);
  linkEditors(true,true);
  linkEditors(false,true);
  myMergeContext.setChangesInvalidateHandler(new MergeContext.ChangesInvalidateHandler(){
    public void someChangesInvalidated(){
      ModelAccess.instance().runReadInEDT(new Runnable(){
        public void run(){
          rehighlight();
        }
      }
);
    }
  }
);
  JSplitPane splitPane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,myTopPanel,myBottomPanel);
  splitPane.setResizeWeight(0.7);
  MergeRootsDialog.MyGoToNeighbourRootActions neighbourActions=new MergeRootsDialog.MyGoToNeighbourRootActions();
  NextPreviousTraverser neighbourTraverser=new NextPreviousTraverser(myChangeGroupBuilders,myResultEditor.getMainEditor());
  DefaultActionGroup actionGroup=ActionUtils.groupFromActions(new ApplyNonConflictsForRoot(this),Separator.getInstance(),neighbourActions.previous(),neighbourActions.next(),Separator.getInstance(),neighbourTraverser.previousAction(),neighbourTraverser.nextAction());
  ActionToolbar toolbar=ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN,actionGroup,true);
  neighbourTraverser.setActionToolbar(toolbar);
  myContainer.add(toolbar.getComponent(),BorderLayout.NORTH);
  myContainer.add(splitPane,BorderLayout.CENTER);
  myContainer.add(this.myStatusBar,BorderLayout.SOUTH);
  highlightAllChanges();
}
