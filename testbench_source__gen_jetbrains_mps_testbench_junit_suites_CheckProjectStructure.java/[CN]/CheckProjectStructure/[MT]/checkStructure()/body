{
  final List<String> errors=new ArrayList<String>();
  ModelAccess.instance().runReadAction(new Runnable(){
    public void run(){
      for (      SModel sm : extractModels(true)) {
        MessageCollectProcessor collector=new MessageCollectProcessor(false){
          @Override protected String formatMessage(          ValidationProblem problem){
            String err=super.formatMessage(problem);
            if (!((problem instanceof NodeValidationProblem))) {
              return err;
            }
            return err + " in node " + ((NodeValidationProblem)problem).getNode().getNodeId();
          }
        }
;
        ValidationUtil.validateModelContent(sm.getRootNodes(),new TemplatesModelProcessorDecorator(sm,collector));
        if (collector.getErrors().isEmpty()) {
          continue;
        }
        final StringBuilder errorMessages=new StringBuilder();
        errorMessages.append("errors in model: ").append(sm.getReference().toString()).append("\n");
        ListSequence.fromList(((List<String>)collector.getErrors())).visitAll(new IVisitor<String>(){
          public void visit(          String it){
            errorMessages.append("\t").append(it).append("\n");
          }
        }
);
        errors.add(errorMessages.toString());
      }
    }
  }
);
  Assert.assertTrue("Structure errors:\n" + CheckingTestsUtil.formatErrors(errors),errors.isEmpty());
}
