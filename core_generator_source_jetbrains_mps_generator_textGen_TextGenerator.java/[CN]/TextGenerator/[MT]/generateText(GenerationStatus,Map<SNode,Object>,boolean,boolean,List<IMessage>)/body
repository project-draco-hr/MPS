{
  boolean hasErrors=false;
  ModelDependencies dependRoot=new ModelDependencies();
  status.setBLDependencies(dependRoot);
  SModel outputModel=status.getOutputModel();
  if (outputModel == null)   return !hasErrors;
  DebugInfoBuilder debugInfoBuilder=null;
  if (generateDebugInfo) {
    debugInfoBuilder=new DebugInfoBuilder();
    status.setDebugInfo(debugInfoBuilder.getDebugInfo());
  }
  StringBuilder[] buffers=new StringBuilder[]{new StringBuilder(8192),new StringBuilder(32768)};
  for (  SNode outputNode : outputModel.roots()) {
    buffers[0].setLength(0);
    buffers[1].setLength(0);
    if (buffers[0].capacity() > 100000) {
      buffers[0]=new StringBuilder(8192);
    }
    if (buffers[1].capacity() > 200000) {
      buffers[1]=new StringBuilder(32768);
    }
    TextGenerationResult result=TextGen.generateText(outputNode,failIfNoTextgen,generateDebugInfo,buffers);
    if (hasErrors && result.problems().isEmpty()) {
      throw new IllegalStateException();
    }
    hasErrors|=result.hasErrors();
    if (result.hasErrors()) {
      errors.addAll(result.problems());
    }
 else {
      Object contents=result.getResult();
      if (TextGen.NO_TEXTGEN != contents) {
        String fileName=getFileName(outputNode);
        if (debugInfoBuilder != null) {
          debugInfoBuilder.fillDebugInfo(fileName,result.getPositions(),result.getScopePositions(),result.getUnitPositions(),status.getOriginalInputModel());
        }
        fillDependencies(dependRoot,outputNode,fileName,result);
        outputNodeContents.put(outputNode,contents);
      }
 else {
      }
    }
  }
  return !hasErrors;
}
