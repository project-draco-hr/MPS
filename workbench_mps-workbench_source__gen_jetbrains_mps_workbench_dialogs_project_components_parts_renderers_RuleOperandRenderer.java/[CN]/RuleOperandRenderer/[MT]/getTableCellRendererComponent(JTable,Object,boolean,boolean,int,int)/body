{
  if (MapSequence.fromMap(myRenderersCache).containsKey(value)) {
    return MapSequence.fromMap(myRenderersCache).get(value);
  }
  final boolean[] incomplete=new boolean[]{false};
  MPSTree tree=new MPSTree(){
    @Override protected MPSTreeNode rebuild(){
      TextMPSTreeNode root=new TextMPSTreeNode("",null);
      incomplete[0]=!(RuleOperandRenderer.this.add(root,(MappingConfig_AbstractRef)value));
      return root;
    }
  }
;
  tree.setRootVisible(false);
  tree.rebuildNow();
  tree.expandAll();
  if (isSelected && !(hasFocus)) {
    tree.setForeground(table.getSelectionForeground());
    tree.setBackground(table.getSelectionBackground());
    tree.clearSelection();
    tree.setCellRenderer(new NewMPSTreeCellRenderer(){
      @Override public Component getTreeCellRendererComponent(      JTree tree,      Object value,      boolean selected,      boolean expanded,      boolean leaf,      int row,      boolean hasFocus){
        return super.getTreeCellRendererComponent(tree,value,true,expanded,leaf,row,hasFocus);
      }
    }
);
  }
 else {
    tree.setBackground((incomplete[0] ? Color.PINK : table.getBackground()));
    tree.setForeground(table.getForeground());
    tree.setCellRenderer(new DefaultTreeCellRenderer(){
      @Override public Component getTreeCellRendererComponent(      JTree tree,      Object value,      boolean selected,      boolean expanded,      boolean leaf,      int row,      boolean hasFocus){
        setBackgroundNonSelectionColor(tree.getBackground());
        return super.getTreeCellRendererComponent(tree,value,selected,expanded,leaf,row,hasFocus);
      }
    }
);
    tree.clearSelection();
  }
  tree.setBorder((hasFocus ? new DottedBorder(new Insets(1,1,1,1),Color.BLACK) : new EmptyBorder(1,1,1,1)));
  MapSequence.fromMap(myRenderersCache).put(value,tree);
  return tree;
}
