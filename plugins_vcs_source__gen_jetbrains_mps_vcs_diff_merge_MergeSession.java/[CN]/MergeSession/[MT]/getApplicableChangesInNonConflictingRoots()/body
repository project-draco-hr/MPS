{
  return Sequence.fromIterable((Sequence.fromIterable(MapSequence.fromMap(myRootToChanges).values()).concat(ListSequence.fromList(Arrays.asList(myMetadataChanges))))).translate(new ITranslator2<List<ModelChange>,ModelChange>(){
    public Iterable<ModelChange> translate(    List<ModelChange> changes){
      Iterable<ModelChange> unresolvedForRoot=ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>(){
        public boolean accept(        ModelChange ch){
          return !(SetSequence.fromSet(myResolvedChanges).contains(ch));
        }
      }
);
      if (Sequence.fromIterable(unresolvedForRoot).all(new IWhereFilter<ModelChange>(){
        public boolean accept(        ModelChange ch){
          return Sequence.fromIterable(getConflictedWith(ch)).isEmpty();
        }
      }
)) {
        return unresolvedForRoot;
      }
 else {
        return Sequence.fromIterable(Collections.<ModelChange>emptyList());
      }
    }
  }
);
}
