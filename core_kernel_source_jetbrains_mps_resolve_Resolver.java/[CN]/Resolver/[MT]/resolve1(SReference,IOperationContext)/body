{
  SNode referenceNode=reference.getSourceNode();
  ConceptDeclaration referenceNodeConcept=(ConceptDeclaration)referenceNode.getConceptDeclarationAdapter();
  LinkDeclaration linkDeclaration=SModelUtil_new.findLinkDeclaration(referenceNodeConcept,reference.getRole());
  final AbstractConceptDeclaration referentConcept=linkDeclaration.getTarget();
  SNode sNode=referenceNode.getParent();
  if (sNode == null)   sNode=referenceNode;
  SNode containingRoot=sNode.getContainingRoot();
  NodeTypesComponent nodeTypesComponent=NodeTypesComponentsRepository.getInstance().createNodeTypesComponent(containingRoot);
  NodeTypesComponent temporaryComponent;
  try {
    temporaryComponent=nodeTypesComponent.clone();
  }
 catch (  CloneNotSupportedException ex) {
    LOG.error(ex);
    return false;
  }
  TypeChecker.getInstance().setCurrentTypesComponent(temporaryComponent);
  temporaryComponent.computeOnlyTypesForNode(sNode);
  temporaryComponent.solveInequationsAndExpandTypes();
  TypeChecker.getInstance().clearCurrentTypesComponent();
  NodeTypesComponentsRepository.getInstance().swapTypesComponentForRoot(containingRoot,temporaryComponent);
  try {
    SearchScopeStatus status=ModelConstraintsUtil.getSearchScope(referenceNode.getParent(),referenceNode,referenceNodeConcept,linkDeclaration,operationContext);
    if (status.isError()) {
      LOG.error("Couldn't create referent search scope : " + status.getMessage());
      return false;
    }
    ISearchScope searchScope=status.getSearchScope();
    List<SNode> nodes=searchScope.getNodes(new Condition<SNode>(){
      public boolean met(      SNode node){
        return node.isInstanceOfConcept(referentConcept);
      }
    }
);
    Condition<SNode> nameMatchesCondition=new Condition<SNode>(){
      public boolean met(      SNode object){
        return reference.getResolveInfo().equals(object.getName());
      }
    }
;
    List<SNode> filtered=CollectionUtil.filter(nodes,nameMatchesCondition);
    if (!filtered.isEmpty()) {
      reference.getSourceNode().setReferent(reference.getRole(),filtered.get(0));
      return true;
    }
    if (referenceNode.getParent() == null) {
      return false;
    }
    SNode parent=referenceNode.getParent();
    LinkDeclaration parentLinkDeclaration=SModelUtil_new.findLinkDeclaration(parent.getConceptDeclarationAdapter(),referenceNode.getRole_());
    if (parentLinkDeclaration == null) {
      return false;
    }
    final AbstractConceptDeclaration possibleChildConceptDeclaration=parentLinkDeclaration.getTarget();
    ISearchScope conceptsSearchScope=SModelSearchUtil_new.createConceptsFromModelLanguagesScope(parent.getModel(),true,operationContext.getScope());
    List<SNode> applicableConcepts=conceptsSearchScope.getNodes(new Condition<SNode>(){
      public boolean met(      SNode object){
        return SModelUtil_new.isAssignableConcept((ConceptDeclaration)BaseAdapter.fromNode(object),possibleChildConceptDeclaration);
      }
    }
);
    for (    SNode node : applicableConcepts) {
      ConceptDeclaration applicableConcept=(ConceptDeclaration)BaseAdapter.fromNode(node);
      LinkDeclaration smartReference=ReferenceConceptUtil.getCharacteristicReference(applicableConcept);
      if (smartReference == null)       continue;
      List<SNode> smartReferenceTargets=getSmartReferenceTargets(applicableConcept,smartReference,parent,operationContext);
      List<SNode> filteredRefTargets=CollectionUtil.filter(smartReferenceTargets,nameMatchesCondition);
      if (!filteredRefTargets.isEmpty()) {
        SNode target=filteredRefTargets.get(0);
        SNode newNode=SModelUtil_new.instantiateConceptDeclaration(applicableConcept,referenceNode.getModel()).getNode();
        newNode.setReferent(SModelUtil_new.getGenuineLinkRole(smartReference),target);
        parent.replaceChild(referenceNode,newNode);
        return true;
      }
    }
    return false;
  }
  finally {
    NodeTypesComponentsRepository.getInstance().swapTypesComponentForRoot(containingRoot,nodeTypesComponent);
  }
}
