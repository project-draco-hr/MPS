{
  List<SNode> visitedClassifiers=new ArrayList<SNode>();
  LinkedList<SNode> concretes=new LinkedList<SNode>();
  concretes.addLast(concrete);
  SNode resType=type;
  while (!(concretes.isEmpty())) {
    SNode ct=concretes.removeFirst();
    if (visitedClassifiers.contains(SLinkOperations.getTarget(ct,"classifier",false)) || SLinkOperations.getCount(ct,"parameter") == 0) {
      continue;
    }
    visitedClassifiers.add(SLinkOperations.getTarget(ct,"classifier",false));
    for (    SNode sup : TypeChecker.getInstance().getSubtypingManager().collectImmediateSupertypes(ct)) {
{
        IMatchingPattern pattern_=HUtil.createMatchingPatternByConceptFQName("jetbrains.mps.baseLanguage.structure.ClassifierType");
        SNode coercedNode_=TypeChecker.getInstance().getRuntimeSupport().coerce(sup,pattern_);
        if (coercedNode_ != null) {
          concretes.addLast(coercedNode_);
        }
      }
    }
    resType=resolveType(resType,ct);
    if (((List)SNodeOperations.getDescendants(resType,"jetbrains.mps.baseLanguage.structure.TypeVariableReference",false)).isEmpty()) {
      break;
    }
  }
  return resType;
}
