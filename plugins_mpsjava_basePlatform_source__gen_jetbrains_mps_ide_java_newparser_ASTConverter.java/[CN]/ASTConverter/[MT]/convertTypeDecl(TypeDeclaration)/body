{
  SNode cls;
  final Map<SNode,Integer> memberStartPositions=MapSequence.fromMap(new HashMap<SNode,Integer>());
  SNode defaultConstructor=null;
  boolean isAnonymous=x.allocation != null;
  if (isAnonymous) {
    cls=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.AnonymousClass",null);
  }
 else {
switch (TypeDeclaration.kind(x.modifiers)) {
case TypeDeclaration.CLASS_DECL:
      cls=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassConcept",null);
    break;
case TypeDeclaration.INTERFACE_DECL:
  cls=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.Interface",null);
break;
case TypeDeclaration.ENUM_DECL:
cls=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EnumClass",null);
break;
case TypeDeclaration.ANNOTATION_TYPE_DECL:
cls=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.Annotation",null);
break;
default :
throw new JavaParseException("Unknown type declaration type");
}
}
ASTConverter prefixedConverter=this;
if (!(isAnonymous)) {
SPropertyOperations.set(cls,"name",new String(x.name));
SLinkOperations.setTarget(cls,"visibility",convertVisibility(x.modifiers),true);
if (!(SNodeOperations.isInstanceOf(cls,"jetbrains.mps.baseLanguage.structure.Interface")) && flagSet(x.modifiers,ClassFileConstants.AccStatic)) {
SPropertyOperations.set(cls,"nonStatic","" + (false));
}
if (myOnlyStubs) {
String nodeId=getState().getIdPrefix() + SPropertyOperations.getString(cls,"name");
cls.setId(new SNodeId.Foreign(nodeId));
prefixedConverter=this.withIdPrefix(nodeId + ".");
}
}
ASTConverter childConverter=prefixedConverter;
childConverter=childConverter.convertTypeVars(x.typeParameters,cls);
if (x.memberTypes != null) {
for (TypeDeclaration innerTyp : x.memberTypes) {
myTypeResolver.addTypeName(new String(innerTyp.name));
}
for (TypeDeclaration innerTyp : x.memberTypes) {
myTypeResolver.enterType(new String(innerTyp.name));
try {
SNode nested=childConverter.convertTypeDecl(innerTyp);
SLinkOperations.getTargets(cls,"member",true).add(nested);
MapSequence.fromMap(memberStartPositions).put(nested,innerTyp.sourceStart);
}
  finally {
myTypeResolver.leaveType();
}
}
}
childConverter.convertAnnotations(x.annotations,cls);
{
SNode claz=cls;
if (SNodeOperations.isInstanceOf(claz,"jetbrains.mps.baseLanguage.structure.ClassConcept")) {
SLinkOperations.setTarget(claz,"superclass",SNodeOperations.cast(convertTypeReference(x.superclass),"jetbrains.mps.baseLanguage.structure.ClassifierType"),true);
if (x.superInterfaces != null) {
for (TypeReference i : x.superInterfaces) {
ListSequence.fromList(SLinkOperations.getTargets(claz,"implementedInterface",true)).addElement(SNodeOperations.cast(convertTypeReference(i),"jetbrains.mps.baseLanguage.structure.ClassifierType"));
}
}
SPropertyOperations.set(claz,"abstractClass","" + (flagSet(x.modifiers,ClassFileConstants.AccAbstract)));
SPropertyOperations.set(claz,"isFinal","" + (flagSet(x.modifiers,ClassFileConstants.AccFinal)));
}
}
{
SNode iface=cls;
if (SNodeOperations.isInstanceOf(iface,"jetbrains.mps.baseLanguage.structure.Interface")) {
if (x.superInterfaces != null) {
for (TypeReference i : x.superInterfaces) {
ListSequence.fromList(SLinkOperations.getTargets(iface,"extendedInterface",true)).addElement(SNodeOperations.cast(convertTypeReference(i),"jetbrains.mps.baseLanguage.structure.ClassifierType"));
}
}
}
}
{
SNode enm=cls;
if (SNodeOperations.isInstanceOf(enm,"jetbrains.mps.baseLanguage.structure.EnumClass")) {
if (x.fields != null) {
for (FieldDeclaration f : x.fields) {
if (!(isEnumConstant(f))) {
continue;
}
SNode constr=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ConstructorDeclaration",null);
SNode item=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration",null);
SPropertyOperations.set(item,"name",enumConstantName(f));
SLinkOperations.getTargets(enm,"enumConstant",true).add(item);
}
}
}
}
if (x.fields != null) {
for (FieldDeclaration f : x.fields) {
SNode mem=childConverter.convertField(cls,f,true);
MapSequence.fromMap(memberStartPositions).put(SNodeOperations.cast(mem,"jetbrains.mps.baseLanguage.structure.ClassifierMember"),f.sourceStart);
}
}
if (x.methods != null) {
for (AbstractMethodDeclaration method : x.methods) {
SNode mem=childConverter.convertMethod(cls,method,true);
MapSequence.fromMap(memberStartPositions).put(SNodeOperations.cast(mem,"jetbrains.mps.baseLanguage.structure.ClassifierMember"),method.sourceStart);
if (method instanceof ConstructorDeclaration && method.isDefaultConstructor()) {
defaultConstructor=SNodeOperations.cast(mem,"jetbrains.mps.baseLanguage.structure.ClassifierMember");
}
}
}
if (x.javadoc != null) {
AttributeOperations.createAndSetAttrbiute(cls,new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.javadoc.structure.ClassifierDocComment")),"jetbrains.mps.baseLanguage.javadoc.structure.ClassifierDocComment");
MapSequence.fromMap(myJavadocs).put(x.javadoc.sourceStart,AttributeOperations.getAttribute(cls,new IAttributeDescriptor.NodeAttribute(SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.javadoc.structure.ClassifierDocComment"))));
}
List<SNode> sortedMembers=ListSequence.fromList(SLinkOperations.getTargets(cls,"member",true)).sort(new ISelector<SNode,Integer>(){
public Integer select(SNode it){
return MapSequence.fromMap(memberStartPositions).get(it);
}
}
,true).toListSequence();
if ((defaultConstructor != null)) {
ListSequence.fromList(sortedMembers).removeElement(defaultConstructor);
int firstNonField=0;
{
Iterator<SNode> m_it=ListSequence.fromList(sortedMembers).iterator();
SNode m_var;
while (m_it.hasNext()) {
m_var=m_it.next();
if (!(SNodeOperations.isInstanceOf(m_var,"jetbrains.mps.baseLanguage.structure.VariableDeclaration"))) {
break;
}
firstNonField++;
}
}
ListSequence.fromList(sortedMembers).insertElement(firstNonField,defaultConstructor);
}
ListSequence.fromList(SLinkOperations.getTargets(cls,"member",true)).clear();
ListSequence.fromList(SLinkOperations.getTargets(cls,"member",true)).addSequence(ListSequence.fromList(sortedMembers));
return cls;
}
