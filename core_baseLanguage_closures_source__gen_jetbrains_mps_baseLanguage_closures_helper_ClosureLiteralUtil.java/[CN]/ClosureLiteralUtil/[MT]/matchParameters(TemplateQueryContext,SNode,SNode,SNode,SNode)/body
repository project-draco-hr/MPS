{
  Map<SNode,SNode> map=null;
  List<SNode> imds=SLinkOperations.getTargets(SLinkOperations.getTarget(ctNoParams,"classifier",false),"method",true);
  SNode absRetCT=null;
  List<SNode> meths=ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(ctNoParams,"classifier",false),"method",true)).where(new IWhereFilter<SNode>(){
    public boolean accept(    SNode m){
      return !("equals".equals(SPropertyOperations.getString(m,"name"))) && SPropertyOperations.getBoolean(m,"isAbstract");
    }
  }
).toListSequence();
  if (ListSequence.fromList(meths).count() > 0) {
    if (ListSequence.fromList(meths).count() > 1) {
      genContext.showWarningMessage(literal,"The adaptation target interface has more than one method");
    }
    SNode method=ListSequence.fromList(imds).getElement(0);
    if ((SLinkOperations.getTarget(method,"returnType",true) != null) && !(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(method,"returnType",true),"jetbrains.mps.baseLanguage.structure.VoidType"))) {
      map=matchReturnType(SLinkOperations.getTarget(method,"returnType",true),FunctionType_Behavior.call_getNormalizedReturnType_1213877405252(ft),map);
      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(method,"returnType",true),"jetbrains.mps.baseLanguage.structure.ClassifierType")) {
        absRetCT=SNodeOperations.copyNode(SNodeOperations.cast(SLinkOperations.getTarget(method,"returnType",true),"jetbrains.mps.baseLanguage.structure.ClassifierType"));
      }
    }
    List<SNode> ptypes=FunctionType_Behavior.call_getNormalizedParameterTypes_1213877405276(ft);
    int idx=0;
    for (    SNode pd : SLinkOperations.getTargets(method,"parameter",true)) {
      if (idx >= ListSequence.fromList(ptypes).count()) {
        genContext.showErrorMessage(literal,"Closure parameters count doesn't match method '" + SPropertyOperations.getString(method,"name") + "' in "+ JavaNameUtil.fqClassName(SLinkOperations.getTarget(ctNoParams,"classifier",false),SPropertyOperations.getString(SLinkOperations.getTarget(ctNoParams,"classifier",false),"name")));
        return;
      }
      map=matchType(SLinkOperations.getTarget(pd,"type",true),ListSequence.fromList(ptypes).getElement(idx),map);
      idx++;
    }
{
      int tidx=0;
      List<SNode> fttypes=FunctionType_Behavior.call_getNormalizedThrowsTypes_3448422702164385781(ft);
      List<SNode> mttypes=FunctionTypeUtil.normalizeThrowsTypes(SLinkOperations.getTargets(method,"throwsItem",true));
      for (      SNode mtt : mttypes) {
        if (tidx < ListSequence.fromList(fttypes).count()) {
          map=matchType(mtt,ListSequence.fromList(fttypes).getElement(tidx),map);
          tidx++;
        }
 else {
          for (          SNode mttt : mttypes) {
            SNode tvd=SLinkOperations.getTarget(SNodeOperations.as(mttt,"jetbrains.mps.baseLanguage.structure.TypeVariableReference"),"typeVariableDeclaration",false);
            if (tvd != null && (map == null || !(MapSequence.fromMap(map).containsKey(tvd)))) {
              genContext.showErrorMessage(literal,"Closure generic throws types count doesn't match method '" + SPropertyOperations.getString(method,"name") + "' in "+ JavaNameUtil.fqClassName(SLinkOperations.getTarget(ctNoParams,"classifier",false),SPropertyOperations.getString(SLinkOperations.getTarget(ctNoParams,"classifier",false),"name")));
              return;
            }
          }
          break;
        }
      }
    }
  }
  Values.TYPE_MAP.set(genContext,ctNoParams,map);
  if ((absRetCT != null)) {
    SNode ftResCT=FunctionTypeUtil.unmeet(FunctionType_Behavior.call_getNormalizedReturnType_1213877405252(ft));
    String adapterName=JavaNameUtil.shortName(SPropertyOperations.getString(SLinkOperations.getTarget(absRetCT,"classifier",false),"name")) + JavaNameUtil.shortName(SPropertyOperations.getString(SLinkOperations.getTarget(SNodeOperations.as(FunctionTypeUtil.unbound(ftResCT),"jetbrains.mps.baseLanguage.structure.ClassifierType"),"classifier",false),"name")) + "Adapter";
    for (    SNode cls : SModelOperations.getNodes(SNodeOperations.getModel(SLinkOperations.getTarget(absRetCT,"classifier",false)),"jetbrains.mps.baseLanguage.structure.Classifier")) {
      if (adapterName.equals(JavaNameUtil.shortName(SPropertyOperations.getString(cls,"name")))) {
        SNode newRetCT=SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.ClassifierType",null);
        SLinkOperations.setTarget(newRetCT,"classifier",cls,false);
        Values.RETURN_TYPE.set(genContext,ctNoParams,newRetCT);
        break;
      }
    }
  }
  List<SNode> varDecls=SLinkOperations.getTargets(SLinkOperations.getTarget(origCT,"classifier",false),"typeVariableDeclaration",true);
  int idx=0;
  for (  SNode p : SLinkOperations.getTargets(origCT,"parameter",true)) {
    List<SNode> queue=ListSequence.fromListAndArray(new LinkedList<SNode>(),ListSequence.fromList(SLinkOperations.getTargets(ctNoParams,"parameter",true)).addElement(SNodeOperations.copyNode(p)));
    while (!(ListSequence.fromList(queue).isEmpty())) {
      SNode n=ListSequence.fromList(queue).removeElementAt(0);
      if (SNodeOperations.isInstanceOf(n,"jetbrains.mps.baseLanguage.structure.TypeVariableReference")) {
        if (idx < ListSequence.fromList(varDecls).count() && map != null && MapSequence.fromMap(map).containsKey(ListSequence.fromList(varDecls).getElement(idx))) {
          n=SNodeOperations.replaceWithAnother(n,(map != null ? MapSequence.fromMap(map).get(ListSequence.fromList(varDecls).getElement(idx)) : null));
        }
      }
 else {
        if (n != null && (SNodeOperations.isInstanceOf(n,"jetbrains.mps.baseLanguage.structure.UpperBoundType") || SNodeOperations.isInstanceOf(n,"jetbrains.mps.baseLanguage.structure.LowerBoundType"))) {
          ListSequence.fromList(queue).addSequence(ListSequence.fromList(SNodeOperations.getChildren(n)));
        }
      }
    }
    idx++;
  }
}
