{
  myMinorStep=-1;
  List<TemplateMappingConfiguration> mappingConfigurations=new ArrayList<TemplateMappingConfiguration>(myGenerationPlan.getMappingConfigurations(myMajorStep));
  if (mappingConfigurations.isEmpty()) {
    if (inputModel.rootsCount() > 0) {
      myLogger.warning("skip model \"" + inputModel.getSModelFqName() + "\" : no generator available");
    }
    return inputModel;
  }
  if (myGenerationTracer.isTracing() && myLogger.needsInfo()) {
    printGenerationStepData(inputModel);
  }
  mySessionContext=new GenerationSessionContext(myInvocationContext,myGenerationTracer,myTransientModelsModule,inputModel,myGenerationPlan,mySessionContext);
  myLogger.setOperationContext(mySessionContext);
  Iterator<TemplateMappingConfiguration> it=mappingConfigurations.iterator();
  TemplateGenerator templateGenerator=new TemplateGenerator(mySessionContext,myProgressMonitor,myLogger,null,inputModel,null,myGenerationOptions,myDependenciesBuilder,ttrace);
  while (it.hasNext()) {
    TemplateMappingConfiguration c=it.next();
    try {
      if (!c.isApplicable(templateGenerator)) {
        it.remove();
      }
    }
 catch (    GenerationException e) {
      if (!(e instanceof GenerationFailureException)) {
        throw new GenerationFailureException("mapping configuration's isApplicable block threw an exception",null,e);
      }
      throw (GenerationFailureException)e;
    }
  }
  if (mappingConfigurations.isEmpty()) {
    return inputModel;
  }
  RuleManager ruleManager=new RuleManager(myGenerationPlan,mappingConfigurations);
  SModel outputModel=executeMajorStepInternal(inputModel,ruleManager);
  if (myLogger.getErrorCount() > 0) {
    myLogger.warning("model \"" + inputModel.getSModelFqName() + "\" has been generated with errors");
  }
  return outputModel;
}
