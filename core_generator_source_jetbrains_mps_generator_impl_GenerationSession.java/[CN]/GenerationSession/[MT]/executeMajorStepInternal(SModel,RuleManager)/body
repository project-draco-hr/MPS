{
  SModel currentInputModel=inputModel;
  IGenerationTracer tracer=mySessionContext.getGenerationTracer();
  ttrace.push("pre-processing",false);
  currentInputModel=preProcessModel(ruleManager,currentInputModel);
  ttrace.pop();
  SModel currentOutputModel=createTransientModel();
  tracer.startTracing(currentInputModel,currentOutputModel);
  if (myLogger.needsInfo()) {
    myLogger.info("generating model '" + currentInputModel.getSModelReference().getSModelFqName() + "' --> '"+ currentOutputModel.getSModelReference().getSModelFqName()+ "'");
  }
  boolean somethingHasBeenGenerated=applyRules(currentInputModel,currentOutputModel,true,ruleManager);
  if (!somethingHasBeenGenerated) {
    SModelOperations.validateLanguagesAndImports(currentOutputModel,false,false);
    myDependenciesBuilder.updateModel(currentOutputModel);
    recycleWasteModel(currentInputModel);
    return currentOutputModel;
  }
  int secondaryMappingRepeatCount=1;
  while (true) {
    SModelOperations.validateLanguagesAndImports(currentOutputModel,false,false);
    myDependenciesBuilder.updateModel(currentOutputModel);
    mySessionContext.clearTransientObjects();
    recycleWasteModel(currentInputModel);
    currentInputModel=currentOutputModel;
    currentInputModel.disposeFastNodeFinder();
    SModel transientModel=createTransientModel();
    if (myLogger.needsInfo()) {
      myLogger.info("next minor step '" + currentInputModel.getSModelReference().getSModelFqName().getStereotype() + "' --> '"+ transientModel.getSModelReference().getSModelFqName().getStereotype()+ "'");
    }
    tracer.startTracing(currentInputModel,transientModel);
    if (!applyRules(currentInputModel,transientModel,false,ruleManager)) {
      myDependenciesBuilder.dropModel();
      tracer.discardTracing(currentInputModel,transientModel);
      mySessionContext.getModule().removeModel(transientModel.getModelDescriptor());
      myMinorStep--;
      if (myLogger.needsInfo()) {
        myLogger.info("unchanged, empty model '" + transientModel.getSModelReference().getSModelFqName().getStereotype() + "' removed");
      }
      break;
    }
    if (++secondaryMappingRepeatCount > 10) {
      myLogger.error("failed to generate output after 10 repeated mappings");
      if (tracer.isTracing()) {
        myLogger.error("last rules applied:");
        List<Pair<SNode,SNode>> pairs=tracer.getAllAppiedRulesWithInputNodes(transientModel.getSModelReference());
        for (        Pair<SNode,SNode> pair : pairs) {
          myLogger.error(pair.o1,"rule: " + SNodeUtil.getDebugText(pair.o1),GeneratorUtil.describe(pair.o2,"input"));
        }
      }
 else {
        myLogger.error("to get more diagnostic generate model with the 'save transient models' option");
      }
      myLogger.error("failed to generate output after 10 repeated mappings");
      throw new GenerationFailureException();
    }
    currentOutputModel=transientModel;
  }
  ttrace.push("post-processing",false);
  currentOutputModel=postProcessModel(ruleManager,currentOutputModel);
  ttrace.pop();
  return currentOutputModel;
}
