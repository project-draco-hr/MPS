{
  SModel currentInputModel=inputModel;
  IGenerationTracer tracer=mySessionContext.getGenerationTracer();
  ttrace.push("pre-processing",false);
  currentInputModel=preProcessModel(ruleManager,currentInputModel);
  ttrace.pop();
  SModel currentOutputModel=createTransientModel();
  tracer.startTracing(currentInputModel,currentOutputModel);
  if (myLogger.needsInfo()) {
    myLogger.info("generating model '" + currentInputModel.getReference().getModelName() + "' --> '"+ currentOutputModel.getReference().getModelName()+ "'");
  }
  boolean somethingHasBeenGenerated=applyRules(currentInputModel,currentOutputModel,true,ruleManager).o1;
  if (!somethingHasBeenGenerated) {
    SModelOperations.validateLanguagesAndImports(currentOutputModel,false,false);
    myDependenciesBuilder.updateModel(currentOutputModel);
    recycleWasteModel(currentInputModel);
    return currentOutputModel;
  }
  int secondaryMappingRepeatCount=1;
  while (true) {
    SModelOperations.validateLanguagesAndImports(currentOutputModel,false,false);
    myDependenciesBuilder.updateModel(currentOutputModel);
    mySessionContext.clearTransientObjects();
    if (currentInputModel != currentOutputModel) {
      recycleWasteModel(currentInputModel);
    }
    currentInputModel=currentOutputModel;
    ((jetbrains.mps.smodel.SModelInternal)currentInputModel).disposeFastNodeFinder();
    SModel transientModel=createTransientModel();
    if (myLogger.needsInfo()) {
      myLogger.info("next minor step '" + SModelStereotype.getStereotype(currentInputModel.getReference().getModelName()) + "' --> '"+ SModelStereotype.getStereotype(transientModel.getReference().getModelName())+ "'");
    }
    tracer.startTracing(currentInputModel,transientModel);
    final Pair<Boolean,SModel> applied=applyRules(currentInputModel,transientModel,false,ruleManager);
    if (!applied.o1) {
      myDependenciesBuilder.dropModel();
      tracer.discardTracing(currentInputModel,transientModel);
      mySessionContext.getModule().removeModel(transientModel);
      myMinorStep--;
      if (myLogger.needsInfo()) {
        myLogger.info("unchanged, empty model '" + SModelStereotype.getStereotype(transientModel.getReference().getModelName()) + "' removed");
      }
      break;
    }
    SModel realOutputModel=applied.o2;
    if (++secondaryMappingRepeatCount > 10) {
      myLogger.error("failed to generate output after 10 repeated mappings");
      if (tracer.isTracing()) {
        myLogger.error("last rules applied:");
        List<Pair<SNode,SNode>> pairs=tracer.getAllAppiedRulesWithInputNodes(realOutputModel.getReference());
        for (        Pair<SNode,SNode> pair : pairs) {
          myLogger.error(pair.o1,"rule: " + SNodeUtil.getDebugText(pair.o1),GeneratorUtil.describe(pair.o2,"input"));
        }
      }
 else {
        myLogger.error("to get more diagnostic generate model with the 'save transient models' option");
      }
      myLogger.error("failed to generate output after 10 repeated mappings");
      throw new GenerationFailureException();
    }
    currentOutputModel=realOutputModel;
  }
  ttrace.push("post-processing",false);
  currentOutputModel=postProcessModel(ruleManager,currentOutputModel);
  ttrace.pop();
  return currentOutputModel;
}
