{
  if (!ruleManager.getScripts().preprocessing()) {
    return currentInputModel;
  }
  final boolean needToCloneInputModel=ruleManager.getScripts().needModelCloneToPreprocess(currentInputModel,!myDiscardTransients);
  SModel toRecycle=null;
  if (needToCloneInputModel) {
    ttrace.push("model clone",false);
    SModel currentInputModel_clone=createTransientModel();
    if (myLogger.needsInfo()) {
      myLogger.info("clone model '" + currentInputModel.getReference().getModelName() + "' --> '"+ currentInputModel_clone.getReference().getModelName()+ "'");
    }
    CloneUtil.cloneModelWithImports(currentInputModel,currentInputModel_clone,currentInputModel == mySessionContext.getOriginalInputModel());
    ttrace.pop();
    mySessionContext.getGenerationTracer().registerPreMappingScripts(currentInputModel,currentInputModel_clone,ruleManager.getScripts().getPreMappingScripts());
    toRecycle=currentInputModel;
    currentInputModel=currentInputModel_clone;
    myDependenciesBuilder.scriptApplied(currentInputModel);
  }
 else {
    mySessionContext.getGenerationTracer().registerPreMappingScripts(currentInputModel,currentInputModel,ruleManager.getScripts().getPreMappingScripts());
  }
  boolean preProcessed=false;
  TemplateGenerator templateGenerator=new TemplateGenerator(mySessionContext,myProgressMonitor,myLogger,ruleManager,currentInputModel,currentInputModel,myGenerationOptions,myDependenciesBuilder,ttrace);
  for (  TemplateMappingScript preMappingScript : ruleManager.getScripts().getPreMappingScripts()) {
    if (myLogger.needsInfo()) {
      myLogger.info(preMappingScript.getScriptNode().resolve(MPSModuleRepository.getInstance()),"pre-process " + preMappingScript.getLongName());
    }
    templateGenerator.executeScript(preMappingScript);
    preProcessed=true;
  }
  if (needToCloneInputModel) {
    myDependenciesBuilder.scriptApplied(currentInputModel);
    if (myNewCache != null) {
      TransientModelWithMetainfo modelWithMetaInfo=TransientModelWithMetainfo.create(currentInputModel,myDependenciesBuilder);
      myNewCache.store(myMajorStep,myMinorStep,modelWithMetaInfo);
    }
    recycleWasteModel(toRecycle);
  }
  if (myLogger.needsInfo() && preProcessed) {
    myLogger.info("pre-processing finished");
  }
  return currentInputModel;
}
