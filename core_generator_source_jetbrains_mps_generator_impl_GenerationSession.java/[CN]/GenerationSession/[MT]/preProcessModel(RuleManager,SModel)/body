{
  if (ruleManager.getPreProcessScripts().isEmpty()) {
    return currentInputModel;
  }
  final boolean modifiesModel=ruleManager.getPreProcessScripts().modifiesModel();
  final boolean needToCloneInputModel=modifiesModel && myGenerationOptions.isSaveTransientModels();
  SModel toRecycle=null;
  if (needToCloneInputModel) {
    ttrace.push("model clone",false);
    SModel currentInputModel_clone=createTransientModel();
    if (myLogger.needsInfo()) {
      myLogger.info("clone model '" + currentInputModel.getReference().getModelName() + "' --> '"+ currentInputModel_clone.getReference().getModelName()+ "'");
    }
    new CloneUtil(currentInputModel,currentInputModel_clone).cloneModelWithImports();
    ttrace.pop();
    mySessionContext.getGenerationTracer().registerPreMappingScripts(currentInputModel,currentInputModel_clone,ruleManager.getPreProcessScripts().getScripts());
    myNewTrace.nextStep(currentInputModel.getReference(),currentInputModel_clone.getReference());
    toRecycle=currentInputModel;
    currentInputModel=currentInputModel_clone;
    myDependenciesBuilder.scriptApplied(currentInputModel);
  }
 else {
    mySessionContext.getGenerationTracer().registerPreMappingScripts(currentInputModel,currentInputModel,ruleManager.getPreProcessScripts().getScripts());
    myNewTrace.nextStep(currentInputModel.getReference(),currentInputModel.getReference());
  }
  TemplateGenerator templateGenerator=new TemplateGenerator(mySessionContext,new StepArguments(ruleManager,currentInputModel,currentInputModel,myDependenciesBuilder,myNewTrace));
  for (  TemplateMappingScript preMappingScript : ruleManager.getPreProcessScripts().getScripts()) {
    if (myLogger.needsInfo()) {
      myLogger.info(preMappingScript.getScriptNode(),"pre-process " + preMappingScript.getLongName());
    }
    templateGenerator.executeScript(preMappingScript);
  }
  if (modifiesModel) {
    myDependenciesBuilder.scriptApplied(currentInputModel);
  }
  if (needToCloneInputModel) {
    if (myNewCache != null) {
      TransientModelWithMetainfo modelWithMetaInfo=TransientModelWithMetainfo.create(currentInputModel,myDependenciesBuilder);
      myNewCache.store(myMajorStep,myMinorStep,modelWithMetaInfo);
    }
    recycleWasteModel(toRecycle,false);
  }
  myLogger.info("pre-processing finished");
  return currentInputModel;
}
