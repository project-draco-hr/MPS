{
  List<TemplateMappingScript> preMappingScripts=ruleManager.getPreMappingScripts();
  if (preMappingScripts.isEmpty()) {
    return currentInputModel;
  }
  boolean needToCloneInputModel=!myDiscardTransients;
  if (!needToCloneInputModel) {
    for (    TemplateMappingScript preMappingScript : preMappingScripts) {
      if (preMappingScript.getKind() == TemplateMappingScript.PREPROCESS) {
        if (preMappingScript.modifiesModel()) {
          needToCloneInputModel=true;
          break;
        }
      }
    }
  }
  SModel toRecycle=null;
  if (needToCloneInputModel) {
    ttrace.push("model clone",false);
    SModel currentInputModel_clone=createTransientModel();
    if (myLogger.needsInfo()) {
      myLogger.info("clone model '" + currentInputModel.getReference().getSModelFqName() + "' --> '"+ currentInputModel_clone.getReference().getSModelFqName()+ "'");
    }
    CloneUtil.cloneModelWithImports(currentInputModel,currentInputModel_clone,currentInputModel == mySessionContext.getOriginalInputModel());
    ttrace.pop();
    if (!myDiscardTransients) {
      mySessionContext.getGenerationTracer().registerPreMappingScripts(currentInputModel,currentInputModel_clone,preMappingScripts);
    }
    toRecycle=currentInputModel;
    currentInputModel=currentInputModel_clone;
    myDependenciesBuilder.scriptApplied(currentInputModel);
  }
  boolean preProcessed=false;
  for (  TemplateMappingScript preMappingScript : preMappingScripts) {
    if (preMappingScript.getKind() != TemplateMappingScript.PREPROCESS) {
      myLogger.warning(preMappingScript.getScriptNode().resolve(MPSModuleRepository.getInstance()),"skip script " + preMappingScript.getLongName() + " - wrong script kind");
      continue;
    }
    if (myLogger.needsInfo()) {
      myLogger.info(preMappingScript.getScriptNode().resolve(MPSModuleRepository.getInstance()),"pre-process " + preMappingScript.getLongName());
    }
    TemplateGenerator templateGenerator=new TemplateGenerator(mySessionContext,myProgressMonitor,myLogger,ruleManager,currentInputModel,currentInputModel,myGenerationOptions,myDependenciesBuilder,ttrace);
    try {
      templateGenerator.getDefaultExecutionContext(null).executeScript(preMappingScript,currentInputModel);
    }
 catch (    Exception t) {
      myLogger.handleException(t);
      myLogger.error(preMappingScript.getScriptNode().resolve(MPSModuleRepository.getInstance()),"error executing script " + preMappingScript.getLongName() + " (see exception)");
      throw new GenerationFailureException(t);
    }
    preProcessed=true;
  }
  if (needToCloneInputModel) {
    myDependenciesBuilder.scriptApplied(currentInputModel);
    if (myNewCache != null) {
      TransientModelWithMetainfo modelWithMetaInfo=TransientModelWithMetainfo.create(currentInputModel,myDependenciesBuilder);
      myNewCache.store(myMajorStep,myMinorStep,modelWithMetaInfo);
    }
    recycleWasteModel(toRecycle);
  }
  if (myLogger.needsInfo() && preProcessed) {
    myLogger.info("pre-processing finished");
  }
  return currentInputModel;
}
