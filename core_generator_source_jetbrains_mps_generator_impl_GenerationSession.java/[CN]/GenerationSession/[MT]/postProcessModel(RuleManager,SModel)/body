{
  List<TemplateMappingScript> postMappingScripts=ruleManager.getPostMappingScripts();
  if (postMappingScripts.isEmpty()) {
    return currentModel;
  }
  boolean needToCloneModel=!myDiscardTransients;
  SModel toRecycle=null;
  if (needToCloneModel) {
    ttrace.push("model clone",false);
    SModel currentOutputModel_clone=createTransientModel();
    if (myLogger.needsInfo()) {
      myLogger.info("clone model '" + currentModel.getSModelFqName() + "' --> '"+ currentOutputModel_clone.getSModelFqName()+ "'");
    }
    CloneUtil.cloneModelWithImports(currentModel,currentOutputModel_clone,false);
    ttrace.pop();
    mySessionContext.getGenerationTracer().registerPostMappingScripts(currentModel,currentOutputModel_clone,postMappingScripts);
    toRecycle=currentModel;
    currentModel=currentOutputModel_clone;
    myDependenciesBuilder.scriptApplied(currentModel);
  }
  boolean postProcessed=false;
  for (  TemplateMappingScript postMappingScript : postMappingScripts) {
    if (postMappingScript.getKind() != TemplateMappingScript.POSTPROCESS) {
      myLogger.warning(postMappingScript.getScriptNode().resolve(MPSModuleRepository.getInstance()),"skip script " + postMappingScript.getLongName() + " - wrong script kind");
      continue;
    }
    if (myLogger.needsInfo()) {
      myLogger.info(postMappingScript.getScriptNode().resolve(MPSModuleRepository.getInstance()),"post-process " + postMappingScript.getLongName());
    }
    TemplateGenerator templateGenerator=new TemplateGenerator(mySessionContext,myProgressMonitor,myLogger,ruleManager,currentModel,currentModel,myGenerationOptions,myDependenciesBuilder,ttrace);
    try {
      templateGenerator.getDefaultExecutionContext(null).executeScript(postMappingScript,currentModel);
    }
 catch (    Exception t) {
      myLogger.handleException(t);
      myLogger.error(postMappingScript.getScriptNode().resolve(MPSModuleRepository.getInstance()),"error executing script " + postMappingScript.getLongName() + " (see exception)");
      throw new GenerationFailureException(t);
    }
    postProcessed=true;
  }
  if (needToCloneModel) {
    myDependenciesBuilder.scriptApplied(currentModel);
    if (myNewCache != null) {
      TransientModelWithMetainfo modelWithMetaInfo=TransientModelWithMetainfo.create(currentModel,myDependenciesBuilder);
      myNewCache.store(myMajorStep,myMinorStep,modelWithMetaInfo);
    }
    recycleWasteModel(toRecycle);
  }
  if (myLogger.needsInfo() && postProcessed) {
    myLogger.info("post-processing finished");
  }
  return currentModel;
}
