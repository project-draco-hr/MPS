{
  if (myMajorStep != 0) {
    throw new GenerationCanceledException();
  }
  GenerationParametersProvider parametersProvider=myGenerationOptions.getParametersProvider();
  ttrace.push("analyzing dependencies",false);
  Collection<String> additionalLanguages=parametersProvider instanceof GenerationParametersProviderEx ? ((GenerationParametersProviderEx)parametersProvider).getAdditionalLanguages(myOriginalInputModel) : null;
  ModelGenerationPlan customPlan=myGenerationOptions.getCustomPlan(myOriginalInputModel);
  myGenerationPlan=customPlan != null ? new GenerationPlan(myOriginalInputModel,customPlan) : new GenerationPlan(myOriginalInputModel,additionalLanguages);
  if (!checkGenerationPlan(myGenerationPlan)) {
    if (myGenerationOptions.isStrictMode()) {
      throw new GenerationCanceledException();
    }
  }
  monitor.start("",1 + myGenerationPlan.getStepCount());
  try {
    IntermediateCacheHelper cacheHelper=new IntermediateCacheHelper(myGenerationOptions.getIncrementalStrategy(),myGenerationPlan,ttrace);
    IncrementalGenerationHandler incrementalHandler=new IncrementalGenerationHandler(myOriginalInputModel,myProject,myGenerationOptions,cacheHelper,null);
    myDependenciesBuilder=incrementalHandler.createDependenciesBuilder();
    if (incrementalHandler.canOptimize()) {
      int ignored=incrementalHandler.getIgnoredRoots().size();
      int total=incrementalHandler.getRootsCount();
      myLogger.info((!incrementalHandler.canIgnoreConditionals() ? "" : "descriptors and ") + ignored + " of "+ total+ " roots are unchanged");
      if (total > 0 && ignored == total && incrementalHandler.canIgnoreConditionals()) {
        myLogger.info("generated files are up-to-date");
        ttrace.pop();
        return new GenerationStatus(myOriginalInputModel,null,myDependenciesBuilder.getResult(new ProjectOperationContext(myProject),myGenerationOptions.getIncrementalStrategy()),false,false,false);
      }
      if (!incrementalHandler.getRequiredRoots().isEmpty() || incrementalHandler.requireConditionals()) {
        myLogger.info((!incrementalHandler.requireConditionals() ? "" : "descriptors and ") + incrementalHandler.getRequiredRoots().size() + " roots can be used from cache");
      }
      if (myGenerationOptions.getTracingMode() != GenerationOptions.TRACE_OFF) {
        myLogger.info("Processing:");
        for (        SNode node : myOriginalInputModel.getRootNodes()) {
          if (incrementalHandler.getRequiredRoots().contains(node)) {
            myLogger.info(String.format("%s (%s) (cache)",node.getName(),node.getConcept().getQualifiedName()));
          }
 else           if (!incrementalHandler.getIgnoredRoots().contains(node)) {
            myLogger.info(String.format("%s (%s)",node.getName(),node.getConcept().getQualifiedName()));
          }
        }
      }
    }
    monitor.advance(1);
    if (InternalFlag.isInternalMode() && myGenerationOptions.isRebuildAll() && myGenerationOptions.isDebugIncrementalDependencies()&& myDependenciesBuilder instanceof IncrementalDependenciesBuilder) {
      myLogger.info("creating generated.trace");
      ((IncrementalDependenciesBuilder)myDependenciesBuilder).traceDependencyOrigins();
    }
    boolean success=false;
    myIntermediateCache=new IntermediateCacheHelper(myGenerationOptions.getIncrementalStrategy(),myGenerationPlan,ttrace);
    myIntermediateCache.createNew(myOriginalInputModel);
    ttrace.pop();
    try {
      mySessionContext=new GenerationSessionContext(mySessionContext,myGenerationPlan);
      SModel currInputModel=createTransientModel("0");
      new CloneUtil(myOriginalInputModel,currInputModel).traceOriginalInput().cloneModelWithImports();
      for (Iterator<SNode> it1=myOriginalInputModel.getRootNodes().iterator(), it2=currInputModel.getRootNodes().iterator(); it1.hasNext() && it2.hasNext(); ) {
        myDependenciesBuilder.registerRoot(it2.next(),it1.next());
      }
      myDependenciesBuilder.updateModel(currInputModel);
      SModel currOutput=null;
      ttrace.push("steps",false);
      myGenerationPlan.createSwitchGraph();
      for (myMajorStep=0; myMajorStep < myGenerationPlan.getStepCount(); myMajorStep++) {
        final List<TemplateMappingConfiguration> mappingConfigurations=myGenerationPlan.getMappingConfigurations(myMajorStep);
        if (mappingConfigurations.size() >= 1) {
          final TemplateMappingConfiguration first=mappingConfigurations.get(0);
          String n=GeneratorUtil.compactNamespace(first.getModel().getLongName());
          monitor.step(String.format("step %d (%s#%s%s)",myMajorStep,n,first.getName(),mappingConfigurations.size() == 1 ? "" : "..."));
        }
        if (myLogger.needsInfo()) {
          myLogger.info("executing step " + (myMajorStep + 1));
        }
        currOutput=executeMajorStep(monitor.subTask(1),currInputModel);
        monitor.advance(0);
        if (currOutput == null || myLogger.getErrorCount() > 0) {
          break;
        }
        if (mappingConfigurations.isEmpty()) {
          break;
        }
        currInputModel=currOutput;
      }
      ttrace.pop();
      mySessionContext.clearTransientObjects();
      if (myGenerationOptions.isKeepOutputModel() && currOutput != null) {
        mySessionContext.getModule().addModelToKeep(currOutput.getReference(),true);
      }
      GenerationStatus generationStatus=new GenerationStatus(myOriginalInputModel,currOutput,myDependenciesBuilder.getResult(new ProjectOperationContext(myProject),myGenerationOptions.getIncrementalStrategy()),myLogger.getErrorCount() > 0,myLogger.getWarningCount() > 0,false);
      generationStatus.setModelExports(new ExportsVault(mySessionContext).getModelExports());
      success=generationStatus.isOk();
      return generationStatus;
    }
 catch (    GenerationCanceledException gce) {
      throw gce;
    }
catch (    GenerationFailureException gfe) {
      final String nestedException;
      if (gfe.getCause() != null) {
        nestedException=gfe.getCause().toString();
      }
 else {
        nestedException="";
      }
      String error=gfe.getMessage() == null ? gfe.toString() : gfe.getMessage();
      String msg=String.format("Generation failed for model '%s': %s. %s",myOriginalInputModel.getReference().getModelName(),error,nestedException);
      myLogger.handleException(gfe);
      myLogger.error(msg);
      return new GenerationStatus.ERROR(myOriginalInputModel);
    }
catch (    Exception e) {
      myLogger.handleException(e);
      myLogger.error("model \"" + myOriginalInputModel.getReference().getModelName() + "\" generation failed (see exception)");
      return new GenerationStatus.ERROR(myOriginalInputModel);
    }
 finally {
      if (success) {
        myIntermediateCache.commit();
      }
 else {
        myIntermediateCache.discard();
      }
    }
  }
  finally {
    monitor.done();
  }
}
