{
  if (myMajorStep != 0) {
    throw new GenerationCanceledException();
  }
  GenerationParametersProvider parametersProvider=myGenerationOptions.getParametersProvider();
  ttrace.push("analyzing dependencies",false);
  myGenerationPlan=myGenerationOptions.getCustomPlan(myOriginalInputModel);
  if (myGenerationPlan == null) {
    Collection<String> additionalLanguages=parametersProvider instanceof GenerationParametersProviderEx ? ((GenerationParametersProviderEx)parametersProvider).getAdditionalLanguages(myOriginalInputModel) : null;
    List<SLanguage> extraLanguages=null;
    if (additionalLanguages != null && !additionalLanguages.isEmpty()) {
      extraLanguages=new ArrayList<SLanguage>(additionalLanguages.size());
      for (      String l : additionalLanguages) {
        extraLanguages.add(MetaAdapterFactoryByName.getLanguage(l));
      }
    }
    GenerationPlan gp;
    myGenerationPlan=gp=new GenerationPlan(myOriginalInputModel,extraLanguages);
    if (!checkGenerationPlan(gp) && myGenerationOptions.isStrictMode()) {
      throw new GenerationCanceledException();
    }
  }
  warnIfGenerateSelf(myGenerationPlan);
  monitor.start("",1 + myGenerationPlan.getSteps_().size());
  try {
    IntermediateCacheHelper cacheHelper=new IntermediateCacheHelper(myGenerationOptions.getIncrementalStrategy(),new PlanSignature(myOriginalInputModel,myGenerationPlan),ttrace);
    IncrementalGenerationHandler incrementalHandler=new IncrementalGenerationHandler(myOriginalInputModel,myProject,myGenerationOptions,cacheHelper,null);
    myDependenciesBuilder=incrementalHandler.createDependenciesBuilder();
    if (incrementalHandler.canOptimize()) {
      int ignored=incrementalHandler.getIgnoredRoots().size();
      int total=incrementalHandler.getRootsCount();
      myLogger.info((!incrementalHandler.canIgnoreConditionals() ? "" : "descriptors and ") + ignored + " of "+ total+ " roots are unchanged");
      if (total > 0 && ignored == total && incrementalHandler.canIgnoreConditionals()) {
        myLogger.info("generated files are up-to-date");
        ttrace.pop();
        return new GenerationStatus(myOriginalInputModel,null,myDependenciesBuilder.getResult(myGenerationOptions.getIncrementalStrategy()),false,false,false);
      }
      if (!incrementalHandler.getRequiredRoots().isEmpty() || incrementalHandler.requireConditionals()) {
        myLogger.info((!incrementalHandler.requireConditionals() ? "" : "descriptors and ") + incrementalHandler.getRequiredRoots().size() + " roots can be used from cache");
      }
      if (myGenerationOptions.getTracingMode() != GenerationOptions.TRACE_OFF) {
        myLogger.info("Processing:");
        for (        SNode node : myOriginalInputModel.getRootNodes()) {
          if (incrementalHandler.getRequiredRoots().contains(node)) {
            myLogger.info(String.format("%s (%s) (cache)",node.getName(),node.getConcept().getQualifiedName()));
          }
 else           if (!incrementalHandler.getIgnoredRoots().contains(node)) {
            myLogger.info(String.format("%s (%s)",node.getName(),node.getConcept().getQualifiedName()));
          }
        }
      }
    }
    monitor.advance(1);
    if (InternalFlag.isInternalMode() && myGenerationOptions.isRebuildAll() && myGenerationOptions.isDebugIncrementalDependencies()&& myDependenciesBuilder instanceof IncrementalDependenciesBuilder) {
      myLogger.info("creating generated.trace");
      ((IncrementalDependenciesBuilder)myDependenciesBuilder).traceDependencyOrigins();
    }
    boolean success=false;
    myIntermediateCache=new IntermediateCacheHelper(myGenerationOptions.getIncrementalStrategy(),new PlanSignature(myOriginalInputModel,myGenerationPlan),ttrace);
    myIntermediateCache.createNew(myOriginalInputModel);
    ttrace.pop();
    try {
      SModel currInputModel=createTransientModel("0");
      new CloneUtil(myOriginalInputModel,currInputModel).traceOriginalInput().cloneModelWithImports();
      for (Iterator<SNode> it1=myOriginalInputModel.getRootNodes().iterator(), it2=currInputModel.getRootNodes().iterator(); it1.hasNext() && it2.hasNext(); ) {
        myDependenciesBuilder.registerRoot(it2.next(),it1.next());
      }
      myDependenciesBuilder.updateModel(currInputModel);
      SModel currOutput=null;
      ttrace.push("steps",false);
      for (myMajorStep=0; myMajorStep < myGenerationPlan.getSteps_().size(); myMajorStep++) {
        Step planStep=myGenerationPlan.getSteps_().get(myMajorStep);
        if (planStep instanceof Transform) {
          Transform transformStep=(Transform)planStep;
          final List<TemplateMappingConfiguration> mappingConfigurations=transformStep.getTransformations();
          if (mappingConfigurations.size() >= 1) {
            final TemplateMappingConfiguration first=mappingConfigurations.get(0);
            String n=GeneratorUtil.compactNamespace(first.getModel().getLongName());
            monitor.step(String.format("step %d (%s#%s%s)",myMajorStep + 1,n,first.getName(),mappingConfigurations.size() == 1 ? "" : "..."));
          }
          if (myLogger.needsInfo()) {
            myLogger.info("executing step " + (myMajorStep + 1));
          }
          currOutput=executeMajorStep(monitor.subTask(1),currInputModel,transformStep);
          monitor.advance(0);
          if (currOutput == null || myLogger.getErrorCount() > 0) {
            break;
          }
          if (mappingConfigurations.isEmpty()) {
            break;
          }
          currInputModel=currOutput;
        }
 else         if (planStep instanceof Checkpoint) {
          Checkpoint checkpointStep=(Checkpoint)planStep;
          CheckpointState cpState=mySessionContext.getCrossModelEnvironment().createCheckpoint(myOriginalInputModel,currInputModel,checkpointStep);
          if (myStepArguments != null) {
            GeneratorMappings stepLabels=myStepArguments.mappingLabels;
            stepLabels.export(cpState);
            SModel checkpointModel=cpState.getCheckpointModel();
            SNode debugMappings=new DebugMappingsBuilder(mySessionContext.getProject().getRepository()).build(checkpointModel,stepLabels);
            checkpointModel.addRootNode(debugMappings);
          }
          myStepArguments=null;
        }
      }
      ttrace.pop();
      mySessionContext.clearTransientObjects();
      if (myGenerationOptions.isKeepOutputModel() && currOutput != null) {
        mySessionContext.getModule().addModelToKeep(currOutput.getReference(),true);
      }
      GenerationStatus generationStatus=new GenerationStatus(myOriginalInputModel,currOutput,myDependenciesBuilder.getResult(myGenerationOptions.getIncrementalStrategy()),myLogger.getErrorCount() > 0,myLogger.getWarningCount() > 0,false);
      generationStatus.setModelExports(mySessionContext.getExports().getExports());
      success=generationStatus.isOk();
      return generationStatus;
    }
 catch (    GenerationCanceledException gce) {
      throw gce;
    }
catch (    GenerationFailureException gfe) {
      final String nestedException;
      if (gfe.getCause() != null) {
        nestedException=gfe.getCause().toString();
      }
 else {
        nestedException="";
      }
      String error=gfe.getMessage() == null ? gfe.toString() : gfe.getMessage();
      String msg=String.format("Generation failed for model '%s': %s. %s",myOriginalInputModel.getReference().getModelName(),error,nestedException);
      myLogger.handleException(gfe);
      myLogger.error(msg);
      return new GenerationStatus.ERROR(myOriginalInputModel);
    }
catch (    Exception e) {
      myLogger.handleException(e);
      myLogger.error("model \"" + myOriginalInputModel.getReference().getModelName() + "\" generation failed");
      return new GenerationStatus.ERROR(myOriginalInputModel);
    }
 finally {
      if (success) {
        myIntermediateCache.commit();
      }
 else {
        myIntermediateCache.discard();
      }
    }
  }
  finally {
    monitor.done();
  }
}
