{
  boolean hasChanges;
  myDependenciesBuilder.setOutputModel(currentOutputModel,myMajorStep,myMinorStep);
  ttrace.push(String.format("Step %d.%d",myMajorStep + 1,myMinorStep),true);
  StepArguments args=new StepArguments(ruleManager,currentInputModel,currentOutputModel,myDependenciesBuilder,myNewTrace);
  final TemplateGenerator tg=myGenerationOptions.isGenerateInParallel() ? new ParallelTemplateGenerator(myTaskPoolProvider,mySessionContext,myProgressMonitor,args) : new TemplateGenerator(mySessionContext,myProgressMonitor,args);
  hasChanges=tg.apply(isPrimary);
  ttrace.pop();
  SModel outputModel=tg.getOutputModel();
  if (myNewCache != null && (isPrimary || hasChanges)) {
    ttrace.push("saving cache",false);
    TransientModelWithMetainfo modelWithMetaInfo=TransientModelWithMetainfo.create(outputModel,myDependenciesBuilder);
    tg.getMappings().export(modelWithMetaInfo,myDependenciesBuilder);
    myNewCache.store(myMajorStep,myMinorStep,modelWithMetaInfo);
    ttrace.pop();
  }
  return new Pair<Boolean,SModel>(hasChanges,outputModel);
}
