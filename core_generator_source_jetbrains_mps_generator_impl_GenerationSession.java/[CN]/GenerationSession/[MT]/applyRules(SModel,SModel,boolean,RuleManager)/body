{
  boolean hasChanges;
  myDependenciesBuilder.setOutputModel(currentOutputModel,myMajorStep,myMinorStep);
  final TemplateGenerator tg=myGenerationOptions.isGenerateInParallel() ? new ParallelTemplateGenerator(myController,mySessionContext,myProgressMonitor,myLogger,ruleManager,currentInputModel,currentOutputModel,myGenerationOptions,myDependenciesBuilder,ttrace) : new TemplateGenerator(mySessionContext,myProgressMonitor,myLogger,ruleManager,currentInputModel,currentOutputModel,myGenerationOptions,myDependenciesBuilder,ttrace);
  if (tg instanceof ParallelTemplateGenerator) {
    hasChanges=GeneratorUtil.runReadInWrite(new GenerationComputable<Boolean>(){
      @Override public Boolean compute() throws GenerationCanceledException, GenerationFailureException {
        return tg.apply(isPrimary);
      }
    }
);
  }
 else {
    hasChanges=tg.apply(isPrimary);
  }
  if (myNewCache != null && (isPrimary || hasChanges)) {
    TransientModelWithMetainfo modelWithMetaInfo=TransientModelWithMetainfo.create(currentOutputModel,myDependenciesBuilder);
    tg.getMappings().export(modelWithMetaInfo,myDependenciesBuilder);
    myNewCache.store(myMajorStep,myMinorStep,modelWithMetaInfo);
  }
  return hasChanges;
}
