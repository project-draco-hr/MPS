{
  if (myMajorStep != 0) {
    throw new GenerationCanceledException();
  }
  ttrace.push("analyzing dependencies",false);
  myGenerationPlan=new GenerationPlan(myOriginalInputModel.getSModel());
  if (!checkGenerationPlan(myGenerationPlan)) {
  }
  GenerationFilter filter=new GenerationFilter(myOriginalInputModel,myInvocationContext,myGenerationOptions,myGenerationPlan.getSignature());
  myDependenciesBuilder=filter.createDependenciesBuilder();
  if (filter.canOptimize()) {
    int ignored=filter.getIgnoredRoots().size();
    int total=filter.getRootsCount();
    myLogger.info((!filter.canIgnoreConditionals() ? "" : "descriptors and ") + ignored + " of "+ total+ " roots are unchanged");
    if (total > 0 && ignored == total && filter.canIgnoreConditionals()) {
      myLogger.info("generated files are up-to-date");
      ttrace.pop();
      return new GenerationStatus(myOriginalInputModel.getSModel(),null,myDependenciesBuilder.getResult(myInvocationContext,myGenerationOptions.getIncrementalStrategy()),false,false,false);
    }
    if (!filter.getRequiredRoots().isEmpty() || filter.requireConditionals()) {
      myLogger.info((!filter.requireConditionals() ? "" : "descriptors and ") + filter.getRequiredRoots().size() + " roots can be used from cache");
    }
    if (myGenerationOptions.getTracingMode() != GenerationOptions.TRACE_OFF) {
      myLogger.info("Processing:");
      for (      SNode node : myOriginalInputModel.getSModel().getRoots()) {
        if (filter.getRequiredRoots().contains(node)) {
          myLogger.info(node.getName() + " (cache)");
        }
 else         if (!filter.getIgnoredRoots().contains(node)) {
          myLogger.info(node.getName());
        }
      }
    }
  }
  boolean success=false;
  myNewCache=filter.createNewCache();
  ttrace.pop();
  try {
    SModel currInputModel=myOriginalInputModel.getSModel();
    SModel currOutput=null;
    ttrace.push("steps",false);
    for (myMajorStep=0; myMajorStep < myGenerationPlan.getStepCount(); myMajorStep++) {
      if (myLogger.needsInfo()) {
        myLogger.info("executing step " + (myMajorStep + 1));
      }
      currOutput=executeMajorStep(currInputModel);
      if (currOutput == null || myLogger.getErrorCount() > 0) {
        break;
      }
      if (myGenerationPlan.getMappingConfigurations(myMajorStep).isEmpty()) {
        break;
      }
      currInputModel=currOutput;
    }
    ttrace.pop();
    if (mySessionContext != null) {
      mySessionContext.clearTransientObjects();
    }
    GenerationStatus generationStatus=new GenerationStatus(myOriginalInputModel.getSModel(),currOutput,myDependenciesBuilder.getResult(myInvocationContext,myGenerationOptions.getIncrementalStrategy()),myLogger.getErrorCount() > 0,myLogger.getWarningCount() > 0,false);
    success=generationStatus.isOk();
    return generationStatus;
  }
 catch (  GenerationCanceledException gce) {
    throw gce;
  }
catch (  GenerationFailureException gfe) {
    myLogger.error(gfe.getMessage());
    myLogger.error("model \"" + myOriginalInputModel.getSModelReference().getSModelFqName() + "\" generation failed : "+ gfe);
    return new GenerationStatus.ERROR(myOriginalInputModel.getSModel());
  }
catch (  Throwable e) {
    myLogger.handleException(e);
    myLogger.error("model \"" + myOriginalInputModel.getSModelReference().getSModelFqName() + "\" generation failed : "+ e);
    return new GenerationStatus.ERROR(myOriginalInputModel.getSModel());
  }
 finally {
    if (myNewCache != null) {
      if (success) {
        myNewCache.store();
      }
 else {
        myNewCache.remove();
      }
      myLogger.info("time spent saving cache: " + myNewCache.getTimeSpent());
    }
  }
}
