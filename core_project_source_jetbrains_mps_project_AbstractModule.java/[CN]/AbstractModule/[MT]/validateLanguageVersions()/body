{
  assertCanChange();
  ModuleDescriptor md=getModuleDescriptor();
  if (md == null) {
    return;
  }
  Map<SLanguage,Integer> oldLanguageVersions=md.getLanguageVersions();
  Map<SLanguage,Integer> newLanguageVersions=new HashMap<SLanguage,Integer>();
  if (!md.hasLanguageVersions()) {
    for (    SLanguage lang : getAllUsedLanguages()) {
      newLanguageVersions.put(lang,0);
    }
    md.setHasLanguageVersions(true);
  }
 else {
    for (    SLanguage lang : getAllUsedLanguages()) {
      if (oldLanguageVersions.containsKey(lang)) {
        newLanguageVersions.put(lang,oldLanguageVersions.get(lang));
      }
 else {
        int currentVersion=lang.getLanguageVersion();
        for (        SModel m : getModels()) {
          SModelInternal modelInternal=(SModelInternal)m;
          if (!modelInternal.importedLanguageIds().contains(lang))           continue;
          int modelVer=modelInternal.getLanguageImportVersion(lang);
          if (modelVer == -1)           continue;
          if (modelInternal.importedLanguageIds().contains(lang) && modelVer != currentVersion) {
            LOG.error("Could not update used language versions. Language " + lang + " has current version "+ currentVersion+ " while model "+ m.getModelName()+ " uses this language with version "+ modelVer);
          }
        }
        newLanguageVersions.put(lang,currentVersion);
        if (md.hasDependencyVersions()) {
          setChanged();
        }
      }
    }
    if (oldLanguageVersions.size() != newLanguageVersions.size()) {
      if (md.hasDependencyVersions()) {
        setChanged();
      }
    }
  }
  oldLanguageVersions.clear();
  oldLanguageVersions.putAll(newLanguageVersions);
}
