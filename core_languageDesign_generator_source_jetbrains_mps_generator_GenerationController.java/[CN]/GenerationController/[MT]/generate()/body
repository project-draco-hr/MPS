{
  long startTime=System.currentTimeMillis();
  clearMessageVew();
  myProgress.setIndeterminate(false);
  myProgress.setFraction(0);
  if (!myProgress.isRunning()) {
    myProgress.start();
  }
  long totalJob=estimateGenerationTime();
  long startJobTime=System.currentTimeMillis();
  myMesssages.handle(new Message(MessageKind.INFORMATION,myGenerationType.getStartText()));
  try {
    boolean generationOK=true;
    for (    Pair<IModule,List<SModelDescriptor>> moduleAndDescriptors : myModuleSequence) {
      boolean result=generateModelsInModule(moduleAndDescriptors.o1,moduleAndDescriptors.o2,totalJob,startJobTime);
      generationOK=generationOK && result;
    }
    if (generationOK) {
      fireBeforeModelsCompiled(generationOK);
      boolean compiledSuccessfully=true;
      long compilationStart=System.currentTimeMillis();
      boolean needToReload=false;
      for (      Pair<IModule,List<SModelDescriptor>> moduleListPair : myModuleSequence) {
        IModule module=moduleListPair.o1;
        if (module != null && module.reloadClassesAfterGeneration() && myGenerationType.requiresReloading()) {
          needToReload=true;
        }
        boolean compilationResult=compileModule(module,totalJob,startJobTime);
        compiledSuccessfully=compiledSuccessfully && compilationResult;
      }
      for (      SModelDescriptor sm : myModelsToContexts.keySet()) {
        ModelGenerationStatusManager.getInstance().invalidateData(sm);
      }
      if (compiledSuccessfully && needToReload) {
        reloadClasses(totalJob,startJobTime);
      }
      generationOK=generationOK && compiledSuccessfully;
      info("Compilation finished in " + (System.currentTimeMillis() - compilationStart) + " ms");
      fireAfterModelsCompiled(generationOK);
    }
    if (generationOK) {
      info("generation completed successfully in " + (System.currentTimeMillis() - startTime) + " ms");
    }
 else {
      error("generation completed with errors in " + (System.currentTimeMillis() - startTime) + " ms");
    }
    if (isIDEAPresent() && !myGenerationType.requiresCompilationAfterGeneration()) {
      getProjectHandler().refreshFS();
    }
    fireModelsGenerated(generationOK);
  }
 catch (  GenerationCanceledException gce) {
    warning("generation canceled");
    myProgress.stop();
    return false;
  }
catch (  Throwable t) {
    LOG.error(t);
    final String text=t.toString();
    myMesssages.handle(new Message(MessageKind.ERROR,text));
  }
 finally {
    if (myProgress.isRunning()) {
      myProgress.stop();
    }
  }
  return true;
}
