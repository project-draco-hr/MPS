{
  boolean currentGenerationOK=true;
  IOperationContext invocationContext=myModulesToContexts.get(module);
  setText2("module " + module,totalJob,startJobTime);
  String outputFolder=module != null ? module.getGeneratorOutputPath() : null;
  prepareOutputFolder(outputFolder);
  if (containsTestModels(inputModels)) {
    String testsOutputFolder=module != null ? module.getTestsGeneratorOutputPath() : null;
    prepareOutputFolder(testsOutputFolder);
  }
  myMesssages.handle(new Message(MessageKind.INFORMATION,GenerationController.class,"    target root folder: \"" + outputFolder + "\""));
  String wasLoggingThreshold=null;
  IGenerationSession generationSession=new GenerationSession(invocationContext,mySaveTransientModels,myProgress,myMesssages);
  try {
    if (mySettings.isShowErrorsOnly()) {
      wasLoggingThreshold=Logger.setThreshold("ERROR");
    }
    Logger.addLoggingHandler(generationSession.getLoggingHandler());
    for (    SModelDescriptor inputModel : inputModels) {
      TypeChecker.getInstance().setIsGeneration(true);
      TaskProgressHelper progress=new TaskProgressHelper(this);
      try {
        if (!myGenerationType.isApplicable(inputModel)) {
          LOG.error("Can't apply generation type " + myGenerationType + " to "+ inputModel.getSModelFqName());
          continue;
        }
        info("");
        String taskName=ModelsProgressUtil.generationModelTaskName(inputModel);
        setText2("model " + inputModel.getSModelFqName(),totalJob,startJobTime);
        progress.startLeafTask(taskName,myProgress,totalJob,startJobTime);
        GenerationStatus status=generationSession.generateModel(inputModel);
        status.setOriginalInputModel(inputModel);
        currentGenerationOK=currentGenerationOK && status.isOk();
        info("handling output...");
        checkMonitorCanceled();
        String targetDir=module.getOutputFor(inputModel);
        if (status.getOutputModel() != null) {
          boolean result=myGenerationType.handleOutput(status,targetDir,invocationContext,myProgress,myMesssages);
          if (!result) {
            info("there were errors.");
            currentGenerationOK=false;
          }
        }
 else         if (!(status.isCanceled() || status.isError())) {
          myGenerationType.handleEmptyOutput(status,targetDir,invocationContext,myProgress,myMesssages);
        }
      }
  finally {
        generationSession.discardTransients();
        CleanupManager.getInstance().cleanup();
        progress.finishTask();
        TypeChecker.getInstance().setIsGeneration(false);
        setText2("",totalJob,startJobTime);
      }
    }
  }
  finally {
    if (wasLoggingThreshold != null) {
      Logger.setThreshold(wasLoggingThreshold);
    }
    Logger.removeLoggingHandler(generationSession.getLoggingHandler());
  }
  checkMonitorCanceled();
  info("");
  setText2("",totalJob,startJobTime);
  return currentGenerationOK;
}
