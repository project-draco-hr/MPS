{
  LinkedList<SNode> ancestors=new LinkedList<SNode>();
  SNode current=node;
  while (current != null) {
    ancestors.addFirst(current);
    current=current.getParent();
  }
  MPSTreeNode currentTreeNode=parent;
  for (  final SNode anc : ancestors) {
    final MPSTreeNode finalCurrentTreeNode=currentTreeNode;
    if (!currentTreeNode.isInitialized() && !currentTreeNode.hasInfiniteSubtree())     currentTreeNode.init();
    currentTreeNode=findTreeNode(finalCurrentTreeNode,new Condition<MPSTreeNode>(){
      public boolean met(      MPSTreeNode object){
        if (object == finalCurrentTreeNode)         return true;
        if (!(object instanceof PackageNode))         return false;
        String pack=((PackageNode)object).getFullPackage();
        String vp=node.getContainingRoot().getProperty(SNodeUtil.property_BaseConcept_virtualPackage);
        return vp != null && vp.startsWith(pack);
      }
    }
,new Condition<MPSTreeNode>(){
      public boolean met(      MPSTreeNode tNode){
        return (tNode instanceof SNodeTreeNode) && (((SNodeTreeNode)tNode).getSNode() == anc);
      }
    }
);
    if (currentTreeNode == null)     return null;
  }
  return (MPSTreeNodeEx)currentTreeNode;
}
