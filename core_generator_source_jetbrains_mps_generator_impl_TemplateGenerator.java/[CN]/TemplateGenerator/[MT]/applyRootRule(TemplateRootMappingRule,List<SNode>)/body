{
  String applicableConcept=rule.getApplicableConcept();
  if (applicableConcept == null) {
    showErrorMessage(null,null,rule.getRuleNode().resolve(MPSModuleRepository.getInstance()),"rule has no applicable concept defined");
    return;
  }
  boolean includeInheritors=rule.applyToInheritors();
  Iterable<SNode> inputNodes=((jetbrains.mps.smodel.SModelInternal)myInputModel).getFastNodeFinder().getNodes(applicableConcept,includeInheritors);
  for (  SNode inputNode : inputNodes) {
    if (getGeneratorSessionContext().isCopiedRoot(inputNode))     continue;
    final QueryExecutionContext executionContext=getExecutionContext(inputNode);
    if (executionContext != null) {
      TemplateExecutionEnvironment environment=new TemplateExecutionEnvironmentImpl(this,new ReductionContext(executionContext),getOperationContext(),myGenerationTracer);
      try {
        if (executionContext.isApplicable(rule,environment,new DefaultTemplateContext(inputNode))) {
          myGenerationTracer.pushInputNode(GenerationTracerUtil.getSNodePointer(inputNode));
          myGenerationTracer.pushRule(rule.getRuleNode());
          try {
            boolean copyRootOnFailure=false;
            if (inputNode.getModel() != null && inputNode.getModel().isRoot(inputNode) && !rule.keepSourceRoot()) {
              rootsToCopy.remove(inputNode);
              copyRootOnFailure=true;
            }
            createRootNodeByRule(rule,inputNode,copyRootOnFailure,environment);
          }
  finally {
            myGenerationTracer.closeInputNode(GenerationTracerUtil.getSNodePointer(inputNode));
          }
        }
      }
 catch (      GenerationException e) {
        if (e instanceof GenerationCanceledException)         throw (GenerationCanceledException)e;
        if (e instanceof GenerationFailureException)         throw (GenerationFailureException)e;
        showErrorMessage(null,rule.getRuleNode().resolve(MPSModuleRepository.getInstance()),"internal error: " + e.toString());
      }
    }
  }
}
