{
  double time=System.currentTimeMillis();
  curTime=time;
  if (OrthogonalPointFlowLayouter.SHOW_TIME > 0) {
    System.out.println("creating layout for graph with " + ListSequence.<Node>fromList(graph.getNodes()).count() + " nodes and "+ ListSequence.<Edge>fromList(graph.getEdges()).count()+ " edges...");
  }
  Graph copy=new Graph();
  Map<Node,Node> nodeMap=MapSequence.<Node,Node>fromMap(new HashMap<Node,Node>());
  Map<Edge,Edge> edgeMap=MapSequence.<Edge,Edge>fromMap(new HashMap<Edge,Edge>());
  for (  Node node : ListSequence.<Node>fromList(graph.getNodes())) {
    MapSequence.<Node,Node>fromMap(nodeMap).put(node,copy.createNode());
  }
  for (  Edge edge : ListSequence.<Edge>fromList(graph.getEdges())) {
    MapSequence.<Edge,Edge>fromMap(edgeMap).put(edge,copy.connect(MapSequence.<Node,Node>fromMap(nodeMap).get(edge.getSource()),MapSequence.<Node,Node>fromMap(nodeMap).get(edge.getTarget())));
  }
  EdgesHistoryManager historyManager=new EdgesHistoryManager(copy);
  BiconnectAugmentation.smartMakeBiconnected(copy);
  EmbeddedGraph embeddedGraph=new ShortestPathEmbeddingFinder(new PQPlanarizationFinder()).find(copy);
  Map<Edge,List<Edge>> history=MapSequence.<Edge,List<Edge>>fromMap(new HashMap<Edge,List<Edge>>());
  for (  Edge edge : ListSequence.<Edge>fromList(graph.getEdges())) {
    Edge copyEdge=MapSequence.<Edge,Edge>fromMap(edgeMap).get(edge);
    MapSequence.<Edge,List<Edge>>fromMap(history).put(edge,historyManager.getHistory(copyEdge));
    if (copyEdge.getSource() != MapSequence.<Node,Node>fromMap(nodeMap).get(edge.getSource())) {
      MapSequence.<Edge,List<Edge>>fromMap(history).put(edge,ListSequence.<Edge>fromList(MapSequence.<Edge,List<Edge>>fromMap(history).get(edge)).reversedList());
    }
  }
  if (OrthogonalPointFlowLayouter.SHOW_TIME > 0) {
    long newTime=System.currentTimeMillis();
    System.out.println("finding the embedding: " + ((newTime - curTime) / OrthogonalPointFlowLayouter.MILLIS));
    System.out.println("graph now has " + ListSequence.<Node>fromList(copy.getNodes()).count() + " nodes and "+ ListSequence.<Edge>fromList(copy.getEdges()).count()+ " edges");
    curTime=newTime;
  }
  GraphPointLayout copyLayout=getFlowLayout(embeddedGraph,historyManager);
  GraphPointLayout graphLayout=new GraphPointLayout(graph);
  for (  Node node : ListSequence.<Node>fromList(graph.getNodes())) {
    graphLayout.setLayoutFor(node,copyLayout.getLayoutFor(MapSequence.<Node,Node>fromMap(nodeMap).get(node)));
  }
  for (  Edge graphEdge : ListSequence.<Edge>fromList(graph.getEdges())) {
    List<Point> edgeLayout=ListSequence.<Point>fromList(new ArrayList<Point>());
    List<Edge> edgeHistory=MapSequence.<Edge,List<Edge>>fromMap(history).get(graphEdge);
    Node cur=MapSequence.<Node,Node>fromMap(nodeMap).get(graphEdge.getSource());
    for (    Edge edge : ListSequence.<Edge>fromList(edgeHistory)) {
      if (cur == edge.getSource()) {
        ListSequence.<Point>fromList(edgeLayout).addSequence(ListSequence.<Point>fromList(copyLayout.getLayoutFor(edge)));
      }
 else {
        ListSequence.<Point>fromList(edgeLayout).addSequence(ListSequence.<Point>fromList(copyLayout.getLayoutFor(edge)).reversedList());
      }
      cur=edge.getOpposite(cur);
    }
    graphLayout.setLayoutFor(graphEdge,edgeLayout);
  }
  if (OrthogonalPointFlowLayouter.SHOW_TIME > 0) {
    long newTime=System.currentTimeMillis();
    System.out.println("all: " + ((newTime - time) / OrthogonalPointFlowLayouter.MILLIS));
  }
  return graphLayout;
}
