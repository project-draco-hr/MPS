{
  MethodBinding b=x.binding;
  SNode method=SNodeOperations.cast(myTypesProvider.getRaw(b),"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration");
  if ((method == null)) {
    return;
  }
  try {
    if (x.isNative()) {
      throw new JavaConverterException("Native methods not supported");
    }
    myCurrentMethod=method;
    SNode methodBody=SLinkOperations.getTarget(method,"body",true);
    if ((methodBody == null)) {
      methodBody=SModelOperations.createNewNode(myCurrentModel,"jetbrains.mps.baseLanguage.structure.StatementList",null);
      ListSequence.fromList(myBlocks).addElement(MultiTuple.<SNode,CompilationUnitDeclaration,Integer,Integer>from(methodBody,getCUD(),x.declarationSourceStart,x.declarationSourceEnd));
      SLinkOperations.setTarget(method,"body",methodBody,true);
    }
    for (    SNode statement : processStatements(x.statements)) {
      ListSequence.fromList(SLinkOperations.getTargets(methodBody,"statement",true)).addElement(statement);
    }
    addMethodParametersAnnotations(x);
    addMethodAnnotations(method,x);
    addMethodJavadoc(method,x.javadoc);
    myCurrentMethod=null;
  }
 catch (  Throwable e) {
    throw new JavaConverterException(e);
  }
}
