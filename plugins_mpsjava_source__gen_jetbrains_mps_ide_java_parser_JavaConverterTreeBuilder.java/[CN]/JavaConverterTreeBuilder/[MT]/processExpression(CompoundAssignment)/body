{
  BaseAssignmentExpression op;
switch (x.operator) {
case OperatorIds.PLUS:
    op=PlusAssignmentExpression.newInstance(myCurrentModel);
  break;
case OperatorIds.MINUS:
op=MinusAssignmentExpression.newInstance(myCurrentModel);
break;
case OperatorIds.MULTIPLY:
op=MulAssignmentExpression.newInstance(myCurrentModel);
break;
case OperatorIds.DIVIDE:
op=DivAssignmentExpression.newInstance(myCurrentModel);
break;
case OperatorIds.AND:
op=AndAssignmentExpression.newInstance(myCurrentModel);
break;
case OperatorIds.OR:
op=OrAssignmentExpression.newInstance(myCurrentModel);
break;
case OperatorIds.XOR:
op=XorAssignmentExpression.newInstance(myCurrentModel);
break;
case OperatorIds.REMAINDER:
op=RemAssignmentExpression.newInstance(myCurrentModel);
break;
case OperatorIds.LEFT_SHIFT:
op=LeftShiftAssignmentExpression.newInstance(myCurrentModel);
break;
case OperatorIds.RIGHT_SHIFT:
op=RightShiftAssignmentExpression.newInstance(myCurrentModel);
break;
default :
throw new JavaConverterException("Unsupported operator for CompoundAssignment");
}
op.setLValue(processExpressionRefl(x.lhs));
op.setRValue(processExpressionRefl(x.expression));
return op;
}
