{
  SNode classifier=SNodeOperations.cast(myTypesProvider.getRaw(x.binding),"jetbrains.mps.baseLanguage.structure.Classifier");
  if (x.binding.isAnnotationType()) {
    myCurrentTypeDeclaration=x;
    if (x.methods != null) {
      for (      AbstractMethodDeclaration method : x.methods) {
        processAnnotationMethod((AnnotationMethodDeclaration)method);
      }
    }
    addClassifierAnnotations(classifier,x);
    addClassifierJavadoc(classifier,x.javadoc);
    myCurrentTypeDeclaration=null;
    return classifier;
  }
  myCurrentTypeDeclaration=x;
  myCurrentClass=classifier;
  try {
    if (x.fields != null) {
      for (      FieldDeclaration fieldDeclaration : x.fields) {
        if (fieldDeclaration instanceof Initializer) {
          assert(SNodeOperations.isInstanceOf(classifier,"jetbrains.mps.baseLanguage.structure.ClassConcept"));
          processInitializer((Initializer)fieldDeclaration,SNodeOperations.cast(classifier,"jetbrains.mps.baseLanguage.structure.ClassConcept"));
        }
 else {
          processField(fieldDeclaration);
        }
      }
    }
    if (x.methods != null) {
      for (      AbstractMethodDeclaration method : x.methods) {
        if (method.isConstructor()) {
          assert(SNodeOperations.isInstanceOf(myCurrentClass,"jetbrains.mps.baseLanguage.structure.ClassConcept"));
          if (x.binding instanceof LocalTypeBinding) {
          }
 else {
            processConstructor((ConstructorDeclaration)method);
          }
        }
 else         if (method.isClinit()) {
          continue;
        }
 else {
          processMethod(method);
        }
        addExceptionsToMethod(method);
      }
    }
    addClassifierAnnotations(classifier,x);
    addClassifierJavadoc(classifier,x.javadoc);
    myCurrentClass=null;
    myCurrentTypeDeclaration=null;
  }
 catch (  Throwable e) {
    throw new JavaConverterException(e);
  }
  return classifier;
}
