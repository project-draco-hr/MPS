{
  ModelAccess.instance().flushEventQueue();
  Future<IResult> res;
  BuildMakeService bms=new BuildMakeService();
  MakeSession ms=new MakeSession(project,getMyMessageHandler(),true){
    @Override public IScript toScript(    ScriptBuilder scriptBuilder){
      scriptBuilder.withFacetNames(new IFacet.Name("jetbrains.mps.make.reduced.ReportFiles"),new IFacet.Name("jetbrains.mps.make.reduced.CollectHashes"));
      return scriptBuilder.toScript();
    }
  }
;
  final Iterable<MResource> resources=Sequence.fromIterable(collectResources(project,go)).toListSequence();
  this.myOutputPaths=new ModuleOutputPaths(Sequence.fromIterable(resources).select(new ISelector<MResource,SModule>(){
    public SModule select(    MResource r){
      return r.module();
    }
  }
));
  final String outputRoot=myWhatToDo.getProperty("OUTPUT_ROOT_DIR");
  final String cachesOutputRoot=myWhatToDo.getProperty("CACHES_OUTPUT_ROOT_DIR");
  final boolean useTransientOutput=Sequence.fromIterable(resources).any(new IWhereFilter<MResource>(){
    public boolean accept(    MResource r){
      return ((AbstractModule)r.module()).getModuleDescriptor().isUseTransientOutput();
    }
  }
);
  this.myOutputRedirects=new OutputPathRedirects(myOutputPaths,outputRoot,cachesOutputRoot,useTransientOutput);
  this.myForeignRootPaths=new ReducedGenerationWorker.MyForeignRootPaths(myOutputPaths.getOutputPaths());
  ReducedMakeFacetConfiguration facetConf=new ReducedMakeFacetConfiguration(myOutputRedirects);
  final List<String> writtenFiles=facetConf.getWrittenFiles();
  final List<String> deletedFiles=facetConf.getDeletedFiles();
  IScriptController scriptCtl=facetConf.configureFacets(ms);
  try {
    res=bms.make(ms,resources,null,scriptCtl);
    if (!(res.get().isSucessful())) {
      myErrors.add("Make was not successful");
    }
    for (    String f : writtenFiles) {
      System.out.println("##WRITTEN##" + f);
    }
    for (    String f : deletedFiles) {
      System.out.println("##DELETED##" + f);
    }
  }
 catch (  InterruptedException e) {
    myErrors.add(e.toString());
  }
catch (  ExecutionException e) {
    myErrors.add(e.toString());
  }
}
