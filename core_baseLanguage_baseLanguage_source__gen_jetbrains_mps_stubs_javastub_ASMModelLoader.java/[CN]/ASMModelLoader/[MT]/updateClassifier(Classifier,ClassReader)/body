{
  if (clsfr instanceof ClassConcept) {
    final ClassConcept cls=(ClassConcept)clsfr;
    ASMClass ac=new ASMClass(reader);
    if (ac.isPublic()) {
      cls.setVisibility(PublicVisibility.newInstance(clsfr.getModel()));
    }
 else {
      cls.setVisibility(null);
    }
    cls.setAbstractClass(ac.isAbstract());
    cls.setIsDeprecated(ac.isDeprecated());
    this.updateAnnotations(ac,cls);
    this.updateTypeVariables(ac,cls.getModel(),cls);
    this.updateExtendsAndImplements(ac,cls);
    this.updateInstanceFields(ac,cls);
    this.updateStaticFields(ac,cls);
    this.updateConstructors(ac,cls);
    this.updateInstanceMethods(ac,cls);
    this.updateStaticMethods(ac,cls);
    cls.setIsFinal(ac.isFinal());
  }
  if (clsfr instanceof Annotation) {
    final Annotation annotation=(Annotation)clsfr;
    ASMClass cls=new ASMClass(reader);
    if (cls.isPublic()) {
      annotation.setVisibility(PublicVisibility.newInstance(clsfr.getModel()));
    }
 else {
      annotation.setVisibility(null);
    }
    this.updateAnnotationMethods(cls,annotation);
    this.updateAnnotations(cls,annotation);
  }
  if (clsfr instanceof Interface && !((clsfr instanceof Annotation))) {
    final Interface intfc=(Interface)clsfr;
    ASMClass ac=new ASMClass(reader);
    if (ac.isPublic()) {
      intfc.setVisibility(PublicVisibility.newInstance(clsfr.getModel()));
    }
 else {
      intfc.setVisibility(null);
    }
    this.updateAnnotations(ac,intfc);
    this.updateTypeVariables(ac,intfc.getModel(),intfc);
    this.updateExtendsForInterface(ac,intfc);
    this.updateStaticFields(ac,intfc);
    this.updateInstanceMethods(ac,intfc);
    intfc.setIsDeprecated(ac.isDeprecated());
  }
}
