{
  if (!((isApplicable(initialState,repository))) || !(ListSequence.fromList(selectedOptions).contains(OPTION))) {
    return ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<SNodeReference,SNodeReference>>());
  }
 else {
    final SNode sourceConcept=SNodeOperations.cast(initialState.resolve(repository),MetaAdapterFactory.getConcept(0xc72da2b97cce4447L,0x8389f407dc1158b7L,0x1103553c5ffL,"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration"));
    Language sourceLanguage=((Language)SNodeOperations.getModel(sourceConcept).getModule());
    Map<LanguageAspect,List<SNode>> aspectsMap=MoveConceptUtil.getAspectNodes(sourceLanguage,Sequence.<SNode>singleton(sourceConcept));
    return MapSequence.fromMap(aspectsMap).translate(new ITranslator2<IMapping<LanguageAspect,List<SNode>>,RefactoringParticipant.Change<SNodeReference,SNodeReference>>(){
      public Iterable<RefactoringParticipant.Change<SNodeReference,SNodeReference>> translate(      final IMapping<LanguageAspect,List<SNode>> mapping){
        return ListSequence.fromList(mapping.value()).select(new ISelector<SNode,RefactoringParticipant.Change<SNodeReference,SNodeReference>>(){
          public RefactoringParticipant.Change<SNodeReference,SNodeReference> select(          final SNode aspect){
            List<SNode> descendants=SNodeOperations.getNodeDescendants(aspect,null,true,new SAbstractConcept[]{});
            final List<Tuples._2<SNode,RecursiveParticipant.RecursiveParticipantState<?,?,SNode,SNode>>> childparticipantStates=ListSequence.fromList(descendants).translate(new ITranslator2<SNode,Tuples._2<SNode,RecursiveParticipant.RecursiveParticipantState<?,?,SNode,SNode>>>(){
              public Iterable<Tuples._2<SNode,RecursiveParticipant.RecursiveParticipantState<?,?,SNode,SNode>>> translate(              final SNode node){
                return Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?,?>>("jetbrains.mps.ide.platform.MoveNodeParticipantEP").getObjects()).select(new ISelector<MoveNodeRefactoringParticipant<?,?>,Tuples._2<SNode,RecursiveParticipant.RecursiveParticipantState<?,?,SNode,SNode>>>(){
                  public Tuples._2<SNode,RecursiveParticipant.RecursiveParticipantState<?,?,SNode,SNode>> select(                  MoveNodeRefactoringParticipant<?,?> participant){
                    RecursiveParticipant.RecursiveParticipantState<?,?,SNode,SNode> participantState=RecursiveParticipant.RecursiveParticipantState.create(participant,node,parents);
                    participantState.findChanges(repository,selectedOptions,searchScope);
                    return MultiTuple.<SNode,RecursiveParticipant.RecursiveParticipantState<?,?,SNode,SNode>>from(node,participantState);
                  }
                }
);
              }
            }
).toListSequence();
            final SearchResults results=new SearchResults();
            results.addAll(new SearchResults(SetSequence.fromSetAndArray(new HashSet<SNode>(),sourceConcept),ListSequence.fromListAndArray(new ArrayList<SearchResult<SNode>>(),new SearchResult<SNode>(aspect,"concept aspect"))));
            ListSequence.fromList(childparticipantStates).translate(new ITranslator2<Tuples._2<SNode,RecursiveParticipant.RecursiveParticipantState<?,?,SNode,SNode>>,RefactoringParticipant.Change<Object,Object>>(){
              public Iterable<RefactoringParticipant.Change<Object,Object>> translate(              Tuples._2<SNode,RecursiveParticipant.RecursiveParticipantState<?,?,SNode,SNode>> it){
                return ((RefactoringParticipant.ParticipantState)it._1()).getChanges();
              }
            }
).select(new ISelector<RefactoringParticipant.Change<Object,Object>,SearchResults>(){
              public SearchResults select(              RefactoringParticipant.Change<Object,Object> it){
                return it.getSearchResults();
              }
            }
).visitAll(new IVisitor<SearchResults>(){
              public void visit(              SearchResults it){
                results.addAll(it);
              }
            }
);
            RefactoringParticipant.Change<SNodeReference,SNodeReference> change=new RefactoringParticipant.Change<SNodeReference,SNodeReference>(){
              public SearchResults getSearchResults(){
                return results;
              }
              public boolean needsToPreserveOldNode(){
                return ListSequence.fromList(childparticipantStates).translate(new ITranslator2<Tuples._2<SNode,RecursiveParticipant.RecursiveParticipantState<?,?,SNode,SNode>>,RefactoringParticipant.Change<Object,Object>>(){
                  public Iterable<RefactoringParticipant.Change<Object,Object>> translate(                  Tuples._2<SNode,RecursiveParticipant.RecursiveParticipantState<?,?,SNode,SNode>> it){
                    return ((RefactoringParticipant.ParticipantState)it._1()).getChanges();
                  }
                }
).any(new IWhereFilter<RefactoringParticipant.Change<Object,Object>>(){
                  public boolean accept(                  RefactoringParticipant.Change<Object,Object> it){
                    return it.needsToPreserveOldNode();
                  }
                }
);
              }
              public void confirm(              SNodeReference finalState,              final SRepository repository,              final RefactoringSession refactoringSession){
                SNode targetConcept=SNodeOperations.cast(finalState.resolve(repository),MetaAdapterFactory.getConcept(0xc72da2b97cce4447L,0x8389f407dc1158b7L,0x1103553c5ffL,"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration"));
                Language targetLanguage=((Language)SNodeOperations.getModel(targetConcept).getModule());
                NodeLocation.NodeLocationRootWithAspectModelCreation newLocation=new NodeLocation.NodeLocationRootWithAspectModelCreation(targetLanguage,mapping.key());
                List<SNode> copied=MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).copy(ListSequence.fromListAndArray(new ArrayList<SNode>(),aspect),ListSequence.fromListAndArray(new ArrayList<Boolean>(),needsToPreserveOldNode() || MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).whetherKeepNode(sourceConcept)));
                final Map<SNode,SNode> copyMap=MoveNodesDefault.CopyMapObject.getCopyMap(refactoringSession).getCopyMap();
                newLocation.insertNode(repository,ListSequence.fromList(copied).first());
                ListSequence.fromList(childparticipantStates).visitAll(new IVisitor<Tuples._2<SNode,RecursiveParticipant.RecursiveParticipantState<?,?,SNode,SNode>>>(){
                  public void visit(                  Tuples._2<SNode,RecursiveParticipant.RecursiveParticipantState<?,?,SNode,SNode>> pis){
                    pis._1().confirm(MapSequence.fromMap(copyMap).get(pis._0()),repository,refactoringSession);
                  }
                }
);
              }
            }
;
            return (RefactoringParticipant.Change<SNodeReference,SNodeReference>)change;
          }
        }
);
      }
    }
).toListSequence();
  }
}
