{
  HashMap<SNode,SNode> mapping=new HashMap<SNode,SNode>();
  final SNode copy=CopyUtil.copy(Arrays.asList(myParentNode.getContainingRoot()),mapping).get(0);
  getModelForTypechecking().addRootNode(copy);
  final SNode conceptDecl=SModelUtil.getLinkDeclarationTarget(myLinkDeclaration);
  final SAbstractConcept concept=MetaAdapterByDeclaration.getConcept(conceptDecl);
  boolean holeIsAType=concept != null && concept.isSubConceptOf(SNodeUtil.concept_IType);
  SNode parent=mapping.get(myParentNode);
  String role=SModelUtil.getGenuineLinkRole(myLinkDeclaration);
  SNode hole=SModelUtil_new.instantiateConceptDeclaration(SNodeUtil.concept_BaseConcept,null,null,true);
  if (myCurrentChild != null) {
    SNode child=mapping.get(myCurrentChild);
    parent.insertChildBefore(role,hole,child);
    parent.removeChild(child);
  }
 else {
    parent.addChild(role,hole);
  }
  InequalitySystem inequationsForHole=TypeChecker.getInstance().getInequalitiesForHole(hole,holeIsAType);
  inequationsForHole.replaceRefs(mapping);
  return inequationsForHole;
}
