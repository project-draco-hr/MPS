{
  final Wrappers._int _maxErrors=new Wrappers._int(maxErrors);
  final List<Problem> result=ListSequence.fromList(new ArrayList<Problem>());
  Collection<DependencyProblem> badModuleProblems=findBadModules(modules,_maxErrors.value);
  ListSequence.fromList(result).addSequence(CollectionSequence.fromCollection(badModuleProblems));
  _maxErrors.value-=CollectionSequence.fromCollection(badModuleProblems).count();
  if (_maxErrors.value == 0) {
    return result;
  }
  Collection<BinaryModelProblem> badModelProblems=findBinaryModels(modules,_maxErrors.value);
  ListSequence.fromList(result).addSequence(CollectionSequence.fromCollection(badModelProblems));
  _maxErrors.value-=CollectionSequence.fromCollection(badModelProblems).count();
  if (_maxErrors.value == 0) {
    return result;
  }
  if (progressCallback != null) {
    progressCallback.invoke(0.1);
  }
  final Set<SLanguage> missingLangs=SetSequence.fromSet(new HashSet<SLanguage>());
  final Set<SAbstractConcept> missingConcepts=SetSequence.fromSet(new HashSet<SAbstractConcept>());
  final Set<SConceptFeature> missingFeatures=SetSequence.fromSet(new HashSet<SConceptFeature>());
  Iterable<SModel> models=Sequence.fromIterable(modules).translate(new ITranslator2<SModule,SModel>(){
    public Iterable<SModel> translate(    SModule it){
      return it.getModels();
    }
  }
);
  int modelsCount=Sequence.fromIterable(models).count();
  int processedModels=0;
  for (  SModel model : Sequence.fromIterable(models)) {
    ValidationUtil.validateModelContent(model.getRootNodes(),new Processor<ValidationProblem>(){
      public boolean process(      ValidationProblem vp){
        if (vp instanceof LanguageMissingError) {
          LanguageMissingError err=(LanguageMissingError)vp;
          if (SetSequence.fromSet(missingLangs).contains(err.getLanguage())) {
            return true;
          }
          SetSequence.fromSet(missingLangs).addElement(err.getLanguage());
          if (err.isCompletelyAbsent()) {
            ListSequence.fromList(result).addElement(new LanguageAbsentInRepoProblem(err.getLanguage(),err.getNode()));
          }
 else {
            ListSequence.fromList(result).addElement(new LanguageNotLoadedProblem(err.getLanguage(),err.getNode()));
          }
        }
 else         if (vp instanceof ConceptMissingError) {
          ConceptMissingError err=(ConceptMissingError)vp;
          SConcept concept=err.getConcept();
          if (SetSequence.fromSet(missingLangs).contains(concept.getLanguage()) || SetSequence.fromSet(missingConcepts).contains(concept)) {
            return true;
          }
          SetSequence.fromSet(missingConcepts).addElement(concept);
          ListSequence.fromList(result).addElement(new ConceptMissingProblem(concept,err.getNode()));
        }
 else         if (vp instanceof ConceptFeatureMissingError) {
          ConceptFeatureMissingError err=(ConceptFeatureMissingError)vp;
          SAbstractConcept concept=err.getFeature().getOwner();
          if (SetSequence.fromSet(missingLangs).contains(concept.getLanguage()) || SetSequence.fromSet(missingConcepts).contains(concept) || SetSequence.fromSet(missingFeatures).contains(err.getFeature())) {
            return true;
          }
          SetSequence.fromSet(missingFeatures).addElement(err.getFeature());
          ListSequence.fromList(result).addElement(new ConceptFeatureMissingProblem(err.getFeature(),err.getNode(),err.getMessage()));
        }
 else {
        }
        _maxErrors.value--;
        return _maxErrors.value > 0;
      }
    }
);
    if (_maxErrors.value == 0) {
      return result;
    }
    processedModels++;
    if (progressCallback != null) {
      progressCallback.invoke(0.1 + 0.9 * processedModels / modelsCount);
    }
  }
  return result;
}
