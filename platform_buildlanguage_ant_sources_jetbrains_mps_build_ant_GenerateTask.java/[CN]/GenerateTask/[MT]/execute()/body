{
  if (myMpsHome == null) {
    String mpsHomePath=getProject().getProperty("mps.home");
    if (mpsHomePath == null || !new File(mpsHomePath).exists()) {
      throw new BuildException("Path to mps home expected. Specify mps.home property or mpshome attribute.");
    }
    myMpsHome=new File(mpsHomePath);
  }
  File[] pathsToLook;
  if (new File(myMpsHome.getAbsolutePath() + File.separator + "classes").exists()) {
    pathsToLook=new File[]{new File(myMpsHome.getAbsolutePath() + File.separator + "core"),new File(myMpsHome.getAbsolutePath() + File.separator + "lib"),new File(myMpsHome.getAbsolutePath() + File.separator + "platform"+ File.separator+ "buildlanguage"),new File(myMpsHome.getAbsolutePath() + File.separator + "workbench"),new File(myMpsHome.getAbsolutePath() + File.separator + "MPSPlugin"+ File.separator+ "MPSSupport")};
  }
 else {
    pathsToLook=new File[]{new File(myMpsHome.getAbsolutePath() + File.separator + "core"),new File(myMpsHome.getAbsolutePath() + File.separator + "lib"),new File(myMpsHome.getAbsolutePath() + File.separator + "platform"),new File(myMpsHome.getAbsolutePath() + File.separator + "workbench"),new File(myMpsHome.getAbsolutePath() + File.separator + "plugin")};
  }
  Set<File> classPaths=new LinkedHashSet<File>();
  for (  File path : pathsToLook) {
    if (!path.exists() || !path.isDirectory()) {
      throw new BuildException(myMpsHome + " myInputStream invalid MPS home path.");
    }
    gatherAllClassesAndJarsUnder(path,classPaths);
  }
  File mpsClasses=new File(myMpsHome + File.separator + "classes");
  if (mpsClasses.exists()) {
    classPaths.add(mpsClasses);
  }
  if (myUsePropertiesAsMacro) {
    Hashtable properties=getProject().getProperties();
    for (    Object name : properties.keySet()) {
      Object value=properties.get(name);
      myWhatToGenerate.addMacro((String)name,(String)value);
    }
  }
  if (myFork) {
    String currentClassPathString=System.getProperty("java.class.path");
    List<String> commandLine=new ArrayList<String>();
    commandLine.add("java");
    commandLine.add("-Xss1024k");
    commandLine.add("-Xmx512m");
    commandLine.add("-XX:MaxPermSize=92m");
    StringBuffer sb=new StringBuffer();
    String pathSeparator=System.getProperty("path.separator");
    for (    File cp : classPaths) {
      sb.append(pathSeparator);
      sb.append(cp.getAbsolutePath());
    }
    commandLine.add("-classpath");
    commandLine.add(currentClassPathString + sb.toString());
    commandLine.add(Generator.class.getCanonicalName());
    commandLine.add(myWhatToGenerate.toString());
    Execute exe=new Execute(new ExecuteStreamHandler(){
      private Thread myOutputReadingThread;
      private Thread myErrorReadingThread;
      public void setProcessInputStream(      OutputStream os) throws IOException {
      }
      public void setProcessErrorStream(      final InputStream is) throws IOException {
        myErrorReadingThread=new Thread(new Runnable(){
          public void run(){
            Scanner s=new Scanner(is);
            while (s.hasNextLine()) {
              log(s.nextLine(),Project.MSG_ERR);
            }
          }
        }
);
      }
      public void setProcessOutputStream(      final InputStream is) throws IOException {
        myOutputReadingThread=new Thread(new Runnable(){
          public void run(){
            Scanner s=new Scanner(is);
            while (s.hasNextLine()) {
              log(s.nextLine());
            }
          }
        }
);
      }
      public void start() throws IOException {
        myOutputReadingThread.start();
        myErrorReadingThread.start();
      }
      public void stop(){
        try {
          myOutputReadingThread.join();
        }
 catch (        InterruptedException e) {
        }
        try {
          myErrorReadingThread.join();
        }
 catch (        InterruptedException e) {
        }
      }
    }
);
    exe.setAntRun(this.getProject());
    exe.setWorkingDirectory(this.getProject().getBaseDir());
    exe.setCommandline(commandLine.toArray(new String[commandLine.size()]));
    try {
      int i=exe.execute();
      if (i != 0) {
        throw new BuildException("Process exited with code " + i + ".");
      }
    }
 catch (    IOException e) {
      log(e,Project.MSG_ERR);
    }
  }
 else {
    List<URL> classPathUrls=new ArrayList<URL>();
    for (    File path : classPaths) {
      try {
        classPathUrls.add(new URL("file://" + path + (path.isDirectory() ? "/" : "")));
      }
 catch (      MalformedURLException e) {
        throw new BuildException(e);
      }
    }
    URLClassLoader classLoader=new URLClassLoader(classPathUrls.toArray(new URL[classPathUrls.size()]),ProjectComponent.class.getClassLoader());
    try {
      Class<?> whatToGenerateClass=classLoader.loadClass(WhatToGenerate.class.getCanonicalName());
      Object whatToGenerate=whatToGenerateClass.newInstance();
      myWhatToGenerate.cloneTo(whatToGenerate);
      Class<?> generatorClass=classLoader.loadClass(Generator.class.getCanonicalName());
      Constructor<?> constructor=generatorClass.getConstructor(whatToGenerateClass,ProjectComponent.class);
      Object generator=constructor.newInstance(whatToGenerate,this);
      Method method=generatorClass.getMethod("generate");
      method.invoke(generator);
    }
 catch (    ClassNotFoundException e) {
      throw new BuildException(e.getMessage() + "\n" + "Used class path: "+ classPathUrls.toString());
    }
catch (    NoSuchMethodException e) {
      throw new BuildException(e);
    }
catch (    InvocationTargetException e) {
      throw new BuildException(e.getTargetException());
    }
catch (    IllegalAccessException e) {
      throw new BuildException(e);
    }
catch (    InstantiationException e) {
      throw new BuildException(e);
    }
  }
}
