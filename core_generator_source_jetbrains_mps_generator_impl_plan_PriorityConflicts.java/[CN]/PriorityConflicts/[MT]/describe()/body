{
  Map<Kind,String> messageFormats=new HashMap<Kind,String>();
  messageFormats.put(Kind.SelfLock,"Self-locking rule: %s");
  messageFormats.put(Kind.PastTopPri,"Rules left after all top-priority rules were consumed: %s");
  messageFormats.put(Kind.LoPriLocksHiPri,"Configuration with lower priority blocks high-priority configuration: %s");
  messageFormats.put(Kind.CoherentWithStrict,"Coherent configurations on both sides of strict rule: %s");
  messageFormats.put(null,"%s");
  List<Pair<TemplateMappingPriorityRule,String>> rv=new ArrayList<Pair<TemplateMappingPriorityRule,String>>();
  for (  Kind k : Kind.values()) {
    Set<TemplateMappingPriorityRule> rules=myConflictingRules.get(k);
    if (rules.isEmpty()) {
      continue;
    }
    String fmt=messageFormats.get(messageFormats.containsKey(k) ? k : null);
    for (    TemplateMappingPriorityRule r : rules) {
      String msg=String.format(fmt,r.toString());
      rv.add(new Pair<TemplateMappingPriorityRule,String>(r,msg));
    }
  }
  return rv;
}
