{
  myMenuEmpty=false;
  String pattern=getPatternEditor().getPattern();
  List<INodeSubstituteItem> matchingActions=myNodeSubstituteInfo.getMatchingActions(pattern);
  myMenuSubstituteEntries=new LinkedList<INodeSubstituteItem>(matchingActions);
  if (myMenuSubstituteEntries.size() == 0) {
    myMenuEmpty=true;
    myMenuSubstituteEntries.add(new AbstractNodeSubstituteItem(){
      public String getMatchingText(      String pattern){
        return "No variants for \"" + getPatternEditor().getPattern() + "\"";
      }
      public SemanticNode doSubstitute(      String pattern){
        return null;
      }
    }
);
  }
  myStrings=new String[myMenuSubstituteEntries.size()];
  myMatchingStrings=new String[myMenuSubstituteEntries.size()];
  String[] descriptionStrings=new String[myMenuSubstituteEntries.size()];
  int descriptionIndent=2;
  for (int i=0; i < myMenuSubstituteEntries.size(); i++) {
    INodeSubstituteItem entry=myMenuSubstituteEntries.get(i);
    myMatchingStrings[i]=entry.getMatchingText(null);
    if (myMatchingStrings[i] != null) {
      descriptionIndent=Math.max(descriptionIndent,myMatchingStrings[i].length() + 2);
    }
    descriptionStrings[i]=entry.getDescriptionText(null);
  }
  for (int i=0; i < myMenuSubstituteEntries.size(); i++) {
    StringBuffer sb=new StringBuffer();
    int indentSize=descriptionIndent;
    if (myMatchingStrings[i] != null) {
      sb.append(myMatchingStrings[i]);
      indentSize=descriptionIndent - myMatchingStrings[i].length();
    }
    if (descriptionStrings[i] != null) {
      char[] indent=new char[indentSize];
      Arrays.fill(indent,' ');
      sb.append(indent);
      sb.append(descriptionStrings[i]);
    }
    myStrings[i]=sb.toString();
  }
}
