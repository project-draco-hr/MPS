{
  double time=System.currentTimeMillis();
  Map<Edge,Integer> flow=MaxFlow.getFlow(graph,source,target,initialCapacity);
  Map<Edge,Edge> opposite=MapSequence.fromMap(new HashMap<Edge,Edge>());
  final Map<Edge,Integer> capacity=MapSequence.fromMap(new HashMap<Edge,Integer>());
  Set<Edge> dummyEdges=SetSequence.fromSet(new HashSet<Edge>());
  for (  Edge edge : ListSequence.fromList(graph.getEdges())) {
    MapSequence.fromMap(capacity).put(edge,MapSequence.fromMap(initialCapacity).get(edge) - MapSequence.fromMap(flow).get(edge));
    Edge oppositeEdge=graph.connect(edge.getTarget(),edge.getSource());
    MapSequence.fromMap(opposite).put(edge,oppositeEdge);
    MapSequence.fromMap(opposite).put(oppositeEdge,edge);
    MapSequence.fromMap(capacity).put(oppositeEdge,MapSequence.fromMap(flow).get(edge));
    MapSequence.fromMap(cost).put(oppositeEdge,-MapSequence.fromMap(cost).get(edge));
    SetSequence.fromSet(dummyEdges).addElement(oppositeEdge);
  }
  boolean hasNegativeCycle=true;
  while (hasNegativeCycle) {
    FordBellman cycleFinder=new FordBellman(graph,target,cost);
    cycleFinder.doAlgorithm(new _FunctionTypes._return_P1_E0<Boolean,Edge>(){
      public Boolean invoke(      Edge edge){
        return MapSequence.fromMap(capacity).get(edge) > 0;
      }
    }
,Edge.Direction.FRONT);
    List<Edge> cycle=cycleFinder.getNegativeCycleReachableFromSource();
    if (cycle == null) {
      hasNegativeCycle=false;
    }
 else {
      int minCapacity=Integer.MAX_VALUE;
      for (      Edge edge : ListSequence.fromList(cycle)) {
        minCapacity=Math.min(minCapacity,MapSequence.fromMap(capacity).get(edge));
      }
      for (      Edge edge : ListSequence.fromList(cycle)) {
        if (SetSequence.fromSet(dummyEdges).contains(edge)) {
          Edge realEdge=MapSequence.fromMap(opposite).get(edge);
          MapSequence.fromMap(flow).put(realEdge,MapSequence.fromMap(flow).get(realEdge) - minCapacity);
          MapSequence.fromMap(capacity).put(realEdge,MapSequence.fromMap(capacity).get(realEdge) + minCapacity);
          MapSequence.fromMap(capacity).put(edge,MapSequence.fromMap(flow).get(realEdge));
        }
 else {
          MapSequence.fromMap(flow).put(edge,MapSequence.fromMap(flow).get(edge) + minCapacity);
          MapSequence.fromMap(capacity).put(edge,MapSequence.fromMap(capacity).get(edge) - minCapacity);
          MapSequence.fromMap(capacity).put(MapSequence.fromMap(opposite).get(edge),MapSequence.fromMap(flow).get(edge));
        }
      }
    }
  }
  for (  Edge edge : SetSequence.fromSet(dummyEdges)) {
    graph.removeEdge(edge);
  }
  if (SHOW_TIME > 0) {
    System.out.println("Min cost max flow algorithm on network with " + ListSequence.fromList(graph.getNodes()).count() + " nodes and "+ ListSequence.fromList(graph.getEdges()).count()+ " edges");
    System.out.println("working time is " + ((System.currentTimeMillis() - time) / 1000) + " seconds");
  }
  return flow;
}
