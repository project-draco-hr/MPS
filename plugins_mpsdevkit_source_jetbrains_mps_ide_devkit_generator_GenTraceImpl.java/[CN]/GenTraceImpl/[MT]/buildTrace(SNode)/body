{
  Phase ph=findPhaseForInput(inputNode);
  if (ph == null) {
    return Collections.emptyList();
  }
  final MPSModuleRepository modelRepository=MPSModuleRepository.getInstance();
  ArrayList<TraceNodeUI> rv=new ArrayList<TraceNodeUI>();
  ArrayList<SNodeId> input=new ArrayList<SNodeId>();
  input.add(inputNode.getNodeId());
  do {
    TraceNodeUI phaseNode=new TraceNodeUI(String.format("Phase %s->%s",ph.input.getModelName(),ph.output.getModelName()),Icons.COLLECTION,null);
    LinkedHashSet<SNodeId> nextInputs=new LinkedHashSet<SNodeId>();
    for (    SNodeId nid : input) {
      SNode in=new SNodePointer(ph.input,nid).resolve(modelRepository);
      if (in == null) {
        continue;
      }
      Element[] changes=ph.findByInputAncestors(in);
      List<TraceNodeUI> uiNodes=new ArrayList<TraceNodeUI>(5);
      if (changes == null) {
        SNodeReference o=new SNodePointer(ph.output,nid);
        if (o.resolve(modelRepository) != null) {
          TraceNodeUI n=new TraceNodeUI(Kind.COPY_OPERATION,null);
          n.addChild(new TraceNodeUI(Kind.OUTPUT,o));
          uiNodes.add(n);
          nextInputs.add(nid);
        }
      }
 else {
        MultiMap<SNodeId,TraceNodeUI> outputs=new MultiMap<SNodeId,TraceNodeUI>();
        for (        Element e : changes) {
          outputs.putValue(e.output,new TraceNodeUI(Kind.TEMPLATE,e.template));
          nextInputs.add(e.output);
        }
        for (        SNodeId e : outputs.keySet()) {
          TraceNodeUI out=new TraceNodeUI(Kind.OUTPUT,new SNodePointer(ph.output,e));
          for (          TraceNodeUI n : outputs.get(e)) {
            out.addChild(n);
          }
          uiNodes.add(out);
        }
      }
      TraceNodeUI top=new TraceNodeUI(Kind.INPUT,in.getReference());
      for (      TraceNodeUI n : uiNodes) {
        top.addChild(n);
      }
      phaseNode.addChild(top);
    }
    if (phaseNode.getChildren().iterator().hasNext()) {
      rv.add(phaseNode);
    }
    input.clear();
    input.addAll(nextInputs);
    ph=ph.next;
  }
 while (ph != null && !input.isEmpty());
  return rv;
}
