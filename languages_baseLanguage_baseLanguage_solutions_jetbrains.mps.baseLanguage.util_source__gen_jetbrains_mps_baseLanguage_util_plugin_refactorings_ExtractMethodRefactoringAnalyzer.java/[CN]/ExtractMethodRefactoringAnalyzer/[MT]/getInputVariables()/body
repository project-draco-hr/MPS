{
  Map<SNode,MethodParameter> result=MapSequence.fromMap(new LinkedHashMap<SNode,MethodParameter>(16,(float)0.75,false));
  this.addDataflowParameters(result);
  addExternalParameters(result);
  for (  SNode node : ListSequence.fromList(this.myPartToExtract)) {
    for (    SNode parameter : ListSequence.fromList(SNodeOperations.getNodeDescendants(node,MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0x11d486a1d9eL,"jetbrains.mps.baseLanguage.structure.IParameter"),true,new SAbstractConcept[]{}))) {
      SNode expressionType=TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(parameter),HUtil.createMatchingPatternByConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0xf8c37f506dL,"jetbrains.mps.baseLanguage.structure.Type")),true);
      MapSequence.fromMap(result).put(((SNode)BHReflection.invoke(parameter,SMethodTrimmedId.create("getDeclaration",null,"hP8xjWn"))),new MethodParameter(((SNode)BHReflection.invoke(parameter,SMethodTrimmedId.create("getDeclaration",null,"hP8xjWn"))),expressionType,((String)BHReflection.invoke(parameter,SMethodTrimmedId.create("getParameterName",null,"hP8qAbK"))),parameter));
    }
  }
  return ListSequence.fromListWithValues(new ArrayList<MethodParameter>(),MapSequence.fromMap(result).values());
}
