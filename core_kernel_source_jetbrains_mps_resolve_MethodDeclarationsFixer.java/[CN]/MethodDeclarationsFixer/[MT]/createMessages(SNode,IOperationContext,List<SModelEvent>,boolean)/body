{
  if (DISABLED) {
    return new HashSet<EditorMessage>();
  }
  final Map<SNode,SNode> reResolvedTargets=new HashMap<SNode,SNode>();
  if (!wasCheckedOnce) {
    for (    SNode methodCall : rootNode.getDescendants(new IsInstanceCondition(IMethodCall.concept))) {
      testAndFixMethodCall(methodCall,reResolvedTargets);
    }
  }
 else {
    Set<SNode> expressionsWithChangedTypes;
synchronized (myRecalculatedTypesLock) {
      expressionsWithChangedTypes=new HashSet<SNode>(myCurrentExpressionsWithChangedTypes);
      myCurrentExpressionsWithChangedTypes.clear();
    }
    SModelEventVisitor visitor=new SModelEventVisitorAdapter(){
      public void visitChildEvent(      SModelChildEvent event){
        SNode child=event.getChild();
        if (event.isAdded()) {
          nodeAdded(child,reResolvedTargets);
        }
 else {
          nodeRemoved(child,event.getParent(),reResolvedTargets);
        }
      }
      public void visitReferenceEvent(      SModelReferenceEvent event){
        SReference reference=event.getReference();
        SNode sourceNode=reference.getSourceNode();
        if (SNodeOperations.isInstanceOf(sourceNode,IMethodCall.concept) && IMethodCall.BASE_METHOD_DECLARATION.equals(reference.getRole())) {
          methodCallDeclarationChanged(sourceNode,reResolvedTargets);
        }
      }
      public void visitPropertyEvent(      SModelPropertyEvent event){
        SNode node=event.getNode();
        if (SNodeOperations.isInstanceOf(node,BaseMethodDeclaration.concept)) {
          if (BaseMethodDeclaration.NAME.equals(event.getPropertyName())) {
            methodDeclarationNameChanged(node,reResolvedTargets);
            methodDeclarationSignatureChanged(node,reResolvedTargets);
          }
        }
      }
    }
;
    for (    SModelEvent event : events) {
      if (event.getAffectedRoot() != rootNode) {
        continue;
      }
      event.accept(visitor);
    }
    for (    SNode expressionWithChangedType : expressionsWithChangedTypes) {
      expressionTypeChanged(expressionWithChangedType,reResolvedTargets);
    }
  }
  ThreadUtils.runInUIThreadNoWait(new Runnable(){
    public void run(){
      if (reResolvedTargets.isEmpty())       return;
      ModelAccess.instance().runWriteActionInCommand(new Runnable(){
        public void run(){
          CommandProcessor.getInstance().runUndoTransparentAction(new Runnable(){
            public void run(){
              for (              SNode methodCall : reResolvedTargets.keySet()) {
                SNode referent=reResolvedTargets.get(methodCall);
                if (referent != null && !referent.shouldHaveBeenDisposed()) {
                  methodCall.setReferent(IMethodCall.BASE_METHOD_DECLARATION,referent);
                }
              }
            }
          }
);
        }
      }
);
    }
  }
);
  return new HashSet<EditorMessage>();
}
