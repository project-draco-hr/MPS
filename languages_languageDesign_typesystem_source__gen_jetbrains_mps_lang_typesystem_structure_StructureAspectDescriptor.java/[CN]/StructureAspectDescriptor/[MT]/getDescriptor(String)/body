{
switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0b,conceptFqName)) {
case 0:
    return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.AbstractCheckingRule","jetbrains.mps.lang.typesystem.structure.AbstractRule",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractRule"},new String[]{"overrides"},new String[]{},new String[]{"body"},new boolean[]{false});
case 1:
  return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.AbstractComparableStatement","jetbrains.mps.lang.typesystem.structure.AbstractEquationStatement",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractEquationStatement"},new String[]{"infer"},new String[]{},new String[]{},new boolean[]{});
case 2:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.AbstractEquationStatement","jetbrains.mps.baseLanguage.structure.Statement",false,new String[]{"jetbrains.mps.baseLanguage.structure.Statement"},new String[]{"checkOnly"},new String[]{},new String[]{"leftExpression","rightExpression","nodeToCheck","errorString","helginsIntention"},new boolean[]{false,false,false,false,true});
case 3:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement","jetbrains.mps.lang.typesystem.structure.AbstractEquationStatement",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractEquationStatement"},new String[]{"inequationPriority","label","strong","orientation"},new String[]{},new String[]{"afterEquations","beforeEquations","afterGroups","beforeGroups","inequationGroup","rulesToSkip"},new boolean[]{true,true,true,true,false,true});
case 4:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.AbstractOverloadedOpsTypeRule","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{},new String[]{"operationConcept","function","isApplicable"},new boolean[]{true,false,false});
case 5:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.AbstractRule","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.baseLanguage.structure.IValidIdentifier","jetbrains.mps.lang.structure.structure.IConceptAspect"},new String[]{},new String[]{},new String[]{"applicableNode"},new boolean[]{false});
case 6:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.AbstractSubtypingRule","jetbrains.mps.lang.typesystem.structure.AbstractRule",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractRule","jetbrains.mps.baseLanguage.structure.IMethodLike"},new String[]{"isWeak"},new String[]{},new String[]{"body"},new boolean[]{false});
case 7:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.AddDependencyStatement","jetbrains.mps.baseLanguage.structure.Statement",false,new String[]{"jetbrains.mps.baseLanguage.structure.Statement"},new String[]{},new String[]{},new String[]{"dependency"},new boolean[]{false});
case 8:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ApplicableNodeCondition","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.lang.core.structure.INamedConcept"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 9:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ApplicableNodeReference","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression"},new String[]{},new String[]{"applicableNode"},new String[]{},new boolean[]{});
case 10:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.AssertStatement","jetbrains.mps.lang.typesystem.structure.ReportErrorStatement",false,new String[]{"jetbrains.mps.lang.typesystem.structure.ReportErrorStatement"},new String[]{},new String[]{},new String[]{"condition"},new boolean[]{false});
case 11:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.CaretPositionOperation","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.baseLanguage.structure.IOperation"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 12:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.CoerceExpression","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression"},new String[]{"strong"},new String[]{},new String[]{"pattern","nodeToCoerce"},new boolean[]{false,false});
case 13:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.CoerceStatement","jetbrains.mps.baseLanguage.structure.Statement",false,new String[]{"jetbrains.mps.baseLanguage.structure.Statement"},new String[]{"strong"},new String[]{},new String[]{"pattern","nodeToCoerce","body","elseClause"},new boolean[]{false,false,false,false});
case 14:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.CoerceStrongExpression","jetbrains.mps.lang.typesystem.structure.CoerceExpression",false,new String[]{"jetbrains.mps.lang.typesystem.structure.CoerceExpression"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 15:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ComparisonRule","jetbrains.mps.lang.typesystem.structure.AbstractSubtypingRule",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractSubtypingRule","jetbrains.mps.lang.typesystem.structure.IRuleWithTwoNodes"},new String[]{},new String[]{},new String[]{"anotherNode"},new boolean[]{false});
case 16:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ConceptClauseLinkInfo","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{"linkDeclaration"},new String[]{"targetNode","childIndex"},new boolean[]{false,false});
case 17:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_BlockingComputationNode","jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 18:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_ContextNode","jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 19:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_DependentComputationNode","jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 20:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_EditorContext","jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 21:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_Role","jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 22:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_Selection","jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 23:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_isAggregation","jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 24:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_node","jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 25:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ConceptFunctionParameter_var","jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 26:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ConceptReference","jetbrains.mps.lang.typesystem.structure.ApplicableNodeCondition",false,new String[]{"jetbrains.mps.lang.typesystem.structure.ApplicableNodeCondition"},new String[]{},new String[]{"concept"},new String[]{},new boolean[]{});
case 27:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ConceptTypeClause","jetbrains.mps.lang.typesystem.structure.TypeClause",false,new String[]{"jetbrains.mps.lang.typesystem.structure.TypeClause"},new String[]{},new String[]{"matchingConcept"},new String[]{"linkInfo"},new boolean[]{true});
case 28:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.CreateComparableEquationStatement","jetbrains.mps.lang.typesystem.structure.AbstractComparableStatement",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractComparableStatement"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 29:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.CreateComparableEquationStatementStrong","jetbrains.mps.lang.typesystem.structure.AbstractComparableStatement",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractComparableStatement"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 30:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.CreateEquationStatement","jetbrains.mps.lang.typesystem.structure.AbstractEquationStatement",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractEquationStatement"},new String[]{"direction"},new String[]{},new String[]{},new boolean[]{});
case 31:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.CreateGreaterThanInequationStatement","jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 32:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.CreateLessThanInequationStatement","jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 33:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.CreateStrongGreaterThanInequationStatement","jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 34:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.CreateStrongLessThanInequationStatement","jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractInequationStatement"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 35:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.DefaultGroupReference","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 36:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.Dependency","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{"targetConcept","sourceConcept"},new String[]{"findSourceBlock"},new boolean[]{false});
case 37:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.DependentComputationItem","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.lang.core.structure.INamedConcept"},new String[]{},new String[]{"applicableConcept","blockingNodeConcept"},new String[]{"findMasterBlock","isApplicableBlock","isBlockingBlock"},new boolean[]{false,false,false});
case 38:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.DependentComputationItem_ApplicableBlock","jetbrains.mps.baseLanguage.structure.ConceptFunction",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunction"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 39:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.DependentComputationItem_BlockingBlock","jetbrains.mps.baseLanguage.structure.ConceptFunction",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunction"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 40:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.DependentComputationItem_FindMasterBlock","jetbrains.mps.baseLanguage.structure.ConceptFunction",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunction"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 41:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ErrorInfoExpression","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 42:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.FindSourceBlock","jetbrains.mps.baseLanguage.structure.ConceptFunction",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunction"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 43:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.FindSourceBlockParameter","jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 44:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.GetOperationType","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression"},new String[]{},new String[]{},new String[]{"operation","leftOperandType","rightOperandType"},new boolean[]{false,false,false});
case 45:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.IRuleWithOneNode",null,true,new String[]{},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 46:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.IRuleWithTwoNodes",null,true,new String[]{},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 47:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ImmediateSupertypesExpression","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression"},new String[]{},new String[]{},new String[]{"subtypeExpression"},new boolean[]{false});
case 48:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.InequationReference","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{"inequation"},new String[]{},new boolean[]{});
case 49:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.InequationReplacementRule","jetbrains.mps.lang.typesystem.structure.AbstractSubtypingRule",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractSubtypingRule","jetbrains.mps.lang.typesystem.structure.IRuleWithTwoNodes"},new String[]{},new String[]{},new String[]{"supertypeNode","isApplicableClause"},new boolean[]{false,false});
case 50:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.InferenceRule","jetbrains.mps.lang.typesystem.structure.AbstractCheckingRule",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractCheckingRule","jetbrains.mps.lang.typesystem.structure.IRuleWithOneNode"},new String[]{},new String[]{},new String[]{"dependency"},new boolean[]{true});
case 51:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.InfoStatement","jetbrains.mps.baseLanguage.structure.Statement",false,new String[]{"jetbrains.mps.baseLanguage.structure.Statement","jetbrains.mps.lang.typesystem.structure.MessageStatement"},new String[]{},new String[]{},new String[]{"infoText"},new boolean[]{false});
case 52:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.IsReplacementRuleApplicable_ConceptFunction","jetbrains.mps.baseLanguage.structure.ConceptFunction",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunction"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 53:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.IsStrongSubtypeExpression","jetbrains.mps.lang.typesystem.structure.IsSubtypeExpression",false,new String[]{"jetbrains.mps.lang.typesystem.structure.IsSubtypeExpression"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 54:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.IsSubtypeExpression","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression"},new String[]{},new String[]{},new String[]{"subtypeExpression","supertypeExpression"},new boolean[]{false,false});
case 55:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.JoinContainer","jetbrains.mps.lang.core.structure.NodeAttribute",false,new String[]{"jetbrains.mps.lang.core.structure.NodeAttribute","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{"joinType"},new boolean[]{false});
case 56:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.JoinType","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.lang.core.structure.IType","jetbrains.mps.baseLanguage.structure.IGenericType"},new String[]{},new String[]{},new String[]{"argument"},new boolean[]{true});
case 57:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.LeftOperandType_parameter","jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 58:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.LinkPatternVariableReference","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression"},new String[]{},new String[]{"patternVarDecl"},new String[]{},new boolean[]{});
case 59:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ListVarDeclaration","jetbrains.mps.baseLanguage.structure.Statement",false,new String[]{"jetbrains.mps.baseLanguage.structure.Statement","jetbrains.mps.lang.core.structure.INamedConcept"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 60:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.MatchStatement","jetbrains.mps.baseLanguage.structure.Statement",false,new String[]{"jetbrains.mps.baseLanguage.structure.Statement"},new String[]{},new String[]{},new String[]{"expression","item","ifFalseStatement"},new boolean[]{false,true,false});
case 61:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.MatchStatementItem","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{},new String[]{"condition","ifTrue"},new boolean[]{false,false});
case 62:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.MeetContainer","jetbrains.mps.lang.core.structure.NodeAttribute",false,new String[]{"jetbrains.mps.lang.core.structure.NodeAttribute","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{"meetType"},new boolean[]{false});
case 63:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.MeetType","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.lang.core.structure.IType","jetbrains.mps.baseLanguage.structure.IGenericType"},new String[]{},new String[]{},new String[]{"argument"},new boolean[]{true});
case 64:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.MessageStatement",null,true,new String[]{},new String[]{},new String[]{},new String[]{"nodeToReport","helginsIntention","messageTarget","foreignMessageSource"},new boolean[]{false,true,false,false});
case 65:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.MessageTarget","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 66:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.MultipleForeachLoop","jetbrains.mps.baseLanguage.structure.AbstractLoopStatement",false,new String[]{"jetbrains.mps.baseLanguage.structure.AbstractLoopStatement"},new String[]{},new String[]{},new String[]{"loopVariable"},new boolean[]{true});
case 67:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.MultipleForeachLoopVariable","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{},new String[]{"variable","iterable"},new boolean[]{false,false});
case 68:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.NodeInfo","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{"modelId","nodeId"},new String[]{},new String[]{},new boolean[]{});
case 69:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.Node_InferTypeOperation","jetbrains.mps.lang.smodel.structure.SNodeOperation",false,new String[]{"jetbrains.mps.lang.smodel.structure.SNodeOperation","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 70:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.Node_TypeOperation","jetbrains.mps.lang.smodel.structure.SNodeOperation",false,new String[]{"jetbrains.mps.lang.smodel.structure.SNodeOperation","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 71:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.NonTypesystemRule","jetbrains.mps.lang.typesystem.structure.AbstractCheckingRule",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractCheckingRule","jetbrains.mps.lang.typesystem.structure.IRuleWithOneNode"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 72:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.NormalTypeClause","jetbrains.mps.lang.typesystem.structure.TypeClause",false,new String[]{"jetbrains.mps.lang.typesystem.structure.TypeClause"},new String[]{},new String[]{},new String[]{"normalType"},new boolean[]{false});
case 73:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.OperationContextExpression","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 74:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.Operation_parameter","jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 75:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.OrStatement","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{},new String[]{"orClause"},new boolean[]{true});
case 76:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.OriginalNodeId","jetbrains.mps.lang.core.structure.NodeAttribute",false,new String[]{"jetbrains.mps.lang.core.structure.NodeAttribute"},new String[]{"nodeId","modelId"},new String[]{},new String[]{},new boolean[]{});
case 77:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.OverloadedOpIsApplicableFunction","jetbrains.mps.baseLanguage.structure.ConceptFunction",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunction"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 78:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.OverloadedOpRulesContainer","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.lang.core.structure.INamedConcept"},new String[]{},new String[]{},new String[]{"rule"},new boolean[]{true});
case 79:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.OverloadedOpTypeRule_OneTypeSpecified","jetbrains.mps.lang.typesystem.structure.AbstractOverloadedOpsTypeRule",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractOverloadedOpsTypeRule"},new String[]{"isExact","isStrong"},new String[]{},new String[]{"operandType"},new boolean[]{false});
case 80:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.OverloadedOperatorTypeFunction","jetbrains.mps.baseLanguage.structure.ConceptFunction",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunction"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 81:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.OverloadedOperatorTypeRule","jetbrains.mps.lang.typesystem.structure.AbstractOverloadedOpsTypeRule",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractOverloadedOpsTypeRule"},new String[]{"leftIsExact","rightIsExact","rightIsStrong","leftIsStrong"},new String[]{},new String[]{"leftOperandType","rightOperandType"},new boolean[]{false,false});
case 82:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.PatternCondition","jetbrains.mps.lang.typesystem.structure.ApplicableNodeCondition",false,new String[]{"jetbrains.mps.lang.typesystem.structure.ApplicableNodeCondition"},new String[]{},new String[]{},new String[]{"pattern"},new boolean[]{false});
case 83:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.PatternVariableReference","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression"},new String[]{},new String[]{"patternVarDecl"},new String[]{},new boolean[]{});
case 84:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.PrintToTrace","jetbrains.mps.baseLanguage.structure.Statement",false,new String[]{"jetbrains.mps.baseLanguage.structure.Statement"},new String[]{},new String[]{},new String[]{"message"},new boolean[]{false});
case 85:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.Processed","jetbrains.mps.lang.core.structure.NodeAttribute",false,new String[]{"jetbrains.mps.lang.core.structure.NodeAttribute"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 86:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.PropertyMessageTarget","jetbrains.mps.lang.typesystem.structure.MessageTarget",false,new String[]{"jetbrains.mps.lang.typesystem.structure.MessageTarget"},new String[]{},new String[]{"propertyDeclaration"},new String[]{},new boolean[]{});
case 87:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.PropertyNameTarget","jetbrains.mps.lang.typesystem.structure.MessageTarget",false,new String[]{"jetbrains.mps.lang.typesystem.structure.MessageTarget"},new String[]{},new String[]{},new String[]{"propertyName"},new boolean[]{false});
case 88:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.PropertyPatternVariableReference","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression"},new String[]{},new String[]{"patternVarDecl"},new String[]{},new boolean[]{});
case 89:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.QuickFixArgument","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.lang.core.structure.INamedConcept"},new String[]{},new String[]{},new String[]{"argumentType"},new boolean[]{false});
case 90:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.QuickFixArgumentReference","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression"},new String[]{},new String[]{"quickFixArgument"},new String[]{},new boolean[]{});
case 91:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.QuickFixDescriptionBlock","jetbrains.mps.baseLanguage.structure.ConceptFunction",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunction"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 92:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.QuickFixExecuteBlock","jetbrains.mps.baseLanguage.structure.ConceptFunction",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunction"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 93:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.QuickFixField","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.lang.core.structure.INamedConcept"},new String[]{},new String[]{},new String[]{"fieldType"},new boolean[]{false});
case 94:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.QuickFixFieldReference","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression"},new String[]{},new String[]{"quickFixField"},new String[]{},new boolean[]{});
case 95:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.QuickFixSetSelectionBlock","jetbrains.mps.baseLanguage.structure.ConceptFunction",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunction"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 96:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ReferenceMessageTarget","jetbrains.mps.lang.typesystem.structure.MessageTarget",false,new String[]{"jetbrains.mps.lang.typesystem.structure.MessageTarget"},new String[]{},new String[]{"linkDeclaration"},new String[]{},new boolean[]{});
case 97:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ReferenceRoleTarget","jetbrains.mps.lang.typesystem.structure.MessageTarget",false,new String[]{"jetbrains.mps.lang.typesystem.structure.MessageTarget"},new String[]{},new String[]{},new String[]{"referenceRole"},new boolean[]{false});
case 98:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ReplacementRuleReference","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{"fqName"},new String[]{"replacementRule"},new String[]{},new boolean[]{});
case 99:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.ReportErrorStatement","jetbrains.mps.baseLanguage.structure.Statement",false,new String[]{"jetbrains.mps.baseLanguage.structure.Statement","jetbrains.mps.lang.typesystem.structure.MessageStatement"},new String[]{},new String[]{},new String[]{"errorString"},new boolean[]{false});
case 100:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.RightOperandType_parameter","jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter","jetbrains.mps.lang.core.structure.IDontSubstituteByDefault"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 101:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.RuntimeErrorType","jetbrains.mps.lang.typesystem.structure.RuntimeTypeVariable",false,new String[]{"jetbrains.mps.lang.typesystem.structure.RuntimeTypeVariable"},new String[]{"errorText","nodeId","nodeModel"},new String[]{},new String[]{},new boolean[]{});
case 102:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.RuntimeHoleType","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 103:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.RuntimeListVariable","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.lang.core.structure.INamedConcept"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 104:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.RuntimeTypeVariable","jetbrains.mps.baseLanguage.structure.Type",false,new String[]{"jetbrains.mps.baseLanguage.structure.Type","jetbrains.mps.lang.core.structure.INamedConcept"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 105:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.SelectionType","jetbrains.mps.baseLanguage.structure.Type",false,new String[]{"jetbrains.mps.baseLanguage.structure.Type"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 106:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.SubtypingRule","jetbrains.mps.lang.typesystem.structure.AbstractSubtypingRule",false,new String[]{"jetbrains.mps.lang.typesystem.structure.AbstractSubtypingRule","jetbrains.mps.lang.typesystem.structure.IRuleWithOneNode"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 107:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.TypeCheckerAccessExpression","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 108:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.TypeClause","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 109:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.TypeOfExpression","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression"},new String[]{"skipDependencyOnCurrent"},new String[]{},new String[]{"term"},new boolean[]{false});
case 110:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.TypeVarDeclaration","jetbrains.mps.baseLanguage.structure.Statement",false,new String[]{"jetbrains.mps.baseLanguage.structure.Statement","jetbrains.mps.lang.core.structure.INamedConcept"},new String[]{"nullable"},new String[]{},new String[]{},new boolean[]{});
case 111:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.TypeVarReference","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression"},new String[]{},new String[]{"typeVarDeclaration"},new String[]{},new boolean[]{});
case 112:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.TypesystemIntention","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{"applyImmediately"},new String[]{"quickFix"},new String[]{"actualArgument"},new boolean[]{true});
case 113:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.TypesystemIntentionArgument","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{"quickFixArgument"},new String[]{"value"},new boolean[]{false});
case 114:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.TypesystemQuickFix","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.baseLanguage.structure.IValidIdentifier"},new String[]{},new String[]{},new String[]{"executeBlock","descriptionBlock","setSelectionBlock","quickFixArgument","quickFixField"},new boolean[]{false,false,false,true,true});
case 115:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.VariableConverterItem","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{},new String[]{"applicableBlock","convertBlock"},new boolean[]{false,false});
case 116:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.VariableConverterItem_ApplicableBlock","jetbrains.mps.baseLanguage.structure.ConceptFunction",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunction"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 117:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.VariableConverterItem_ConvertBlock","jetbrains.mps.baseLanguage.structure.ConceptFunction",false,new String[]{"jetbrains.mps.baseLanguage.structure.ConceptFunction"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 118:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.VariableConvertersContainer","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept"},new String[]{},new String[]{},new String[]{"converterItem"},new boolean[]{true});
case 119:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.WarningStatement","jetbrains.mps.baseLanguage.structure.Statement",false,new String[]{"jetbrains.mps.baseLanguage.structure.Statement","jetbrains.mps.lang.typesystem.structure.MessageStatement"},new String[]{},new String[]{},new String[]{"warningText"},new boolean[]{false});
case 120:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.WasSelectedNodeOperation","jetbrains.mps.lang.core.structure.BaseConcept",false,new String[]{"jetbrains.mps.lang.core.structure.BaseConcept","jetbrains.mps.baseLanguage.structure.IOperation"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 121:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.WhenConcreteStatement","jetbrains.mps.baseLanguage.structure.Statement",false,new String[]{"jetbrains.mps.baseLanguage.structure.Statement","jetbrains.mps.baseLanguage.structure.Closureoid","jetbrains.mps.baseLanguage.structure.IControlFlowInterrupter"},new String[]{"isShallow","skipsError"},new String[]{},new String[]{"body","argument","argumentRepresentator"},new boolean[]{false,false,false});
case 122:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.WhenConcreteVariableDeclaration","jetbrains.mps.baseLanguage.structure.VariableDeclaration",false,new String[]{"jetbrains.mps.baseLanguage.structure.VariableDeclaration"},new String[]{},new String[]{},new String[]{},new boolean[]{});
case 123:
return new CompiledConceptDescriptor("jetbrains.mps.lang.typesystem.structure.WhenConcreteVariableReference","jetbrains.mps.baseLanguage.structure.Expression",false,new String[]{"jetbrains.mps.baseLanguage.structure.Expression"},new String[]{},new String[]{"whenConcreteVar"},new String[]{},new boolean[]{});
default :
return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);
}
}
