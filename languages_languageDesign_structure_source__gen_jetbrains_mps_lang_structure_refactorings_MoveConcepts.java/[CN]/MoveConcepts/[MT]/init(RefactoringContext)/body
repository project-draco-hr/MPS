{
  final Wrappers._boolean canRefactor=new Wrappers._boolean(false);
  final Wrappers._boolean hasGenerator=new Wrappers._boolean(false);
  ModelAccess.instance().runReadAction(new Runnable(){
    public void run(){
      final SModel model=SNodeOperations.getModel(ListSequence.fromList(refactoringContext.getSelectedNodes()).first());
      refactoringContext.setParameter("sourceModel",model.getModelDescriptor());
      refactoringContext.setParameter("sourceLanguage",Language.getLanguageFor(((SModelDescriptor)refactoringContext.getParameter("sourceModel"))));
      canRefactor.value=ListSequence.fromList(refactoringContext.getSelectedNodes()).all(new IWhereFilter<SNode>(){
        public boolean accept(        SNode node){
          return SNodeOperations.getModel(node) == model;
        }
      }
);
      hasGenerator.value=ListSequence.fromList(refactoringContext.getSelectedNodes()).any(new IWhereFilter<SNode>(){
        public boolean accept(        SNode node){
          return ListSequence.fromList(AbstractConceptDeclaration_Behavior.call_findGeneratorFragments_6409339300305625383(node)).isNotEmpty();
        }
      }
);
    }
  }
);
  if (!(canRefactor.value)) {
    Messages.showErrorDialog("All concept should be from the same language.","Move concepts");
    return false;
  }
  if (hasGenerator.value) {
    Messages.showWarningDialog("Generator fragments will not be moved.","Move concepts");
  }
  return MoveConcepts.this.ask(refactoringContext,MPSChooserFactory.createModelChooser(refactoringContext,"targetModel",new MoveConcepts_targetModel_Settings(refactoringContext)));
}
