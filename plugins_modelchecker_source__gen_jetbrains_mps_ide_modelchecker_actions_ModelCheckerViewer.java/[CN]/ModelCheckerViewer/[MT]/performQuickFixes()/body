{
  int dialogAnswer=Messages.showYesNoDialog(myOperationContext.getProject(),"You are going to remove undeclared properties, children from nodes and resolve references. " + "You may not be able to undo it. Are you sure?","Warning",null);
  if (dialogAnswer != 0) {
    return;
  }
  final Wrappers._int fixedTotal=new Wrappers._int(0);
  ModelAccess.instance().runWriteActionInCommand(new Runnable(){
    public void run(){
      final Set<SNodePointer> includedResultNodes=SetSequence.fromSetWithValues(new HashSet<SNodePointer>(),myUsagesView.getIncludedResultNodes());
      List<ModelCheckerIssue> issuesToFix=ListSequence.fromList(((List<SearchResult<ModelCheckerIssue>>)getSearchResults().getSearchResults())).<ModelCheckerIssue>select(new ISelector<SearchResult<ModelCheckerIssue>,ModelCheckerIssue>(){
        public ModelCheckerIssue select(        SearchResult<ModelCheckerIssue> sr){
          return sr.getObject();
        }
      }
).where(new IWhereFilter<ModelCheckerIssue>(){
        public boolean accept(        ModelCheckerIssue sr){
          return sr instanceof ModelCheckerIssue.NodeIssue && SetSequence.fromSet(includedResultNodes).contains(new SNodePointer(((ModelCheckerIssue.NodeIssue)sr).getNode())) && sr.isFixable();
        }
      }
).toListSequence();
      while (true) {
        int fixedBefore=fixedTotal.value;
        for (        ModelCheckerIssue issue : ListSequence.fromListWithValues(new ArrayList<ModelCheckerIssue>(),issuesToFix)) {
          if (issue.fix()) {
            fixedTotal.value++;
            ListSequence.fromList(issuesToFix).removeElement(issue);
          }
        }
        if (fixedBefore == fixedTotal.value) {
          break;
        }
      }
    }
  }
);
  if (fixedTotal.value != 0) {
    int dialogAnswer1=Messages.showYesNoDialog(myOperationContext.getProject(),"Model checker fixed " + fixedTotal.value + " issues. Do you wish to recheck?","Recheck",null);
    if (dialogAnswer1 != 0) {
      return;
    }
    runCheck();
  }
}
