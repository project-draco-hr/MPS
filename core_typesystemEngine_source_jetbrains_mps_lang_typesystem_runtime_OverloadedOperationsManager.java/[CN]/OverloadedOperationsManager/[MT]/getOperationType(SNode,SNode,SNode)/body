{
  Set<IOverloadedOpsTypesProvider> operationsTypesProviderSet;
synchronized (RulesManager.RULES_LOCK) {
    operationsTypesProviderSet=myOperationsToTypeProviders.getRules(operation);
  }
  if (operationsTypesProviderSet.isEmpty()) {
    return null;
  }
  SubtypingManager subtypingManager=myTypeChecker.getSubtypingManager();
  List<IOverloadedOpsTypesProvider> filteredProviders=new ArrayList<IOverloadedOpsTypesProvider>();
  for (  IOverloadedOpsTypesProvider provider : operationsTypesProviderSet) {
    if (provider.isApplicable(subtypingManager,operation,leftOperandType,rightOperandType)) {
      filteredProviders.add(provider);
    }
  }
  final boolean[] severalRules=new boolean[]{false};
  Collections.sort(filteredProviders,new Comparator<IOverloadedOpsTypesProvider>(){
    public int compare(    IOverloadedOpsTypesProvider o1,    IOverloadedOpsTypesProvider o2){
      int i=o1.compareTo(o2);
      if (i == 0) {
        severalRules[0]=true;
      }
      return i;
    }
  }
);
  if (severalRules[0]) {
    LOG.warning("several overloaded rules found for operation",operation);
  }
  for (  IOverloadedOpsTypesProvider provider : filteredProviders) {
    SNode result=provider.getOperationType(operation,leftOperandType,rightOperandType);
    if (result != null) {
      return result;
    }
  }
  return null;
}
