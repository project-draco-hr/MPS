{
  Set<IOverloadedOpsTypesProvider> operationsTypesProviderSet=myOperationsToTypeProviders.getRules(operation);
  if (operationsTypesProviderSet.isEmpty()) {
    return null;
  }
  SubtypingManager subtypingManager=myTypeChecker.getSubtypingManager();
  List<IOverloadedOpsTypesProvider> filteredProviders=new ArrayList<IOverloadedOpsTypesProvider>();
  for (  IOverloadedOpsTypesProvider provider : operationsTypesProviderSet) {
    if (provider.isApplicable(subtypingManager,leftOperandType,rightOperandType) && provider.isApplicable(subtypingManager,operation,leftOperandType,rightOperandType)) {
      filteredProviders.add(provider);
    }
  }
  final boolean[] severalRules=new boolean[]{false};
  final IOverloadedOpsTypesProvider[] matchedProviders=new IOverloadedOpsTypesProvider[2];
  Collections.sort(filteredProviders,new Comparator<IOverloadedOpsTypesProvider>(){
    @Override public int compare(    IOverloadedOpsTypesProvider o1,    IOverloadedOpsTypesProvider o2){
      int i=o1.compareTo(o2);
      if (i == 0) {
        severalRules[0]=true;
        matchedProviders[0]=o1;
        matchedProviders[1]=o2;
      }
      return i;
    }
  }
);
  if (severalRules[0]) {
    matchedProviders[0].reportConflict(warningProducer);
    matchedProviders[1].reportConflict(warningProducer);
  }
  for (  IOverloadedOpsTypesProvider provider : filteredProviders) {
    SNode result=provider.getOperationType(operation,leftOperandType,rightOperandType);
    if (result != null) {
      return result;
    }
  }
  return null;
}
