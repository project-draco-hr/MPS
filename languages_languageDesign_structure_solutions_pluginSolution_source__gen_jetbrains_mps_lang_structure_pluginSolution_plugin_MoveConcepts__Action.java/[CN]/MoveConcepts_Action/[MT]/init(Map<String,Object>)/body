{
  final Wrappers._boolean canRefactor=new Wrappers._boolean(false);
  final Wrappers._boolean hasGenerator=new Wrappers._boolean(false);
  ModelAccess.instance().runReadAction(new Runnable(){
    public void run(){
      final SModel model=SNodeOperations.getModel(ListSequence.fromList(((List<SNode>)MapSequence.fromMap(_params).get("target"))).first());
      canRefactor.value=ListSequence.fromList(((List<SNode>)MapSequence.fromMap(_params).get("target"))).all(new IWhereFilter<SNode>(){
        public boolean accept(        SNode node){
          return SNodeOperations.getModel(node) == model;
        }
      }
);
      hasGenerator.value=ListSequence.fromList(((List<SNode>)MapSequence.fromMap(_params).get("target"))).any(new IWhereFilter<SNode>(){
        public boolean accept(        SNode node){
          return ListSequence.fromList(AbstractConceptDeclaration_Behavior.call_findGeneratorFragments_6409339300305625383(node)).isNotEmpty();
        }
      }
);
    }
  }
);
  if (!(canRefactor.value)) {
    Messages.showErrorDialog("All concept should be from the same language.","Move concepts");
    return false;
  }
  if (hasGenerator.value) {
    Messages.showWarningDialog("Generator fragments will not be moved.","Move concepts");
  }
  return true;
}
