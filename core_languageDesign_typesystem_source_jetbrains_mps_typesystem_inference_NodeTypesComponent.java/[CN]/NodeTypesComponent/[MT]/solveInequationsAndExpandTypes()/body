{
  myEquationManager.solveInequations();
  getSlicer().beforeTypesExpanded(myNodesToTypesMap);
  if (myIsSmartCompletion) {
    myHoleTypeWrapper.getInequationSystem().normalize();
  }
  for (  Entry<SNode,SNode> contextEntry : new HashSet<Entry<SNode,SNode>>(myNodesToTypesMap.entrySet())) {
    SNode term=contextEntry.getKey();
    if (term == null)     continue;
    SNode type=expandType(term,contextEntry.getValue(),myTypeChecker.getRuntimeTypesModel());
    if (BaseAdapter.isInstance(type,RuntimeErrorType.class)) {
      RuntimeErrorType errorType=(RuntimeErrorType)BaseAdapter.fromNode(type);
      reportTypeError(term,errorType.getErrorText(),errorType.getNodeModel(),errorType.getNodeId());
    }
    myNodesToTypesMap.put(term,type);
  }
}
