{
  myEquationManager.solveInequations();
  getSlicer().beforeTypesExpanded(myNodesToTypesMap);
  if (myIsSmartCompletion) {
    myHoleTypeWrapper=HoleWrapper.createHoleWrapper(myEquationManager,myHoleTypeWrapper);
    myHoleTypeWrapper.getInequationSystem().normalize();
  }
  for (  Entry<SNode,SNode> contextEntry : new HashSet<Entry<SNode,SNode>>(myNodesToTypesMap.entrySet())) {
    SNode term=contextEntry.getKey();
    if (term == null)     continue;
    SNode type=expandTypeAndPutToContext(term);
    if (type != null && (RuntimeErrorType.concept.equals(type.getConceptFqName()))) {
      RuntimeErrorType errorType=(RuntimeErrorType)BaseAdapter.fromNode(type);
      reportTypeError(term,errorType.getErrorText(),errorType.getNodeModel(),errorType.getNodeId());
    }
  }
}
