{
  if (node == null)   return;
  Set<SNode> frontier=new LinkedHashSet<SNode>();
  Set<SNode> newFrontier=new LinkedHashSet<SNode>();
  frontier.add(node);
  frontier.addAll(additionalNodes);
  if (myIsSmartCompletion) {
    myHoleTypeWrapper=HoleWrapper.createHoleWrapper(myEquationManager,myHoleTypeWrapper);
    if (!myHoleIsAType) {
      myNodesToTypesMap.put(myHole,myHoleTypeWrapper.getNode());
    }
  }
  while (!(frontier.isEmpty())) {
    for (    SNode sNode : frontier) {
      if (myFullyCheckedNodes.contains(sNode)) {
        continue;
      }
      if (myIsSpecial) {
        newFrontier.addAll(myTypeChecker.getRulesManager().getDependencies(sNode));
      }
      if (forceChildrenCheck) {
        newFrontier.addAll(sNode.getChildren());
      }
      if (!myPartlyCheckedNodes.contains(sNode)) {
        myNotSkippedNodes.add(new SNodePointer(sNode));
        myCurrentFrontier=newFrontier;
        MyLanguageCachesReadListener languageCachesReadListener=null;
        if (isIncrementalMode()) {
          languageCachesReadListener=new MyLanguageCachesReadListener();
          myNodesReadListener.clear();
          NodeReadEventsCaster.setNodesReadListener(myNodesReadListener);
          LanguageHierarchyCache.getInstance().setReadAccessListener(languageCachesReadListener);
        }
        try {
          applyRulesToNode(sNode);
        }
  finally {
          if (isIncrementalMode()) {
            LanguageHierarchyCache.getInstance().removeReadAccessListener();
            NodeReadEventsCaster.removeNodesReadListener();
          }
          myCurrentFrontier=null;
        }
        if (isIncrementalMode()) {
synchronized (ACCESS_LOCK) {
            myNodesReadListener.setAccessReport(true);
            Set<SNode> accessedNodes=myNodesReadListener.myAccessedNodes;
            addDepedentNodesTypesystem(sNode,accessedNodes);
            myNodesReadListener.setAccessReport(false);
            if (languageCachesReadListener != null) {
              languageCachesReadListener.setAccessReport(true);
              if (languageCachesReadListener.myIsCacheAccessed) {
                addCacheDependentNodesTypesystem(sNode);
              }
              languageCachesReadListener.setAccessReport(false);
            }
          }
          myNodesReadListener.clear();
        }
        myPartlyCheckedNodes.add(sNode);
      }
      myFullyCheckedNodes.add(sNode);
    }
    frontier=newFrontier;
    newFrontier=new LinkedHashSet<SNode>();
  }
}
