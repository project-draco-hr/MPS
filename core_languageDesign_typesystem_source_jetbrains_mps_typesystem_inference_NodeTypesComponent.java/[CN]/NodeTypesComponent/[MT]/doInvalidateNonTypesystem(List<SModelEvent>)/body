{
  Set<Pair<SNode,NonTypesystemRule_Runtime>> invalidatedNodesAndRules=new HashSet<Pair<SNode,NonTypesystemRule_Runtime>>();
  for (  SNode node : myCurrentNodesToInvalidateNonTypesystem) {
    WeakHashMap<SNode,Set<NonTypesystemRule_Runtime>> nodesAndRules=myNodesToDependentNodesWithNTRules.get(node);
    if (nodesAndRules != null) {
      for (      SNode nodeOfRule : nodesAndRules.keySet()) {
        Set<NonTypesystemRule_Runtime> rules=nodesAndRules.get(nodeOfRule);
        if (rules != null) {
          for (          NonTypesystemRule_Runtime rule : rules) {
            invalidatedNodesAndRules.add(new Pair<SNode,NonTypesystemRule_Runtime>(nodeOfRule,rule));
          }
        }
      }
    }
  }
  for (  Pair<SNode,NonTypesystemRule_Runtime> nodeAndRule : invalidatedNodesAndRules) {
    myCheckedNodesNonTypesystem.remove(nodeAndRule);
    Map<NonTypesystemRule_Runtime,Set<IErrorReporter>> rulesAndErrors=myNodesAndNTRulesToErrors.get(nodeAndRule.o1);
    if (rulesAndErrors != null) {
      Set<IErrorReporter> errors=rulesAndErrors.get(nodeAndRule.o2);
      if (errors != null) {
        for (        IErrorReporter errorReporter : errors) {
          Stack<IErrorReporter> iErrorReporters=myNodesToNonTypesystemErrorsMap.get(errorReporter.getSNode());
          if (iErrorReporters != null) {
            iErrorReporters.remove(errorReporter);
          }
        }
      }
    }
  }
  myCurrentNodesToInvalidateNonTypesystem.clear();
}
