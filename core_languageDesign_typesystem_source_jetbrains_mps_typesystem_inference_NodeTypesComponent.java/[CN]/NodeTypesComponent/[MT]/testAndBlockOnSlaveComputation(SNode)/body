{
  boolean result=false;
  Set<AbstractDependentComputation_Runtime> dependentComputations=myTypeChecker.getRulesManager().getDependentComputations(node);
  for (  AbstractDependentComputation_Runtime dependentComputation : dependentComputations) {
    SNode blockingNode=dependentComputation.getBlockingNode(node);
    if (blockingNode != null) {
      if (!myComputedBlockingTerms.contains(blockingNode)) {
        if (blockingNode.getAncestors(true).contains(node)) {
          LOG.warning("blocking node is a descendant of blocked node, will be never unblocked ",blockingNode);
          LOG.warning("MPS typesystem will not block node type computation ",node);
          continue;
        }
        result=true;
        Set<SNode> nodes=myBlockedOnSlaveComputation.get(blockingNode);
        if (nodes == null) {
          nodes=new HashSet<SNode>(1);
          myBlockedOnSlaveComputation.put(blockingNode,nodes);
        }
        nodes.add(node);
      }
    }
  }
  return result;
}
