{
  SModel sourceModel=sourceModelDescriptor.getSModel();
  addProgressMessage(MessageKind.INFORMATION,"generating model \"" + sourceModel.getUID() + "\"");
  Class<? extends IModelGenerator> defaultGeneratorClass=getDefaultGeneratorClass(targetLanguage);
  addMessage(MessageKind.INFORMATION,"    default generator class: " + (defaultGeneratorClass != null ? defaultGeneratorClass.getName() : "<n/a>"));
  GenerationSessionContext context=new GenerationSessionContext(targetLanguage,sourceModel,myInvocationContext,mappings);
  List<Generator> generators=context.getGeneratorModules();
  if (generators.isEmpty()) {
    addProgressMessage(MessageKind.WARNING,"skip model \"" + sourceModel.getUID() + "\" : no generator avalable");
    return new GenerationStatus(sourceModel,null,null,false,false);
  }
  setGenerationSessionContext(context);
  Class<? extends IModelGenerator> currentGeneratorClass=null;
  for (  Generator generator : generators) {
    Class<? extends IModelGenerator> generatorClass=getGeneratorClass(generator);
    addMessage(MessageKind.INFORMATION,"    generator found: " + generator.getModuleUID() + " generator class: "+ (generatorClass != null ? generatorClass.getName() : "<default>"));
    if (generatorClass != null) {
      if (currentGeneratorClass == null) {
        currentGeneratorClass=generatorClass;
        continue;
      }
      if (currentGeneratorClass.isAssignableFrom(generatorClass)) {
        currentGeneratorClass=generatorClass;
      }
 else       if (!generatorClass.isAssignableFrom(currentGeneratorClass)) {
        addProgressMessage(MessageKind.ERROR,"couldn't choose generator class");
        addMessage(MessageKind.ERROR,"generator classes \"" + currentGeneratorClass.getName() + "\" and "+ generatorClass.getName()+ " are not compatible");
        return new GenerationStatus.ERROR(sourceModel);
      }
    }
  }
  if (currentGeneratorClass == null) {
    if (defaultGeneratorClass == null) {
      addProgressMessage(MessageKind.ERROR,"generator class is not defined");
      return new GenerationStatus.ERROR(sourceModel);
    }
    currentGeneratorClass=defaultGeneratorClass;
  }
  addMessage(MessageKind.INFORMATION,"    use generator class: \"" + currentGeneratorClass + "\"");
  if (!ITemplateGenerator.class.isAssignableFrom(currentGeneratorClass)) {
    IModelGenerator handCodedGenerator=currentGeneratorClass.getConstructor(IOperationContext.class).newInstance(context);
    SModelDescriptor outputModel=createTransientModel(sourceModel,context.getModule());
    handCodedGenerator.generate(sourceModel,outputModel.getSModel());
    return new GenerationStatus(sourceModel,outputModel.getSModel(),null,false,false);
  }
  ITemplateGenerator generator=(ITemplateGenerator)currentGeneratorClass.getConstructor(GenerationSessionContext.class,IAdaptiveProgressMonitor.class).newInstance(context,myProgressMonitor);
  GenerationStatus status;
  try {
    SModel outputModel=generateModel(sourceModel,targetLanguage,generator);
    boolean wasErrors=generator.getErrorCount() > 0;
    status=new GenerationStatus(sourceModel,outputModel,context.getTraceMap(),wasErrors,false);
    addMessage(status.isError() ? MessageKind.WARNING : MessageKind.INFORMATION,"model \"" + sourceModel.getUID() + "\" has been generated "+ (status.isError() ? "with errors" : "successfully"));
    generator.reset();
  }
 catch (  GenerationCanceledException gce) {
    throw gce;
  }
catch (  GenerationFailedException gfe) {
    LOG.error(gfe);
    myProgressMonitor.addText(gfe.toString());
    GenerationFailueInfo failueInfo=gfe.getFailueInfo();
    if (failueInfo != null) {
      for (      Message message : failueInfo.createMessages()) {
        addMessage(message);
      }
    }
    addMessage(MessageKind.ERROR,"model \"" + sourceModel.getUID() + "\" generation failed : "+ gfe);
    status=new GenerationStatus.ERROR(sourceModel);
  }
catch (  Exception e) {
    LOG.error(e);
    myProgressMonitor.addText(e.toString());
    addMessage(MessageKind.ERROR,"model \"" + sourceModel.getUID() + "\" generation failed : "+ e);
    status=new GenerationStatus.ERROR(sourceModel);
  }
  return status;
}
