{
  ExitCode status=ExitCode.NOTHING_DONE;
  try {
    final Set<ModuleBuildTarget> targets=new HashSet<ModuleBuildTarget>();
    dirtyFilesHolder.processDirtyFiles(new FileProcessor<JavaSourceRootDescriptor,ModuleBuildTarget>(){
      @Override public boolean apply(      ModuleBuildTarget target,      File file,      JavaSourceRootDescriptor javaSourceRootDescriptor) throws IOException {
        LOG.debug("Dirty file " + file + " in the target "+ target);
        targets.add(target);
        return true;
      }
    }
);
    boolean isMPSChunk=false;
    boolean sourceGenNotInScope=false;
    for (    JpsModule jpsModule : moduleChunk.getModules()) {
      JpsMPSModuleExtension extension=JpsMPSExtensionService.getInstance().getExtension(jpsModule);
      if (extension == null) {
        continue;
      }
      isMPSChunk=true;
      if (!targets.isEmpty()) {
        boolean inScope=false;
        for (        ModuleBuildTarget target : targets) {
          File generatorOutputFile=new File(extension.getConfiguration().getGeneratorOutputPath());
          if (compileContext.getScope().isAffected(target,generatorOutputFile)) {
            inScope=true;
            break;
          }
        }
        if (!inScope) {
          sourceGenNotInScope=true;
          break;
        }
      }
    }
    if (!isMPSChunk) {
      return status;
    }
    if (sourceGenNotInScope) {
      compileContext.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID,Kind.ERROR,"Compile scope is too narrow. MPS generated sources would be out of scope"));
      return ExitCode.ABORT;
    }
    JpsMPSRepositoryFacade.getInstance().init(compileContext);
    final Map<SModel,ModuleBuildTarget> toMake=collectChangedModels(compileContext,dirtyFilesHolder);
    if (toMake.isEmpty()) {
      LOG.debug("Nothing to do");
      return status;
    }
    MPSMakeMediator makeMediator=new MPSMakeMediator(JpsMPSRepositoryFacade.getInstance().getProject(),toMake,compileContext,refreshComponent,outputConsumer);
    boolean success=makeMediator.build();
    if (success) {
      status=ExitCode.OK;
    }
  }
 catch (  Exception ex) {
    throw new ProjectBuildException(ex);
  }
  if (MPSCompilerUtil.isTracingMode()) {
    compileContext.processMessage(new CompilerMessage(MPSMakeConstants.BUILDER_ID,Kind.WARNING,"<simple warning to show Messages tool>"));
  }
  return status;
}
