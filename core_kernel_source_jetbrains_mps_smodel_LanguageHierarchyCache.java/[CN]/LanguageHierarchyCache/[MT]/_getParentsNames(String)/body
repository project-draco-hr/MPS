{
synchronized (myParentsNamesLock) {
    List<String> result=myParentsNamesMap.get(conceptFqName);
    if (result == null) {
      result=NodeReadAccessCasterInEditor.runReadTransparentAction(new Computable<List<String>>(){
        @Override public List<String> compute(){
          SNode declaration=SModelUtil.findConceptDeclaration(conceptFqName);
          if (declaration == null) {
            return Collections.emptyList();
          }
          List<String> result=new ArrayList<String>();
          Set<String> parentsSet=new HashSet<String>();
          if (SNodeUtil.isInstanceOfConceptDeclaration(declaration)) {
            SNode superConcept=SNodeUtil.getConceptDeclaration_Extends(declaration);
            if (superConcept != null) {
              String name=NameUtil.nodeFQName(superConcept);
              if (parentsSet.add(name)) {
                result.add(name);
              }
            }
 else             if (!SNodeUtil.concept_BaseConcept.equals(NameUtil.nodeFQName(declaration))) {
              if (parentsSet.add(SNodeUtil.concept_BaseConcept)) {
                result.add(SNodeUtil.concept_BaseConcept);
              }
            }
            for (            SNode interfaceConcept : SNodeUtil.getConceptDeclaration_Implements(declaration)) {
              String name=NameUtil.nodeFQName(interfaceConcept);
              if (parentsSet.add(name)) {
                result.add(name);
              }
            }
          }
 else           if (SNodeUtil.isInstanceOfInterfaceConceptDeclaration(declaration)) {
            for (            SNode interfaceConcept : SNodeUtil.getInterfaceConceptDeclaration_Extends(declaration)) {
              String name=NameUtil.nodeFQName(interfaceConcept);
              if (parentsSet.add(name)) {
                result.add(name);
              }
            }
          }
          return result;
        }
      }
);
      myParentsNamesMap.put(InternUtil.intern(conceptFqName),Collections.unmodifiableList(result));
    }
    return result;
  }
}
