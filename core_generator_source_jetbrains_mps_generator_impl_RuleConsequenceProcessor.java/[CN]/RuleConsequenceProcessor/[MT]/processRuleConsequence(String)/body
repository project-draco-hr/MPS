{
  ArrayList<SNode> outputNodes=new ArrayList<SNode>();
  for (  Pair<SNode,String> nodeAndMappingNamePair : myNodeAndMappingNamePairs) {
    SNode templateNode=nodeAndMappingNamePair.o1;
    String innerMappingName=nodeAndMappingNamePair.o2 != null ? nodeAndMappingNamePair.o2 : mappingName;
    try {
      List<SNode> _outputNodes=myTemplateProcessor.applyTemplate(innerMappingName,templateNode,myConsequenceContext.subContext(innerMappingName),null);
      if (_outputNodes != null) {
        outputNodes.addAll(_outputNodes);
      }
    }
 catch (    TemplateProcessingFailureException ex) {
      TemplateExecutionEnvironment env=myTemplateProcessor.getEnvironment();
      env.getGenerator().showErrorMessage(myConsequenceContext.getInput(),myRuleNode,"error processing template fragment");
    }
catch (    Throwable t) {
      TemplateExecutionEnvironment env=myTemplateProcessor.getEnvironment();
      env.getLogger().handleException(t);
      env.getGenerator().showErrorMessage(myConsequenceContext.getInput(),templateNode,myRuleNode,"error processing template fragment");
    }
  }
  return outputNodes;
}
