{
  final Wrappers._T<Iterable<SModelReference>> modelReferences=new Wrappers._T<Iterable<SModelReference>>();
  ModelAccess.instance().runReadAction(new Runnable(){
    public void run(){
      Iterable<IModule> modules=MPSModuleRepository.getInstance().getAllModules();
      if (LOG.isEnabledFor(Priority.WARN)) {
        LOG.warn("Modules: " + Sequence.fromIterable(modules).count());
      }
      modelReferences.value=Sequence.fromIterable(modules).translate(new ITranslator2<IModule,SModel>(){
        public Iterable<SModel> translate(        IModule it){
          return it.getModels();
        }
      }
).select(new ISelector<SModel,SModelReference>(){
        public SModelReference select(        SModel it){
          return it.getReference();
        }
      }
);
      if (LOG.isEnabledFor(Priority.WARN)) {
        LOG.warn("Models: " + Sequence.fromIterable(modelReferences.value).count());
      }
    }
  }
);
  monitor.start(actionName,Sequence.fromIterable(modelReferences.value).count());
  try {
    final Wrappers._int num=new Wrappers._int(0);
    for (    final SModelReference modelRef : modelReferences.value) {
      ModelAccess.instance().runReadAction(new Runnable(){
        public void run(){
          UnregisteredNodes.instance().clear();
          if (num.value++ % 100 == 0) {
            if (LOG.isEnabledFor(Priority.WARN)) {
              LOG.warn("Model num: " + num.value + ", name: "+ SModelStereotype.withoutStereotype(modelRef.getModelName()));
            }
          }
          SModel model=SModelRepository.getInstance().getModelDescriptor(modelRef);
          if (model != null) {
            for (            SNode node : new NodesIterable(model)) {
              try {
                nodeCallback.invoke(node);
              }
 catch (              Throwable t) {
                if (LOG.isEnabledFor(Priority.ERROR)) {
                  LOG.error("Exception in callback for node " + node,t);
                }
              }
            }
          }
        }
      }
);
      monitor.advance(1);
      if (monitor.isCanceled()) {
        break;
      }
    }
  }
  finally {
    monitor.done();
  }
}
