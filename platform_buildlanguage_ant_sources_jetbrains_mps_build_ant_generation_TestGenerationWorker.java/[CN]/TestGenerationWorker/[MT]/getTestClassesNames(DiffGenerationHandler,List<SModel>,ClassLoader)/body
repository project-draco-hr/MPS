{
  List<String> testClasses=new ArrayList<String>();
  Condition<SNode> nodeCond=new Condition<SNode>(){
    public boolean met(    SNode node){
      return node.isInstanceOfConcept(ClassConcept.concept);
    }
  }
;
  for (  final SModel model : outputModels) {
    Iterable<SNode> iterable=new ConditionalIterable<SNode>(model.roots(),nodeCond);
    for (    final SNode outputRoot : iterable) {
      if (baseClassLoader == null) {
        model.getClass().getClassLoader();
      }
      ClassLoader classLoader=generationHandler.getCompiler().getClassLoader(baseClassLoader);
      try {
        String className=ModelAccess.instance().runReadAction(new Computable<String>(){
          public String compute(){
            return model.getLongName() + "." + outputRoot.getName();
          }
        }
);
        final Class testClass=Class.forName(className,true,classLoader);
        if (Modifier.isAbstract(testClass.getModifiers()) || Modifier.isInterface(testClass.getModifiers()))         continue;
        if (Modifier.isPrivate(testClass.getModifiers()))         continue;
        if (testClass.getAnnotation(classLoader.loadClass(MPSLaunch.class.getName())) != null)         continue;
        Class<TestCase> testCaseClass=(Class<TestCase>)classLoader.loadClass(TestCase.class.getName());
        if (testCaseClass.isAssignableFrom(testClass)) {
          boolean hasTestMethods=false;
          for (          Method m : testClass.getDeclaredMethods()) {
            if (m.getName().startsWith("test") && Modifier.isPublic(m.getModifiers()) && (m.getParameterTypes().length == 0)&& m.getReturnType().equals(void.class)) {
              hasTestMethods=true;
              break;
            }
          }
          if (hasTestMethods) {
            testClasses.add(className);
          }
        }
      }
 catch (      java.lang.ExceptionInInitializerError ignored) {
      }
catch (      Throwable throwable) {
        log(throwable);
      }
    }
  }
  return testClasses;
}
