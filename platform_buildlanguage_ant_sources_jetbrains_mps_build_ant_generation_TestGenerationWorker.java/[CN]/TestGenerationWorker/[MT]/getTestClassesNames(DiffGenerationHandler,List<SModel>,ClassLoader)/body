{
  List<String> testClasses=new ArrayList<String>();
  for (  final SModel model : outputModels) {
    for (    final SNode outputRoot : model.getRoots()) {
      if (baseClassLoader == null) {
        model.getClass().getClassLoader();
      }
      ClassLoader classLoader=generationHandler.getCompiler().getClassLoader(baseClassLoader);
      Boolean isNotClassConcept=ModelAccess.instance().runReadAction(new Computable<Boolean>(){
        public Boolean compute(){
          return !outputRoot.isInstanceOfConcept(ClassConcept.concept);
        }
      }
);
      if (isNotClassConcept) {
        continue;
      }
      try {
        String className=ModelAccess.instance().runReadAction(new Computable<String>(){
          public String compute(){
            return model.getLongName() + "." + outputRoot.getName();
          }
        }
);
        final Class testClass=Class.forName(className,true,classLoader);
        if (Modifier.isAbstract(testClass.getModifiers()) || Modifier.isInterface(testClass.getModifiers()))         continue;
        if (Modifier.isPrivate(testClass.getModifiers()))         continue;
        if (testClass.getAnnotation(classLoader.loadClass(MPSLaunch.class.getName())) != null)         continue;
        Class<TestCase> testCaseClass=(Class<TestCase>)classLoader.loadClass(TestCase.class.getName());
        if (testCaseClass.isAssignableFrom(testClass)) {
          boolean hasTestMethods=false;
          for (          Method m : testClass.getDeclaredMethods()) {
            if (m.getName().startsWith("test") && Modifier.isPublic(m.getModifiers()) && (m.getParameterTypes().length == 0)&& m.getReturnType().equals(void.class)) {
              hasTestMethods=true;
              break;
            }
          }
          if (hasTestMethods) {
            testClasses.add(className);
          }
        }
      }
 catch (      java.lang.ExceptionInInitializerError ignored) {
      }
catch (      Throwable throwable) {
        log(throwable);
      }
    }
  }
  return testClasses;
}
