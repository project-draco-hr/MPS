{
  Set<IWrapper> types=subtypingGraphVertices();
  boolean hasConcreteTypes=true;
  int priority=0;
  while (hasConcreteTypes) {
    int[] minPriority=new int[]{Integer.MAX_VALUE};
    startCollectingConcretes();
    hasConcreteTypes=false;
    for (    IWrapper type : types) {
      if (type == null)       continue;
      if (getRepresentatorWrapper(type).equals(holeTypeWrapper))       continue;
      if (!type.isConcrete()) {
        typeLessThanVar(type,true,priority,minPriority,shallow,holeTypeWrapper);
        typeLessThanVar(type,false,priority,minPriority,shallow,holeTypeWrapper);
        varLessThanType(type,true,priority,minPriority,shallow,holeTypeWrapper);
        varLessThanType(type,false,priority,minPriority,shallow,holeTypeWrapper);
      }
 else       if ((shallow && type.isConcrete()) || (!shallow && isConcrete(type))) {
        if (shallow && holeTypeWrapper == null) {
          hasConcreteTypes=true;
        }
        hasConcreteTypes=typeLessThanConcrete(type,true,priority,minPriority,shallow,holeTypeWrapper) || hasConcreteTypes;
        hasConcreteTypes=typeLessThanConcrete(type,false,priority,minPriority,shallow,holeTypeWrapper) || hasConcreteTypes;
        hasConcreteTypes=concreteLessThanType(type,true,priority,minPriority,shallow,holeTypeWrapper) || hasConcreteTypes;
        hasConcreteTypes=concreteLessThanType(type,false,priority,minPriority,shallow,holeTypeWrapper) || hasConcreteTypes;
      }
    }
    processConcretes();
    if (minPriority[0] < Integer.MAX_VALUE && minPriority[0] > priority) {
      priority=minPriority[0];
    }
    types=subtypingGraphVertices();
  }
  return types;
}
