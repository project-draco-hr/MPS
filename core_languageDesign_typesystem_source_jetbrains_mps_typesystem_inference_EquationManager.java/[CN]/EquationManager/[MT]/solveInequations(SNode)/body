{
  IWrapper holeWrapper=null;
  SNode holeType=myTypeCheckingContext.getMainContext().get(hole);
  if (hole != null) {
    holeWrapper=NodeWrapper.fromNode(holeType,this);
  }
  eliminateConcretePartsOfInequations(false,holeWrapper);
  Set<IWrapper> types=eliminateConcretePartsOfInequations(true,holeWrapper);
  InequationSystem inequationSystem=new InequationSystem(this,holeType);
  ISlicer slicer=myTypeCheckingContext.getCurrentSlicer();
  for (  IWrapper type : types) {
    if (type == null)     continue;
    Map<IWrapper,EquationInfo> supertypes=mySubtypesToSupertypesMap.get(type);
    if (supertypes != null) {
      mySubtypesToSupertypesMap.remove(type);
      for (      IWrapper supertype : supertypes.keySet()) {
        mySupertypesToSubtypesMap.get(supertype).remove(type);
        IWrapper holeRepresentatorWrapper=getRepresentatorWrapper(holeWrapper);
        if (getRepresentatorWrapper(supertype).equals(holeRepresentatorWrapper) || getRepresentatorWrapper(type).equals(holeRepresentatorWrapper)) {
          inequationSystem.addInequation(holeRepresentatorWrapper.getNode(),supertype.getNode(),false);
        }
 else {
          EquationInfo errorInfo=supertypes.get(supertype);
          slicer.beforeInequationTriggeredEquationAdded(type.getNode(),supertype.getNode(),errorInfo);
          addEquation(type,supertype,errorInfo);
        }
      }
    }
    Map<IWrapper,EquationInfo> subtypes=mySupertypesToSubtypesMap.get(type);
    if (subtypes != null) {
      mySupertypesToSubtypesMap.remove(type);
      for (      IWrapper subtype : subtypes.keySet()) {
        mySubtypesToSupertypesMap.get(subtype).remove(type);
        IWrapper holeRepresentatorWrapper=getRepresentatorWrapper(holeWrapper);
        if (getRepresentatorWrapper(subtype).equals(holeRepresentatorWrapper) || getRepresentatorWrapper(type).equals(holeRepresentatorWrapper)) {
          inequationSystem.addInequation(subtype.getNode(),holeRepresentatorWrapper.getNode(),false);
        }
 else {
          EquationInfo errorInfo=subtypes.get(subtype);
          slicer.beforeInequationTriggeredEquationAdded(type.getNode(),subtype.getNode(),errorInfo);
          addEquation(type,subtype,errorInfo);
        }
      }
    }
    Map<IWrapper,EquationInfo> supertypesStrong=mySubtypesToSupertypesMapStrong.get(type);
    if (supertypesStrong != null) {
      mySubtypesToSupertypesMapStrong.remove(type);
      for (      IWrapper supertype : supertypesStrong.keySet()) {
        mySupertypesToSubtypesMapStrong.get(supertype).remove(type);
        IWrapper holeRepresentatorWrapper=getRepresentatorWrapper(holeWrapper);
        if (getRepresentatorWrapper(supertype).equals(holeRepresentatorWrapper) || getRepresentatorWrapper(type).equals(holeRepresentatorWrapper)) {
          inequationSystem.addInequation(holeRepresentatorWrapper.getNode(),supertype.getNode(),true);
        }
 else {
          EquationInfo errorInfo=supertypesStrong.get(supertype);
          slicer.beforeInequationTriggeredEquationAdded(type.getNode(),supertype.getNode(),errorInfo);
          addEquation(type,supertype,errorInfo);
        }
      }
    }
    Map<IWrapper,EquationInfo> subtypesStrong=mySupertypesToSubtypesMapStrong.get(type);
    if (subtypesStrong != null) {
      mySupertypesToSubtypesMapStrong.remove(type);
      for (      IWrapper subtype : subtypesStrong.keySet()) {
        mySubtypesToSupertypesMapStrong.get(subtype).remove(type);
        IWrapper holeRepresentatorWrapper=getRepresentatorWrapper(holeWrapper);
        if (getRepresentatorWrapper(subtype).equals(holeRepresentatorWrapper) || getRepresentatorWrapper(type).equals(holeRepresentatorWrapper)) {
          inequationSystem.addInequation(subtype.getNode(),holeRepresentatorWrapper.getNode(),true);
        }
 else {
          EquationInfo errorInfo=subtypesStrong.get(subtype);
          slicer.beforeInequationTriggeredEquationAdded(type.getNode(),subtype.getNode(),errorInfo);
          addEquation(type,subtype,errorInfo);
        }
      }
    }
  }
  processCheckingEquations();
  return inequationSystem;
}
