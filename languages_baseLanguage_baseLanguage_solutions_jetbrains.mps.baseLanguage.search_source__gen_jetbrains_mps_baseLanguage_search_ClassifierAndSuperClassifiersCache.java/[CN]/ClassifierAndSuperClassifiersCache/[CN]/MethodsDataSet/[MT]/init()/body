{
  List<SNode> allMethods=new ArrayList<SNode>();
  List<SNode> classifiers=((ClassifierAndSuperClassifiersCache)this.getOwnerCache()).getClassifiers();
  for (  SNode classifier : classifiers) {
    ListSequence.fromList(allMethods).addSequence(Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>)((Class)Object.class),classifier,"jetbrains.mps.baseLanguage.structure.Classifier","call_methods_5292274854859311639",new Object[]{})));
    ListSequence.fromList(allMethods).addSequence(Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>)((Class)Object.class),classifier,"jetbrains.mps.baseLanguage.structure.Classifier","call_staticMethods_8353022880012524412",new Object[]{})));
  }
  this.myMethodsByName=MapSequence.fromMap(new HashMap<String,List<SNode>>());
  this.myOverriddenMethods=MapSequence.fromMap(new HashMap<SNode,List<SNode>>());
  forEachInAllMethods:   for (  SNode currMethod : allMethods) {
    String name=SPropertyOperations.getString(currMethod,MetaAdapterFactory.getProperty(0xceab519525ea4f22L,0x9b92103b95ca8c0cL,0x110396eaaa4L,0x110396ec041L,"name"));
    if (name == null) {
      name="";
    }
    if (!(MapSequence.fromMap(this.myMethodsByName).containsKey(name))) {
      List<SNode> methods=new ArrayList<SNode>();
      methods.add(currMethod);
      MapSequence.fromMap(myMethodsByName).put(name,methods);
      MapSequence.fromMap(myOverriddenMethods).put(currMethod,new ArrayList<SNode>());
    }
 else {
      int currMethodParmCount=ListSequence.fromList(SLinkOperations.getChildren(currMethod,MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0xf8cc56b1fcL,0xf8cc56b1feL,"parameter"))).count();
      List<SNode> equalParmCountMethods=new ArrayList<SNode>();
      List<SNode> methods=MapSequence.fromMap(this.myMethodsByName).get(name);
      for (      SNode method : methods) {
        if ((SNodeOperations.getParent(currMethod) != SNodeOperations.getParent(method)) && ListSequence.fromList(SLinkOperations.getChildren(method,MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0xf8cc56b1fcL,0xf8cc56b1feL,"parameter"))).count() == currMethodParmCount) {
          equalParmCountMethods.add(method);
        }
      }
      if (equalParmCountMethods.size() > 0) {
        if (currMethodParmCount == 0) {
          ListSequence.fromList(MapSequence.fromMap(myOverriddenMethods).get(ListSequence.fromList(equalParmCountMethods).first())).addElement(currMethod);
          continue forEachInAllMethods;
        }
        Map<SNode,SNode> typeByTypeVar=((ClassifierAndSuperClassifiersCache)this.getOwnerCache()).getTypeByTypeVariableMap();
        String currentParms=this.createMethodParameterTypesString(currMethod,typeByTypeVar);
        for (        SNode otherMethod : equalParmCountMethods) {
          String otherParms=this.createMethodParameterTypesString(otherMethod,typeByTypeVar);
          if (otherParms.equals(currentParms)) {
            MapSequence.fromMap(this.myOverriddenMethods).get(otherMethod).add(currMethod);
            continue forEachInAllMethods;
          }
        }
      }
      ListSequence.fromList(MapSequence.fromMap(myMethodsByName).get(name)).addElement(currMethod);
      MapSequence.fromMap(myOverriddenMethods).put(currMethod,new ArrayList<SNode>());
    }
  }
  this.myDependsOnNodes=SetSequence.fromSet(new HashSet<SNode>());
  for (  SNode classifier : classifiers) {
    SetSequence.fromSet(this.myDependsOnNodes).addElement(classifier);
  }
  for (  SNode method : allMethods) {
    SetSequence.fromSet(this.myDependsOnNodes).addElement(method);
    for (    SNode parm : SLinkOperations.getChildren(method,MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0xf8cc56b1fcL,0xf8cc56b1feL,"parameter"))) {
      SNode type=SLinkOperations.getTarget(parm,MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L,0xa443f952ceaf5816L,0x450368d90ce15bc3L,0x4ed4d318133c80ceL,"type"));
      if (type == null) {
        continue;
      }
      SetSequence.fromSet(myDependsOnNodes).addElement(type);
      SetSequence.fromSet(myDependsOnNodes).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(type,null,false,new SAbstractConcept[]{})));
    }
  }
}
