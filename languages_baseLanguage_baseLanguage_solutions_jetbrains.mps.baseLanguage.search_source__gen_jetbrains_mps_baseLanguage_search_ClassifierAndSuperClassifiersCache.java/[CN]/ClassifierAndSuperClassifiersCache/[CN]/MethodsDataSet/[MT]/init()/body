{
  List<SNode> allMethods=new ArrayList<SNode>();
  List<SNode> classifiers=((ClassifierAndSuperClassifiersCache)this.getOwnerCache()).getClassifiers();
  for (  SNode classifier : classifiers) {
    allMethods.addAll(SLinkOperations.getTargets(classifier,"method",true));
    if (SNodeOperations.isInstanceOf(classifier,"jetbrains.mps.baseLanguage.structure.ClassConcept")) {
      allMethods.addAll(SLinkOperations.getTargets((SNodeOperations.cast(classifier,"jetbrains.mps.baseLanguage.structure.ClassConcept")),"staticMethod",true));
    }
  }
  this.myMethodsByName=MapSequence.fromMap(new HashMap<String,List<SNode>>());
  this.myOverriddenMethods=MapSequence.fromMap(new HashMap<SNode,List<SNode>>());
  forEachInAllMethods:   for (  SNode currMethod : allMethods) {
    if (SNodeOperations.isInstanceOf(currMethod,"jetbrains.mps.baseLanguage.structure.PlaceholderMethodDeclaration")) {
      continue;
    }
    String name=SPropertyOperations.getString(currMethod,"name");
    if (name == null) {
      name="";
    }
    if (!(MapSequence.fromMap(this.myMethodsByName).containsKey(name))) {
      List<SNode> methods=new ArrayList<SNode>();
      methods.add(currMethod);
      MapSequence.fromMap(myMethodsByName).put(name,methods);
      MapSequence.fromMap(myOverriddenMethods).put(currMethod,new ArrayList<SNode>());
    }
 else {
      int currMethodParmCount=ListSequence.fromList(SLinkOperations.getTargets(currMethod,"parameter",true)).count();
      List<SNode> equalParmCountMethods=new ArrayList<SNode>();
      List<SNode> methods=MapSequence.fromMap(this.myMethodsByName).get(name);
      for (      SNode method : methods) {
        if ((SNodeOperations.getParent(currMethod) != SNodeOperations.getParent(method)) && (int)ListSequence.fromList(SLinkOperations.getTargets(method,"parameter",true)).count() == currMethodParmCount) {
          equalParmCountMethods.add(method);
        }
      }
      if (equalParmCountMethods.size() > 0) {
        if (currMethodParmCount == 0) {
          ListSequence.fromList(MapSequence.fromMap(myOverriddenMethods).get(ListSequence.fromList(equalParmCountMethods).first())).addElement(currMethod);
          continue forEachInAllMethods;
        }
        Map<SNode,SNode> typeByTypeVar=((ClassifierAndSuperClassifiersCache)this.getOwnerCache()).getTypeByTypeVariableMap();
        String currentParms=this.createMethodParameterTypesString(currMethod,typeByTypeVar);
        for (        SNode otherMethod : equalParmCountMethods) {
          String otherParms=this.createMethodParameterTypesString(otherMethod,typeByTypeVar);
          if (otherParms.equals(currentParms)) {
            MapSequence.fromMap(this.myOverriddenMethods).get(otherMethod).add(currMethod);
            continue forEachInAllMethods;
          }
        }
      }
      ListSequence.fromList(MapSequence.fromMap(myMethodsByName).get(name)).addElement(currMethod);
      MapSequence.fromMap(myOverriddenMethods).put(currMethod,new ArrayList<SNode>());
    }
  }
  this.myDependsOnNodes=SetSequence.fromSet(new HashSet<SNode>());
  for (  SNode classifier : classifiers) {
    SetSequence.fromSet(this.myDependsOnNodes).addElement(classifier);
  }
  for (  SNode method : allMethods) {
    SetSequence.fromSet(this.myDependsOnNodes).addElement(method);
    for (    SNode parm : SLinkOperations.getTargets(method,"parameter",true)) {
      SNode type=SLinkOperations.getTarget(parm,"type",true);
      if (type == null) {
        continue;
      }
      SetSequence.fromSet(myDependsOnNodes).addElement(type);
      SetSequence.fromSet(myDependsOnNodes).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(type,null,false,new String[]{})));
    }
  }
}
